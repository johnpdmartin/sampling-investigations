---
title: "For L-functions without poles, spectrally filtered first quiescent region truncated partial Euler Product based estimates of Riemann Siegel Z functions can provide useful standalone approximations about the real axis across the critical strip."
author: "John Martin"
date: \today
header-includes:  \usepackage{xcolor}
output:
  pdf_document:
  fig_crop: no
---
  
  
  
  ```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)

```
<!-- https://stackoverflow.com/questions/41655383/r-markdown-similar-feature-to-newcommand-in-latex/41664105 -->
\newcommand{\mychi}{\raisebox{0pt}[1ex][1ex]{$\chi$}}

## DRAFT Executive summary 

For L-functions without poles on the real axis, truncated partial Euler Product based approximations of the Riemann Siegel Z analogue function spectrally filtered (and averaged over different spectra widths) using fourier analysis (n~150,000) of finite intervals $\Delta t=(-750,750)$ along the imaginary co-ordinate of the complex plane can produce useful approximations (without nuisance discontinuities) via the fixed truncation length condition $1.25\cdot \sqrt{(\frac{750}{2\pi})^d\cdot N_C}$ (compared to the varying truncation length $1.25\cdot \sqrt{(\frac{t}{2\pi})^d\cdot N_C}$ used as $t \rightarrow \infty$) across the critical strip. In this paper the averaging step in the fourier analysis is not performed as the non-trivial zeroes are well spaced near the real axis for the investigated L-functions without poles and the corresponding measured approximation errors of the final algorithm are sufficiently small in the central interval of the fourier analysis.  

## Introduction

This paper investigates the approximation accuracy around the real axis within the critical strip of inverse fourier transforms of the spectrally filtered and spliced fourier analysis of the partial Euler Product analogues of the zeroth order Riemann-Siegel formula to the true Riemann-Siegel Z function of two L-functions without poles (i) $L(\mychi(3,2),s)$ a first degree periodic dirichlet character L-function and (ii) the second degree L-function 2-13-1.1-c3-0-2 with conductor value 13. 

In particular, a comparison of the spectrally filtered partial Euler Product based approximation to the true Riemann-Siegel Z function analogue is presented firstly via (i) overlay graphs of the the central $-40 < t <40$ interval for a range of truncation lengths of the partial Euler Product and three real axis values within the critical strip and secondly via the approximation error with respect to real( Riemann-Siegel Z function) for the entire -750 < t < 750 fourier spectrum sample (used for fourier analysis). It is illustrated how nuisance discontinuities are progressively removed from the spectrally filtered partial Euler Product based approximation by raising the minimum prime in the partial Euler Product  from $\left\lfloor 1.25\cdot \max\left(1,\sqrt{(\frac{t}{2\pi})^d\cdot N_C}\right)\right\rfloor$ truncation (where the partial Euler product equals 1 if minimum prime < 2) to $\left\lfloor1.25\cdot\sqrt{(\frac{750}{2\pi})^{d}\cdot N_C}\right\rfloor$ where 750 matches the maximum t value of the input spectrum for fourier analysis.

To obtain useful spectrally filtered partial Euler Product approximations \textbf{off the critical line} the spectral filtering and splicing algorithm described by Martin [1-3] is modified to include explicit splicing of the informative parts of both the first and second components of the zeroth order Riemann-Siegel formula (using partial Euler Products). Whereas only one component of the zeroth order Riemann-Siegel formula is required for the splicing step of the spectrally filtered partial Euler Product approximation on the critical line because the conjugate symmetry reflection property of the (true Riemann-Siegel Z function) fourier transform can be invoked.  


As a contrast to the standalone accuracy of the spectrally filtered partial Euler Product approximation of the Riemann-Siegel Z function for L-functions without poles, the appendix presents the case of the Riemann Zeta function (which has a known real axis pole) where for example, in one approach the spectrally filtered partial Euler Product approach would need to be combined with the Riemann Zeta Laurent series to obtain useful approximations about the real axis. 


## L-functions, their Riemann-Siegel Z function analogue and the zeroth order Riemann-Siegel formula definition

Of interest to this paper  [4-7], the functional equation for a given L-function (and its dual L-function $\bar{L}$)

\begin{align}
L(\chi_d,s) &= \mychi(s)\bar{L}(\chi_d,2k-s) 
\end{align}

where (i) $\mychi(s)$ is the complex multiplicative factor of the functional equation of the L function which can be derived from the completed L-function functional equation $\Lambda(s)=\epsilon\bar{\Lambda}(2k-s)$, (ii) $\chi_d$ are the Dirichlet characters of the corresponding Dirichlet Series and (iii) k is the critical line of the L-function defined by its complex plane symmetry behaviour. 

The extended Riemann-Siegel Z function analogue of the L-function across the complex plane $s=\sigma+I\cdot t$

\begin{align}
Z_{extL}(\chi_d,s) &= e^{I\cdot\theta_{normextL}(s)}L(\chi_d,k-s)  \qquad \text{continuous function} \\
&= \sqrt{L(\chi_d,s)L(\chi_d,k-s)|\mychi(s)|}  \qquad \text{discontinuous version}
\end{align}

where the (normalised) extended Riemann-Siegel Theta function $\theta_{normextL}(t)$ is obtained from the definitions

\begin{align}
\frac{\mychi(s)}{|\mychi(s)|} &\equiv e^{-I\cdot 2\theta_{normextL}(s)} \\
\therefore \theta_{normextL}(s) &= -\frac{1}{2}\cdot imag\left[\log{\left(\mychi(s)\right)}\right]
\end{align}

where by using only the imaginary part of the logarithm in equation (5) $\therefore |\theta_{normextL}(s)|=1$ regardless of real(s), and hence 

\begin{equation}
\left|Z_{extL}(\chi_d,s)\right|\equiv\left|L(\chi_d,s)\right|
\end{equation}

is maintained in equation (2).

The \textbf{zeroth order} Riemann-Siegel formula approximation [8,9] symmetrically truncated at the first quiescent region $N_1=\sqrt{(\frac{t}{2\pi})^d\cdot N_C}$ and extended across the complex plane using $\theta_{normextL}(s)$ is of the form

\begin{align}
e^{I\cdot \theta_{extL}(s)}&L(s) &\approx e^{I\cdot \theta_{extL}(s)} \left[ \sum_{n=1}^{(\lfloor\sqrt{(\frac{t}{2\pi})^d\cdot N_C}\rfloor)} \frac{\chi_d(n)}{n^{(s)}}  \large+ \mychi(s) \cdot \sum_{n=1}^{(\lfloor\sqrt{(\frac{t}{2\pi})^d\cdot N_C}\rfloor)} \frac{\bar{\chi}_d(n)}{n^{(k-s)}} \right] +... \quad \text{as } t \rightarrow \infty
\end{align}

where (i) d is the degree of the L-function and (ii) $N_C$ is the conductor of the L-function.


## A fourier analysis procedure for cleaning zeroth order Riemann-Siegel formula based partial Euler product based calculations of the Riemann-Siegel Z function analogue including off the critical line

The partial Euler Product analogues of the first and second terms [1-3] in equation (7) 

For L-functions across the complex plane $s=\sigma+I\cdot t$

\begin{align}
EP_{RS1,L}(s,\beta) &= e^{I\cdot \theta_{extL}(s)} \prod_{p=2}^{P \le (\lfloor\beta\cdot\sqrt{(\frac{t}{2\pi})^d\cdot N_C}\rfloor)} F_{p,L}(p^{-(s)})^{-1}  \\
EP_{RS2,L}(s,\beta) &= e^{I\cdot \theta_{extL}(s)}\cdot\mychi(s) \cdot \prod_{p=2}^{P\le(\lfloor\beta\cdot\sqrt{(\frac{t}{2\pi})^d\cdot N_C}\rfloor)} F_{p,L}(p^{-(k-s)})^{-1} 
\end{align}

where (i) $F_{p,L}(p^{-(s)})^{-1}$ are the Euler factors of the L-function and (ii) $\beta \ge 1$ is a hyperparameter multiplicative factor included to adjust the primes included in the Euler product(s) for the purpose of reducing the effects of spectral leakage when used in conjunction fourier analysis of these partial Euler product(s). In this paper, $\beta=1.25$ will be used.  

Following [1-3], this paper illustrates within the critical strip around the real axis for (i) $L(\mychi(3,2),s)$ L-function, (ii) an elliptic curve L-function 13.4.a.a how the following fourier analysis procedure allows useful approximations of the Riemann-Siegel Z function analogues of these L-functions without poles via the partial Euler Product using $N_1$ (first quiescent region) of the zeroth order Riemann-Siegel formula approximation. 

This paper also illustrates a counterexample in the appendix, that the following fourier analysis procedure \textbf{does not fully approximate} in a standalone manner the Riemann-Siegel Z function of the Riemann Zeta L-functions around the real axis due to the presence of a pole at s=1.

\textbf{\color{blue}Partial Euler Product based zeroth order Riemann-Siegel formula fourier analysis procedure across the critical plane}

For the case of a L-function using both $EP_{RS1,L}(s,\beta)$ and $EP_{RS2,L}(s,\beta)$ calculations

\begin{enumerate}
\item Obtain a maximum discrete spectrum sample $\Delta t = (t_0-750,t_0+750)$, spacing 0.01, $n\sim 150,000$ for both $EP_{RS1,extL}(s,1.25)$ and $EP_{RS2,extL}(s,1.25)$. Using truncation at $1.25\cdot N_1$ rather than $N_1$ to reduce spectral leakage from unwanted higher frequency components [1-3].
\item use spectral filtering to retain only the discrete fourier transform components of (i) $EP_{RS1,extL}(s,\beta)$ arising from primes $2, ..., \lfloor N_1\rfloor$ i.e., the [0,+) angular frequencies and (ii) $EP_{RS2,extL}(s,\beta)$ arising from primes $2, ..., \lfloor N_1\rfloor$ i.e., the (-, 0] angular frequencies 
\item splice together the [0,+) angular frequencies from $EP_{RS1,extL}(s,\beta)$ and the (-, 0] angular frequencies from $EP_{RS2,extL}(s,\beta)$ using the prescription (shown in code) 
\subitem \begin{verbatim}
fft_hybrid=c(1/2*(fft_plusZ[1]+fft_minusZ[1]),(fft_plusZ)[2:(ceiling(n/2)+0)], 
1/2*(fft_plusZ[ceiling(n/2)+1]+fft_minusZ[ceiling(n/2)+1]),fft_minusZ[(ceiling(n/2)+2):n])
\end{verbatim}
where \begin{verbatim}fft_plusZ\end{verbatim} is the discrete fourier transform of $EP_{RS1,extL}(s,\beta)$, \begin{verbatim}fft_minusZ\end{verbatim} is the discrete fourier transform of $EP_{RS2,extL}(s,\beta)$, n is the discrete fourier sample length. The term \begin{verbatim}{1/2*(fft_plusZ[1]+fft_minusZ[1])}\end{verbatim} averages the DC component of the two zeroth order Riemann-Siegel components (giving zero imaginary component on the critical line) and the term \begin{verbatim}{1/2*(fft_plusZ[ceiling(n/2)+1]+fft_minusZ[ceiling(n/2)+1])}\end{verbatim} averages the midway component of the n vector [3] to improve continuity of the splicing.  
\item \textbf{for close spacings between non-trivial zeroes} execute and average fourier analyses of differing lengths from the original stored spectrum (e.g., averaging 100+ fourier analyses using $n\sim 127,500$ $\Delta t = (t_0-637.5,t_0+637.5)$ to $ n\sim 150,000$ $\Delta t = (t_0-750,t_0+750)$) [2,3]. The averaging prescribed this step is not performed in this paper as the non-trivial zeroes are widely spaced compared to the fourier sample grid in the examined intervals. In this paper only a single inverse fourier transform $n \sim 150000$ is returned for each example. 
\item use interpolation of the final fitted results (spacing 0.01) onto a fine interpolation grid (spacing 0.00001) to estimate non-trivial zero positions. This step is not used in this paper as the non-trivial zeroes are widely spaced compared to the fourier sample grid in the examined intervals.
\end{enumerate}

On the critical line $k+I\cdot t$, the simpler spectral filtering and splicing algorithm described in [3] is employed as only one component $EP_{RS1,L}(k+I\cdot t,\beta)$ or $EP_{RS2,L}(k+I\cdot t,\beta)$ is then needed and conjugate symmetry reflection imputation is employed to complete the improved fourier transform approximation. As noted in [3], the advantage of using the Riemann-Siegel Z function analogue for fourier analysis is that the above splicing specification only involves n the sample length.

The input discrete spectra samples are calculated using Pari-GP [10] and the fourier transforms, inverse fourier transforms, spectral filtering and graphing is performed using R [11] and RStudio IDE [12]. The Rmd version of this paper contains the r script used in producing the fourier analysis and graphs.


## Truncated Euler Product approximation of the Riemann-Siegel Z function analogue of the $L(\mychi{(3,2)},s)$ L-function in the critical strip around the real axis using spectral filtering based fourier analyses

The first degree L function, $L(\mychi{(3,2)},s)$ periodic Dirichlet character L function 1-2-3.2-r1-0-0  [7] under the arithmetic version of the L-function is written in dirichlet series form as

\begin{equation}
L(\mychi{(3,2)},s) = \sum_{k=1}^{\infty}\left(\frac{\mychi_{(3,2)}(k)}{k^s}\right)
\end{equation}

for Re(s) > 1 where 

\begin{equation}
\mychi_{(3,2)}(k) = \{1,-1,0\} \qquad \text{for} k=\mod(3)
\end{equation}

The globally convergent integral form of the $L(\mychi{(3,2)},s)$ L function can be written in terms of a sum of Hurwitz zeta functions. 

The functional equation for the the  $L(\mychi{(3,2)},s)$ L-function is given by

log(3)*(1/2-(res+I*t))+log(Pi)*(-1/2+(res+I*t))+lngamma(((1-(res+I*t))+1)/2)-lngamma(((res+I*t)+1)/2)
\begin{equation}
L(\mychi{(3,2)},s) = \left[3^{1/2-s}\pi^{(s-1/2)}\frac{\Gamma((2-s)/2)}{\Gamma(s+1)}\right]\cdot L(\mychi{(3,2)},1-s) 
\end{equation}

The (normalised) extended Riemann Siegel Theta function for the  $L(\mychi{(3,2)},s)$ L-function is given by

\begin{align}
\theta_{normext\mychi{(3,2)}}(s) &= -\frac{1}{2}imag\left[(1/2-s)\cdot \log(3)\cdot(s-1/2)\cdot\log(\pi)+lngamma((2-s)/2)-lngamma(s+1)\right]
\end{align}

The $L(\mychi{(3,2)},s)$ L-function is a degree 1 L-function (d=1) and its conductor value is 3 [7]. Hence the first quiescent region of the dirichlet series of $L(\mychi{(3,2)},s)$ is given by

\begin{equation}
N_1 = \left\lfloor \sqrt{\left(\frac{t}{2\pi}\right)^1\cdot 3} \right\rfloor = \left\lfloor \sqrt{\frac{t}{2\pi}\cdot 3} \right\rfloor
\end{equation}

The function of interest to be approximated by partial Euler Products is the extended Riemann-Siegel Z function analogue of the $L(\mychi{(3,2)},s)$ L-function across the complex plane.

\begin{equation}
Z_{extL(\mychi{(3,2)})}(s) = e^{I\theta_{normext\mychi{(3,2)}}(s)}L(\mychi{(3,2)},s)
\end{equation}

and the zeroth order Riemann-Siegel formula for the Riemann-Siegel Z function analogue of $L(\mychi{(3,2)},s)$ L-function using partial Euler products is used as the basis of the approximation

\begin{align}
Z_{extL(\mychi{(3,2)})}(s)_{EP} &\approx EP_{RS1,L(\mychi{(3,2)})}(s,\beta=1.25) \nonumber \\ &+ EP_{RS2,L(\mychi{(3,2)})}(s,\beta=1.25) + ... \qquad t \rightarrow \infty
\end{align}

using (i) equations (8) & (9) and the known Euler factors  [7] of the $L(\mychi{(3,2)},s)$ L-function and (ii) $\beta=1.25$ is a small cushion factor in the truncation length of the included primes that is empirically observed to improve the quality of the fourier transform components of the finite Euler product arising nearby $N_1$ [2,3]. For the Riemann-Siegel Z function analogue the fourier transform components arising nearby $N_1$ are the fourier transform components namely surrounding (and including) the DC (zero) angular frequency.

Figures 1, 3 and 5 respectively for the following intervals around the real axis 

(i) $s=(0.5-I\cdot 750,0.5+I\cdot 750)$, 

(ii) $s=(0.9-I\cdot 750,0.9+I\cdot 750)$ and 

(iii) $s=(0.1-I\cdot 750,0.1+I\cdot 750)$ 

display the individual fourier transforms of the spectra of the two components of the zeroth order Riemann-Siegel formula approximation of the Riemann-Siegel Z function using partial Euler Products truncated at the first quiescent region as defined in equation (16). Shown in the

(lefthand panel top row); $EP_{RS1,L(\mychi{(3,2)})}(s,\beta=1.25)$

(lefthand panel middle row); $Z_{L(\mychi{(3,2)})}(s)$ - true Riemann-Siegel Z function

(lefthand panel bottom row); $EP_{RS2,L(\mychi{(3,2)})}(s,\beta=1.25)$

The long tails in the top and bottom rows of the lefthand panel fourier spectra arise from high frequencies generated by the finite Euler product that do not exist in finite Dirichlet Series of the same truncation length.

On the top and bottom rows of the righthand panels are spectrally filtered fourier transforms where only the low frequency components are retained from each zeroth order Riemann-Siegel formula term and in the middle row are spliced together following for figures 3 and 5 using the first 3 steps of the fourier analysis procedure described earlier in this paper and for figure 1 using the conjugate symmetry reflection procedure described in [3] (which is a simpler method available to use on the critical line). This spectral filtering and splicing provides a useful improvement in approximating the fourier transform of the true Riemann-Siegel Z function.  

\begin{enumerate}
\item To produce figures 1, 3, 5, a discrete spectra of a grid of ~ n=150,000 points was collected and stored for each interval using a spacing of 0.01. 
\item the fast fourier transform (fft) output vector is wrapped around so that the informative non-zero fft components appear next to the DC fourier component axis as positive and negative frequency components.
\item the x-axis is scaled in units of angular frequency (radians per second).
\end{enumerate}

As indicated by the red vertical lines there are broad spectral features which can be successfully captured by the assignment of the pair of bounds $\pm\frac{1}{2}(\log(UB/\pi/2\cdot 3),\log(LB/\pi/2\cdot 3))$, $\pm\frac{1}{2}(\log(UB/\pi/2\cdot 3/2^2),\log(LB/\pi/2\cdot 3/2^2))$ where UB=750,LB=-750 corresponding to the range of t values collected in the spectrum for figures 1, 3 and 5. 

Figures 2, 4, 6 pair with figures 1, 3 and 5 respectively in illustrating in the lefthand panels, the performance of the averaged inverse fourier transform for the central regions compared to the real (imaginary) parts of the true Riemann-Siegel Z function shown in magenta (cyan) at the fourier grid spacing 0.01. That is, in the lefthand panels of figures 2, 4, 6 the following interval is displayed for five different values of the minimum prime in partial Euler product calculation $P_{min}=\left\lfloor 1.25\cdot \max\left(\{1,2,3,5,23\},\sqrt{(\frac{t}{2\pi})^d\cdot N_C}\right)\right\rfloor$ with each row (top to bottom) respectively belonging to the minimum prime value \{1,2,3,5,23\} which is active when t=0.

(i) $s=(0.5-I\cdot 40,0.5+I\cdot 40)$ 

(ii) $s=(0.9-I\cdot 40,0.9+I\cdot 40)$ and 

(iii) $s=(0.1-I\cdot 40,0.1+I\cdot 40)$ 

following the fourth step of the fourier analysis procedure described earlier in this paper. When $P_{min}=1$, the partial Euler Product returns the value unity.   

In the righthand panels, the approximation error (real(spectrally filtered, spliced inverse fourier transform based approximation)-real(Z)) is displayed the entire span of the input spectra

(i) $s=(0.5-I\cdot 750,0.5+I\cdot 750)$ 

(ii) $s=(0.9-I\cdot 750,0.9+I\cdot 750)$ and 

(iii) $s=(0.1-I\cdot 750,0.1+I\cdot 750)$ 

and there are clear error peaks that can be associated with discontinuous changes in $P_{min}$. The errors at each end $\pm750$ occur due to the rectangular window used for the input spectra. 

It can be seen from figures 2, 4 and 6 

(i) in the lefthand panels that there a lot of visual overlap of the grid of true Riemann-Siegel Z function values with the partial Euler Product based approximation including t=0 except for regions with discontinuities in the real (gray) or blue (imaginary) waveforms of the approximation. The presence of the discontinuites reduces (in the lower rows) as $P_{min}$ is increased. 

(ii) in the righthand panels the magnitude of the errors in the real part of the approximation with respect to the true function values are shown and the peaks in approximation errors are observed to be removed as $P_{min}$ is increased. 

(iii) In the bottom row with as $P_{min}=23$ the approximation has a smooth performance with low errors across the entire $\pm750$ span of the input spectra except for the effect of the rectangular window of the input spectra. The value $P_{min}=13$ corresponds to the maximum prime required in the zeroth order Riemann-Siegel formula for the maximum |t| value of the input spectra $23=\left\lfloor 1.25\cdot \sqrt{(\frac{750}{2\pi})^1\cdot 3}\right\rfloor$. 

\clearpage


```{r Zfnchi32Lfunction_fouriertransform_0_pm750, echo=FALSE, fig.cap="A comparison of the fourier transforms of the Riemann-Siegel Z function analogue of the L(\\mychi{(3,2)},s) L-function and partial Euler Product (using truncation at $1.25\\cdot \\sqrt{((\\frac{750}{2\\pi})^1\\cdot 3}$) in the complex plane at $\\sigma=1/2$ for the interval t=(-750,750) about the real axis. On the critical line, to help use the partial Euler Product as an approximation of the Riemann-Siegel Z function phase conjugate reflection of the (accurate part of) partial Euler Product fourier transform about angular frequency = zero as shown in green is a strong zeroth order improvement. The middle row displays the true Riemann-Siegel Z function fourier transform behaviour.", out.width = c("49%","49%"), fig.show = "hold",  fig.height=5, warning=FALSE, cache=TRUE}


# Riemann-Siegel Z function of L32 function on critical line
# values recorded every .01 spacing in interval [-750,+750]

dfZ=read.csv("/home/john/pari/ZL32_res_p5_0_m750_p750_spacing_p01_real.csv",header=FALSE,colClasses = c("character"));
dfZ$V2=as.numeric(gsub(" ","",dfZ$V2));
dfZ=dfZ[order(as.numeric(dfZ$V1)),]

dfZi=read.csv("/home/john/pari/ZL32_res_p5_0_m750_p750_spacing_p01_imag.csv",header=FALSE,colClasses = c("character"));
dfZi$V2=as.numeric(gsub(" ","",dfZi$V2));
dfZi=dfZi[order(as.numeric(dfZi$V1)),]

fft_zeta_Zfn =  stats::fft(dfZ$V2+1i*dfZi$V2)


#first component of riemann-siegel formula based on first quiescent region
#EP(sigma+i*t)*exp(i*theta)
#using minimum 23 primes in prodeuler pari-gp function

dfplusZ=read.csv("/home/john/pari/ZL32plus_EP_res_p5_0_m750_p750_23upwards_spacing_p01_real.csv",header=FALSE,colClasses = c("character"));
dfplusZ$V2=as.numeric(gsub(" ","",dfplusZ$V2));
dfplusZ=dfplusZ[order(as.numeric(dfplusZ$V1)),]

dfplusZi=read.csv("/home/john/pari/ZL32plus_EP_res_p5_0_m750_p750_23upwards_spacing_p01_imag.csv",header=FALSE,colClasses = c("character"));
dfplusZi$V2=as.numeric(gsub(" ","",dfplusZi$V2));
dfplusZi=dfplusZi[order(as.numeric(dfplusZi$V1)),]

dfreal=dfplusZ;dfimag=dfplusZi

min_val=min(as.numeric(dfreal$V1));max_val=max(as.numeric(dfreal$V1))
dfimag=dfimag[(dfimag$V1 %in% dfreal$V1),]


fft_plusZ = stats::fft(dfreal$V2+1i*dfimag$V2)

dfreal_plus=dfreal
dfimag_plus=dfimag

lenf2=length(fft_plusZ)
delta_fft2=max(as.numeric(substr(dfreal$V1,1,12)))-min(as.numeric(substr(dfreal$V1,1,12)))
n=lenf2

#second component of riemann-siegel formula based on first quiescent region
#EP(1-(sigma+i*t))*chi(sigma+i*t)*exp(i*theta)
#using minimum 23 primes in prodeuler pari-gp function

dfminusZ=read.csv("/home/john/pari/ZL32minus_EP_res_p5_0_m750_p750_23upwards_spacing_p01_real.csv",header=FALSE,colClasses = c("character"));
dfminusZ$V2=as.numeric(gsub(" ","",dfminusZ$V2));
dfminusZ=dfminusZ[order(as.numeric(dfminusZ$V1)),]

dfminusZi=read.csv("/home/john/pari/ZL32minus_EP_res_p5_0_m750_p750_23upwards_spacing_p01_imag.csv",header=FALSE,colClasses = c("character"));
dfminusZi$V2=as.numeric(gsub(" ","",dfminusZi$V2));
dfminusZi=dfminusZi[order(as.numeric(dfminusZi$V1)),]

dfreal=dfminusZ;dfimag=dfminusZi

min_val=min(as.numeric(dfreal$V1));max_val=max(as.numeric(dfreal$V1))
dfimag=dfimag[dfimag$V1 %in% dfreal$V1,]

fft_minusZ = stats::fft(dfreal$V2+1i*dfimag$V2)

dfreal_minus=dfreal
dfimag_minus=dfimag

lenf=dim(dfreal)[1]

n=dim(dfreal)[1]

min_freq=min(as.numeric(substr(dfreal$V1,1,12)))
max_freq=max(as.numeric(substr(dfreal$V1,1,12)))

delta_fft=max_freq-min_freq
mid=floor(delta_fft/2/pi*log(floor(sqrt((max_freq/2/pi/c(1))*3))))

plot(c(-floor(n/2):(ceiling(n/2)-1))*2*pi/delta_fft,c(abs(fft_plusZ)[(ceiling(n/2)+1):n],abs(fft_plusZ)[1:(ceiling(n/2))]),xlim=c(-11,11),typ="l",xaxt="n",xlab="angular frequency (radians per sec)",ylab="|Amplitude|",main="fourier transform spectra of the first component of \n the partial Euler product Riemann-Siegel Z function \n using truncation at N1=sqrt((max(t)/2/pi)*3).")
abline(v=seq(-20,20,l=41),h=seq(0,1e5,l=6),lty=3,col="gray")
axis(1,at=seq(-20,20,l=41))
abline(v=-1/2*log((max_freq)/pi/2*3/c(1:2)^2)-0,col=rgb(1,0,0,0.3))
abline(v=1/2*log((max_freq)/pi/2*3/c(1:2)^2)-0,col=rgb(1,0,0,0.3))


plot(c(-floor(n/2):-1)*2*pi/delta_fft,c(rev(abs(Conj(fft_plusZ))[2:ceiling(n/2)])),xlim=c(-5,5),typ="l",xaxt="n",xlab="angular frequency (radians per sec)",ylab="|Amplitude|",main="piecewise fourier transform \n spectra filtering of the first component positive frequencies \n and phase conjugate reflection imputation of the negative freq half.",col=3)
lines(c(0:(ceiling(n/2)-1))*2*pi/delta_fft,c(abs(fft_plusZ)[1:(ceiling(n/2))]),col=1)
abline(v=seq(-20,20,l=41),h=seq(0,1e5,l=6),lty=3,col="gray")
axis(1,at=seq(-20,20,l=41))
abline(v=-1/2*log((max_freq)/pi/2*3/c(1:2)^2)-0,col=rgb(1,0,0,0.3))
abline(v=1/2*log((max_freq)/pi/2*3/c(1:2)^2)-0,col=rgb(1,0,0,0.3))


n=dim(dfZ)[1]
min_freq=min(as.numeric(dfZ$V1))
max_freq=max(as.numeric(dfZ$V1))
delta_fft=max_freq-min_freq
mid=floor(delta_fft/2/pi*log(floor(sqrt((max_freq/2/pi/c(1))*5))))

plot(c(-floor(n/2):(ceiling(n/2)-1))*2*pi/delta_fft,c(abs(fft_zeta_Zfn)[(ceiling(n/2)+1):n],abs(fft_zeta_Zfn)[1:(ceiling(n/2))]),xlim=c(-11,11),typ="l",xaxt="n",xlab="angular frequency (radians per sec)",ylab="|Amplitude|",main="fourier transform spectra of the true Riemann-Siegel Z function.",cex.main=0.9)
abline(v=seq(-20,20,l=41),h=seq(0,1e5,l=6),lty=3,col="gray")
axis(1,at=seq(-20,20,l=41))
abline(v=-1/2*log((max_freq)/pi/2*3/c(1:2)^2)-0,col=rgb(1,0,0,0.3))
abline(v=1/2*log((max_freq)/pi/2*3/c(1:2)^2)-0,col=rgb(1,0,0,0.3))

n=dim(dfZ)[1]
min_freq=min(as.numeric(dfZ$V1))
max_freq=max(as.numeric(dfZ$V1))
delta_fft=max_freq-min_freq
mid=floor(delta_fft/2/pi*log(floor(sqrt((max_freq/2/pi/c(1))*5))))

plot(c(-floor(n/2):(ceiling(n/2)-1))*2*pi/delta_fft,c(abs(fft_zeta_Zfn)[(ceiling(n/2)+1):n],abs(fft_zeta_Zfn)[1:(ceiling(n/2))]),xlim=c(-5,5),typ="l",xaxt="n",xlab="angular frequency (radians per sec)",ylab="|Amplitude|",main="fourier transform spectra of the true Riemann-Siegel Z function.",cex.main=0.9)
abline(v=seq(-20,20,l=41),h=seq(0,1e5,l=6),lty=3,col="gray")
axis(1,at=seq(-20,20,l=41))
abline(v=-1/2*log((max_freq)/pi/2*3/c(1:2)^2)-0,col=rgb(1,0,0,0.3))
abline(v=1/2*log((max_freq)/pi/2*3/c(1:2)^2)-0,col=rgb(1,0,0,0.3))


n=dim(dfminusZ)[1]
min_freq=min(as.numeric(dfminusZ$V1))
max_freq=max(as.numeric(dfminusZ$V1))
delta_fft=max_freq-min_freq
mid=floor(delta_fft/2/pi*log(floor(sqrt((max_freq/2/pi/c(1))*3))))

plot(c(-floor(n/2):(ceiling(n/2)-1))*2*pi/delta_fft,c(abs(fft_minusZ)[(ceiling(n/2)+1):n],abs(fft_minusZ)[1:(ceiling(n/2))]),xlim=c(-11,11),typ="l",xaxt="n",xlab="angular frequency (radians per sec)",ylab="|Amplitude|",main="fourier transform spectra of the second component of \n the partial Euler product Riemann-Siegel Z function \n using truncation at N1=sqrt((max(t)/2/pi)*3).")
abline(v=seq(-20,20,l=41),h=seq(0,1e5,l=6),lty=3,col="gray")
axis(1,at=seq(-20,20,l=41))
abline(v=-1/2*log((max_freq)/pi/2*3/c(1:2)^2)-0,col=rgb(1,0,0,0.3))
abline(v=1/2*log((max_freq)/pi/2*3/c(1:2)^2)-0,col=rgb(1,0,0,0.3))


plot(c(-floor(n/2):-1)*2*pi/delta_fft,c(abs(fft_minusZ)[(ceiling(n/2)+1):n]),xlim=c(-5,5),typ="l",xaxt="n",xlab="angular frequency (radians per sec)",ylab="|Amplitude|",main="piecewise fourier transform \n spectra filtering of the second component negative frequencies \n and phase conjugate reflection imputation of the positive freq half.",col=1)
lines(c(0:(floor(n/2)))*2*pi/delta_fft,c(abs(fft_minusZ)[1],rev(abs(fft_minusZ)[(ceiling(n/2)+1):n])),col=3)
abline(v=seq(-20,20,l=41),h=seq(0,1e5,l=6),lty=3,col="gray")
axis(1,at=seq(-20,20,l=41))
abline(v=-1/2*log((max_freq)/pi/2*3/c(1:2)^2)-0,col=rgb(1,0,0,0.3))
abline(v=1/2*log((max_freq)/pi/2*3/c(1:2)^2)-0,col=rgb(1,0,0,0.3))

```



\clearpage

```{r Zfnchi32Lfunctionoveraninterval_anditsfouriertransform_0_pm750, echo=FALSE, fig.cap="Lefthand panel - True Z function shown in magenta (cyan) for real (imaginary) parts and spectral filtered based EP approximation shown in black (blue) for real (imaginary) parts, Right hand panel - Error in the real(Z) EP approximation. A comparison of the Riemann-Siegel Z function analogue of the L(\\mychi{(3,2)},s) L-function and spectrally filtered partial Euler Product (using truncation at $\\max (P,\\sqrt{((\\frac{t}{2\\pi})^1\\cdot 3}) $) in the complex plane at $\\sigma=0.5$ for the interval t=(-750,750) where $P_{min}={1,2,3,5,23}$ for rows 1-5. ", out.width = c("49%","49%"), fig.show = "hold",  fig.height=3.8, warning=FALSE, cache=TRUE}


# Riemann-Siegel Z function of L32 function on critical line
# values recorded every .01 spacing in interval [-750,+750]

dfZ=read.csv("/home/john/pari/ZL32_res_p5_0_m750_p750_spacing_p01_real.csv",header=FALSE,colClasses = c("character"));
dfZ$V2=as.numeric(gsub(" ","",dfZ$V2));
dfZ=dfZ[order(as.numeric(dfZ$V1)),]

dfZi=read.csv("/home/john/pari/ZL32_res_p5_0_m750_p750_spacing_p01_imag.csv",header=FALSE,colClasses = c("character"));
dfZi$V2=as.numeric(gsub(" ","",dfZi$V2));
dfZi=dfZi[order(as.numeric(dfZi$V1)),]


#Riemann-Siegel Z function of truncated Euler product at first quiescent region
#first component of riemann-siegel formula based on first quiescent region
#EP(sigma+i*t)*exp(i*theta)
#using 0 extra integers in prodeuler pari-gp function

dfplusZ=read.csv("/home/john/pari/ZL32plus_EP_res_p5_0_m750_p750_0extra_spacing_p01_real.csv",header=FALSE,colClasses = c("character"));
dfplusZ$V2=as.numeric(gsub(" ","",dfplusZ$V2));
dfplusZ=dfplusZ[order(as.numeric(dfplusZ$V1)),]

dfplusZi=read.csv("/home/john/pari/ZL32plus_EP_res_p5_0_m750_p750_0extra_spacing_p01_imag.csv",header=FALSE,colClasses = c("character"));
dfplusZi$V2=as.numeric(gsub(" ","",dfplusZi$V2));
dfplusZi=dfplusZi[order(as.numeric(dfplusZi$V1)),]

dfreal=dfplusZ;dfimag=dfplusZi

min_val=min(as.numeric(dfreal$V1));max_val=max(as.numeric(dfreal$V1))
dfimag=dfimag[(dfimag$V1 %in% dfreal$V1),]


fft_plusZ = stats::fft(dfreal$V2+1i*dfimag$V2)

dfreal_plus=dfreal
dfimag_plus=dfimag

lenf2=length(fft_plusZ)
delta_fft2=max(as.numeric(substr(dfreal$V1,1,12)))-min(as.numeric(substr(dfreal$V1,1,12)))
n=lenf2

#second component of riemann-siegel formula based on first quiescent region
#EP(1-(sigma+i*t))*chi(sigma+i*t)*exp(i*theta)
#using 0 extra integers in prodeuler pari-gp function

dfminusZ=read.csv("/home/john/pari/ZL32minus_EP_res_p5_0_m750_p750_0extra_spacing_p01_real.csv",header=FALSE,colClasses = c("character"));
dfminusZ$V2=as.numeric(gsub(" ","",dfminusZ$V2));
dfminusZ=dfminusZ[order(as.numeric(dfminusZ$V1)),]

dfminusZi=read.csv("/home/john/pari/ZL32minus_EP_res_p5_0_m750_p750_0extra_spacing_p01_imag.csv",header=FALSE,colClasses = c("character"));
dfminusZi$V2=as.numeric(gsub(" ","",dfminusZi$V2));
dfminusZi=dfminusZi[order(as.numeric(dfminusZi$V1)),]

dfreal=dfminusZ;dfimag=dfminusZi

min_val=min(as.numeric(dfreal$V1));max_val=max(as.numeric(dfreal$V1))
dfimag=dfimag[dfimag$V1 %in% dfreal$V1,]

fft_minusZ = stats::fft(dfreal$V2+1i*dfimag$V2)

dfreal_minus=dfreal
dfimag_minus=dfimag

lenf=dim(dfreal)[1]

n=dim(dfreal)[1]

min_freq=min(as.numeric(substr(dfreal$V1,1,12)))
max_freq=max(as.numeric(substr(dfreal$V1,1,12)))
delta_fft=max(as.numeric(substr(dfreal$V1,1,12)))-min(as.numeric(substr(dfreal$V1,1,12)))


#symmetric formula when sigma=0.5
#for spectral filtering of first quiescent region based Euler Product

fft_hybrid=c(Re(fft_plusZ[1]),(fft_plusZ)[2:(ceiling(n/2)+0)],Re(fft_plusZ)[ceiling(n/2)+1],Conj(rev(c((fft_plusZ)[2:floor(n/2)]))))
inv_hybrid=fft(fft_hybrid,inverse=TRUE)

yspan=range(Re(inv_hybrid)/n,Im(inv_hybrid)/n)
plot(as.numeric(substr(dfreal$V1,1,22)),Re(inv_hybrid)/n,typ="l",
     ylab="Z component",ylim=c(-5,5),xlab="t",main="Riemann Siegel Z function analogue (using spectral filtered Euler Product) of \n L32 function using max(1,floor(1.25*sqrt(t/2/pi*3))) in EP",xlim=c(-40,40)+0,col="black",cex.main=0.8);grid(col="gray")
lines(as.numeric(substr(dfimag$V1,1,22)),Im(inv_hybrid)/n,col="blue")
lines(as.numeric(substr(dfZ$V1,1,22)),Re(dfZ$V2),col="magenta",lty=2)
lines(as.numeric(substr(dfZ$V1,1,22)),Re(dfZi$V2),col="cyan",lty=2)

plot(as.numeric(substr(dfreal$V1,1,22)),Re(inv_hybrid)/n-Re(dfZ$V2),typ="l",xlab="t",ylab="Error",main="Error in real(Z) component (using spectral filtered Euler Product approximation) of \n L32 function using max(1,floor(1.25*sqrt(t/2/pi*3))) in EP",col="gray",cex.main=0.8);grid(col="gray2")

#Riemann-Siegel Z function of truncated Euler product at first quiescent region
#first component of riemann-siegel formula based on first quiescent region
#EP(sigma+i*t)*exp(i*theta)
#using 0 extra integers in prodeuler pari-gp function

dfplusZ=read.csv("/home/john/pari/ZL32plus_EP_res_p5_0_m750_p750_2upwards_spacing_p01_real.csv",header=FALSE,colClasses = c("character"));
dfplusZ$V2=as.numeric(gsub(" ","",dfplusZ$V2));
dfplusZ=dfplusZ[order(as.numeric(dfplusZ$V1)),]

dfplusZi=read.csv("/home/john/pari/ZL32plus_EP_res_p5_0_m750_p750_2upwards_spacing_p01_imag.csv",header=FALSE,colClasses = c("character"));
dfplusZi$V2=as.numeric(gsub(" ","",dfplusZi$V2));
dfplusZi=dfplusZi[order(as.numeric(dfplusZi$V1)),]

dfreal=dfplusZ;dfimag=dfplusZi

min_val=min(as.numeric(dfreal$V1));max_val=max(as.numeric(dfreal$V1))
dfimag=dfimag[(dfimag$V1 %in% dfreal$V1),]


fft_plusZ = stats::fft(dfreal$V2+1i*dfimag$V2)

dfreal_plus=dfreal
dfimag_plus=dfimag

lenf2=length(fft_plusZ)
delta_fft2=max(as.numeric(substr(dfreal$V1,1,12)))-min(as.numeric(substr(dfreal$V1,1,12)))
n=lenf2

#second component of riemann-siegel formula based on first quiescent region
#EP(1-(sigma+i*t))*chi(sigma+i*t)*exp(i*theta)
#using 0 extra integers in prodeuler pari-gp function

dfminusZ=read.csv("/home/john/pari/ZL32minus_EP_res_p5_0_m750_p750_2upwards_spacing_p01_real.csv",header=FALSE,colClasses = c("character"));
dfminusZ$V2=as.numeric(gsub(" ","",dfminusZ$V2));
dfminusZ=dfminusZ[order(as.numeric(dfminusZ$V1)),]

dfminusZi=read.csv("/home/john/pari/ZL32minus_EP_res_p5_0_m750_p750_2upwards_spacing_p01_imag.csv",header=FALSE,colClasses = c("character"));
dfminusZi$V2=as.numeric(gsub(" ","",dfminusZi$V2));
dfminusZi=dfminusZi[order(as.numeric(dfminusZi$V1)),]

dfreal=dfminusZ;dfimag=dfminusZi

min_val=min(as.numeric(dfreal$V1));max_val=max(as.numeric(dfreal$V1))
dfimag=dfimag[dfimag$V1 %in% dfreal$V1,]

fft_minusZ = stats::fft(dfreal$V2+1i*dfimag$V2)

dfreal_minus=dfreal
dfimag_minus=dfimag

lenf=dim(dfreal)[1]

n=dim(dfreal)[1]

min_freq=min(as.numeric(substr(dfreal$V1,1,12)))
max_freq=max(as.numeric(substr(dfreal$V1,1,12)))
delta_fft=max(as.numeric(substr(dfreal$V1,1,12)))-min(as.numeric(substr(dfreal$V1,1,12)))


#symmetric formula when sigma=0.5
#for spectral filtering of first quiescent region based Euler Product

fft_hybrid=c(Re(fft_plusZ[1]),(fft_plusZ)[2:(ceiling(n/2)+0)],Re(fft_plusZ)[ceiling(n/2)+1],Conj(rev(c((fft_plusZ)[2:floor(n/2)]))))
inv_hybrid=fft(fft_hybrid,inverse=TRUE)

yspan=range(Re(inv_hybrid)/n,Im(inv_hybrid)/n)
plot(as.numeric(substr(dfreal$V1,1,22)),Re(inv_hybrid)/n,typ="l",
     ylab="Z component",ylim=c(-5,5),xlab="t",main="Riemann Siegel Z function analogue (using spectral filtered Euler Product) of \n L32 function using max(2,floor(1.25*sqrt(t/2/pi*3))) in EP",xlim=c(-40,40)+0,col="black",cex.main=0.8);grid(col="gray")
lines(as.numeric(substr(dfimag$V1,1,22)),Im(inv_hybrid)/n,col="blue")
lines(as.numeric(substr(dfZ$V1,1,22)),Re(dfZ$V2),col="magenta",lty=2)
lines(as.numeric(substr(dfZ$V1,1,22)),Re(dfZi$V2),col="cyan",lty=2)

plot(as.numeric(substr(dfreal$V1,1,22)),Re(inv_hybrid)/n-Re(dfZ$V2),typ="l",xlab="t",ylab="Error",main="Error in real(Z) component (using spectral filtered Euler Product approximation) of \n L32 function using max(2,floor(1.25*sqrt(t/2/pi*3))) in EP",col="gray",cex.main=0.8);grid(col="gray2")

#Riemann-Siegel Z function of truncated Euler product at first quiescent region
#first component of riemann-siegel formula based on first quiescent region
#EP(sigma+i*t)*exp(i*theta)
#using 0 extra integers in prodeuler pari-gp function

dfplusZ=read.csv("/home/john/pari/ZL32plus_EP_res_p5_0_m750_p750_3upwards_spacing_p01_real.csv",header=FALSE,colClasses = c("character"));
dfplusZ$V2=as.numeric(gsub(" ","",dfplusZ$V2));
dfplusZ=dfplusZ[order(as.numeric(dfplusZ$V1)),]

dfplusZi=read.csv("/home/john/pari/ZL32plus_EP_res_p5_0_m750_p750_3upwards_spacing_p01_imag.csv",header=FALSE,colClasses = c("character"));
dfplusZi$V2=as.numeric(gsub(" ","",dfplusZi$V2));
dfplusZi=dfplusZi[order(as.numeric(dfplusZi$V1)),]

dfreal=dfplusZ;dfimag=dfplusZi

min_val=min(as.numeric(dfreal$V1));max_val=max(as.numeric(dfreal$V1))
dfimag=dfimag[(dfimag$V1 %in% dfreal$V1),]


fft_plusZ = stats::fft(dfreal$V2+1i*dfimag$V2)

dfreal_plus=dfreal
dfimag_plus=dfimag

lenf2=length(fft_plusZ)
delta_fft2=max(as.numeric(substr(dfreal$V1,1,12)))-min(as.numeric(substr(dfreal$V1,1,12)))
n=lenf2

#second component of riemann-siegel formula based on first quiescent region
#EP(1-(sigma+i*t))*chi(sigma+i*t)*exp(i*theta)
#using 0 extra integers in prodeuler pari-gp function

dfminusZ=read.csv("/home/john/pari/ZL32minus_EP_res_p5_0_m750_p750_3upwards_spacing_p01_real.csv",header=FALSE,colClasses = c("character"));
dfminusZ$V2=as.numeric(gsub(" ","",dfminusZ$V2));
dfminusZ=dfminusZ[order(as.numeric(dfminusZ$V1)),]

dfminusZi=read.csv("/home/john/pari/ZL32minus_EP_res_p5_0_m750_p750_3upwards_spacing_p01_imag.csv",header=FALSE,colClasses = c("character"));
dfminusZi$V2=as.numeric(gsub(" ","",dfminusZi$V2));
dfminusZi=dfminusZi[order(as.numeric(dfminusZi$V1)),]

dfreal=dfminusZ;dfimag=dfminusZi

min_val=min(as.numeric(dfreal$V1));max_val=max(as.numeric(dfreal$V1))
dfimag=dfimag[dfimag$V1 %in% dfreal$V1,]

fft_minusZ = stats::fft(dfreal$V2+1i*dfimag$V2)

dfreal_minus=dfreal
dfimag_minus=dfimag

lenf=dim(dfreal)[1]

n=dim(dfreal)[1]

min_freq=min(as.numeric(substr(dfreal$V1,1,12)))
max_freq=max(as.numeric(substr(dfreal$V1,1,12)))
delta_fft=max(as.numeric(substr(dfreal$V1,1,12)))-min(as.numeric(substr(dfreal$V1,1,12)))


#symmetric formula when sigma=0.5
#for spectral filtering of first quiescent region based Euler Product

fft_hybrid=c(Re(fft_plusZ[1]),(fft_plusZ)[2:(ceiling(n/2)+0)],Re(fft_plusZ)[ceiling(n/2)+1],Conj(rev(c((fft_plusZ)[2:floor(n/2)]))))
inv_hybrid=fft(fft_hybrid,inverse=TRUE)

yspan=range(Re(inv_hybrid)/n,Im(inv_hybrid)/n)
plot(as.numeric(substr(dfreal$V1,1,22)),Re(inv_hybrid)/n,typ="l",
     ylab="Z component",ylim=c(-5,5),xlab="t",main="Riemann Siegel Z function analogue (using spectral filtered Euler Product) of \n L32 function using max(3,floor(1.25*sqrt(t/2/pi*3))) in EP",xlim=c(-40,40)+0,col="black",cex.main=0.8);grid(col="gray")
lines(as.numeric(substr(dfimag$V1,1,22)),Im(inv_hybrid)/n,col="blue")
lines(as.numeric(substr(dfZ$V1,1,22)),Re(dfZ$V2),col="magenta",lty=2)
lines(as.numeric(substr(dfZ$V1,1,22)),Re(dfZi$V2),col="cyan",lty=2)

plot(as.numeric(substr(dfreal$V1,1,22)),Re(inv_hybrid)/n-Re(dfZ$V2),typ="l",xlab="t",ylab="Error",main="Error in real(Z) component (using spectral filtered Euler Product approximation) of \n L32 function using max(3,floor(1.25*sqrt(t/2/pi*3))) in EP",col="gray",cex.main=0.8);grid(col="gray2")


#Riemann-Siegel Z function of truncated Euler product at first quiescent region
#first component of riemann-siegel formula based on first quiescent region
#EP(sigma+i*t)*exp(i*theta)
#using 0 extra integers in prodeuler pari-gp function

dfplusZ=read.csv("/home/john/pari/ZL32plus_EP_res_p5_0_m750_p750_5upwards_spacing_p01_real.csv",header=FALSE,colClasses = c("character"));
dfplusZ$V2=as.numeric(gsub(" ","",dfplusZ$V2));
dfplusZ=dfplusZ[order(as.numeric(dfplusZ$V1)),]

dfplusZi=read.csv("/home/john/pari/ZL32plus_EP_res_p5_0_m750_p750_5upwards_spacing_p01_imag.csv",header=FALSE,colClasses = c("character"));
dfplusZi$V2=as.numeric(gsub(" ","",dfplusZi$V2));
dfplusZi=dfplusZi[order(as.numeric(dfplusZi$V1)),]

dfreal=dfplusZ;dfimag=dfplusZi

min_val=min(as.numeric(dfreal$V1));max_val=max(as.numeric(dfreal$V1))
dfimag=dfimag[(dfimag$V1 %in% dfreal$V1),]


fft_plusZ = stats::fft(dfreal$V2+1i*dfimag$V2)

dfreal_plus=dfreal
dfimag_plus=dfimag

lenf2=length(fft_plusZ)
delta_fft2=max(as.numeric(substr(dfreal$V1,1,12)))-min(as.numeric(substr(dfreal$V1,1,12)))
n=lenf2

#second component of riemann-siegel formula based on first quiescent region
#EP(1-(sigma+i*t))*chi(sigma+i*t)*exp(i*theta)
#using 0 extra integers in prodeuler pari-gp function

dfminusZ=read.csv("/home/john/pari/ZL32minus_EP_res_p5_0_m750_p750_5upwards_spacing_p01_real.csv",header=FALSE,colClasses = c("character"));
dfminusZ$V2=as.numeric(gsub(" ","",dfminusZ$V2));
dfminusZ=dfminusZ[order(as.numeric(dfminusZ$V1)),]

dfminusZi=read.csv("/home/john/pari/ZL32minus_EP_res_p5_0_m750_p750_5upwards_spacing_p01_imag.csv",header=FALSE,colClasses = c("character"));
dfminusZi$V2=as.numeric(gsub(" ","",dfminusZi$V2));
dfminusZi=dfminusZi[order(as.numeric(dfminusZi$V1)),]

dfreal=dfminusZ;dfimag=dfminusZi

min_val=min(as.numeric(dfreal$V1));max_val=max(as.numeric(dfreal$V1))
dfimag=dfimag[dfimag$V1 %in% dfreal$V1,]

fft_minusZ = stats::fft(dfreal$V2+1i*dfimag$V2)

dfreal_minus=dfreal
dfimag_minus=dfimag

lenf=dim(dfreal)[1]

n=dim(dfreal)[1]

min_freq=min(as.numeric(substr(dfreal$V1,1,12)))
max_freq=max(as.numeric(substr(dfreal$V1,1,12)))
delta_fft=max(as.numeric(substr(dfreal$V1,1,12)))-min(as.numeric(substr(dfreal$V1,1,12)))


#symmetric formula when sigma=0.5
#for spectral filtering of first quiescent region based Euler Product

fft_hybrid=c(Re(fft_plusZ[1]),(fft_plusZ)[2:(ceiling(n/2)+0)],Re(fft_plusZ)[ceiling(n/2)+1],Conj(rev(c((fft_plusZ)[2:floor(n/2)]))))
inv_hybrid=fft(fft_hybrid,inverse=TRUE)

yspan=range(Re(inv_hybrid)/n,Im(inv_hybrid)/n)
plot(as.numeric(substr(dfreal$V1,1,22)),Re(inv_hybrid)/n,typ="l",
     ylab="Z component",ylim=c(-5,5),xlab="t",main="Riemann Siegel Z function analogue (using spectral filtered Euler Product) of \n L32 function using max(5,floor(1.25*sqrt(t/2/pi*3))) in EP",xlim=c(-40,40)+0,col="black",cex.main=0.8);grid(col="gray")
lines(as.numeric(substr(dfimag$V1,1,22)),Im(inv_hybrid)/n,col="blue")
lines(as.numeric(substr(dfZ$V1,1,22)),Re(dfZ$V2),col="magenta",lty=2)
lines(as.numeric(substr(dfZ$V1,1,22)),Re(dfZi$V2),col="cyan",lty=2)

plot(as.numeric(substr(dfreal$V1,1,22)),Re(inv_hybrid)/n-Re(dfZ$V2),typ="l",xlab="t",ylab="Error",main="Error in real(Z) component (using spectral filtered Euler Product approximation) of \n L32 function using max(5,floor(1.25*sqrt(t/2/pi*3))) in EP",col="gray",cex.main=0.8);grid(col="gray2")
lines(rep((7/1.25)^2*2*pi/3,2),c(-0.65,-0.55),lty=2,col="blue")
lines(rep((11/1.25)^2*2*pi/3,2),c(-0.65,-0.55),lty=2,col="blue")
lines(rep((13/1.25)^2*2*pi/3,2),c(-0.65,-0.55),lty=2,col="blue")
lines(rep((17/1.25)^2*2*pi/3,2),c(-0.65,-0.55),lty=2,col="blue")
lines(rep((19/1.25)^2*2*pi/3,2),c(-0.65,-0.55),lty=2,col="blue")
lines(rep((23/1.25)^2*2*pi/3,2),c(-0.65,-0.55),lty=2,col="blue")
lines(-rep((7/1.25)^2*2*pi/3,2),c(-0.65,-0.55),lty=2,col="blue")
lines(-rep((11/1.25)^2*2*pi/3,2),c(-0.65,-0.55),lty=2,col="blue")
lines(-rep((13/1.25)^2*2*pi/3,2),c(-0.65,-0.55),lty=2,col="blue")
lines(-rep((17/1.25)^2*2*pi/3,2),c(-0.65,-0.55),lty=2,col="blue")
lines(-rep((19/1.25)^2*2*pi/3,2),c(-0.65,-0.55),lty=2,col="blue")
lines(-rep((23/1.25)^2*2*pi/3,2),c(-0.65,-0.55),lty=2,col="blue")
text(x=c(-1,1)*(7/1.25)^2*2*pi/3,y=-.67,"7")
text(x=c(-1,1)*(11/1.25)^2*2*pi/3,y=-.67,"11")
text(x=c(-1,1)*(13/1.25)^2*2*pi/3,y=-.67,"13")
text(x=c(-1,1)*(17/1.25)^2*2*pi/3,y=-.67,"17")
text(x=c(-1,1)*(19/1.25)^2*2*pi/3,y=-.67,"19")
text(x=c(-1,1)*(23/1.25)^2*2*pi/3,y=-.67,"23")
text(x=50,y=-0.5,"t value when next prime is included in EP")

#Riemann-Siegel Z function of truncated Euler product at first quiescent region
#first component of riemann-siegel formula based on first quiescent region
#EP(sigma+i*t)*exp(i*theta)
#using 0 extra integers in prodeuler pari-gp function

dfplusZ=read.csv("/home/john/pari/ZL32plus_EP_res_p5_0_m750_p750_23upwards_spacing_p01_real.csv",header=FALSE,colClasses = c("character"));
dfplusZ$V2=as.numeric(gsub(" ","",dfplusZ$V2));
dfplusZ=dfplusZ[order(as.numeric(dfplusZ$V1)),]

dfplusZi=read.csv("/home/john/pari/ZL32plus_EP_res_p5_0_m750_p750_23upwards_spacing_p01_imag.csv",header=FALSE,colClasses = c("character"));
dfplusZi$V2=as.numeric(gsub(" ","",dfplusZi$V2));
dfplusZi=dfplusZi[order(as.numeric(dfplusZi$V1)),]

dfreal=dfplusZ;dfimag=dfplusZi

min_val=min(as.numeric(dfreal$V1));max_val=max(as.numeric(dfreal$V1))
dfimag=dfimag[(dfimag$V1 %in% dfreal$V1),]


fft_plusZ = stats::fft(dfreal$V2+1i*dfimag$V2)

dfreal_plus=dfreal
dfimag_plus=dfimag

lenf2=length(fft_plusZ)
delta_fft2=max(as.numeric(substr(dfreal$V1,1,12)))-min(as.numeric(substr(dfreal$V1,1,12)))
n=lenf2

#second component of riemann-siegel formula based on first quiescent region
#EP(1-(sigma+i*t))*chi(sigma+i*t)*exp(i*theta)
#using 0 extra integers in prodeuler pari-gp function

dfminusZ=read.csv("/home/john/pari/ZL32minus_EP_res_p5_0_m750_p750_23upwards_spacing_p01_real.csv",header=FALSE,colClasses = c("character"));
dfminusZ$V2=as.numeric(gsub(" ","",dfminusZ$V2));
dfminusZ=dfminusZ[order(as.numeric(dfminusZ$V1)),]

dfminusZi=read.csv("/home/john/pari/ZL32minus_EP_res_p5_0_m750_p750_23upwards_spacing_p01_imag.csv",header=FALSE,colClasses = c("character"));
dfminusZi$V2=as.numeric(gsub(" ","",dfminusZi$V2));
dfminusZi=dfminusZi[order(as.numeric(dfminusZi$V1)),]

dfreal=dfminusZ;dfimag=dfminusZi

min_val=min(as.numeric(dfreal$V1));max_val=max(as.numeric(dfreal$V1))
dfimag=dfimag[dfimag$V1 %in% dfreal$V1,]

fft_minusZ = stats::fft(dfreal$V2+1i*dfimag$V2)

dfreal_minus=dfreal
dfimag_minus=dfimag

lenf=dim(dfreal)[1]

n=dim(dfreal)[1]

min_freq=min(as.numeric(substr(dfreal$V1,1,12)))
max_freq=max(as.numeric(substr(dfreal$V1,1,12)))
delta_fft=max(as.numeric(substr(dfreal$V1,1,12)))-min(as.numeric(substr(dfreal$V1,1,12)))


#symmetric formula when sigma=0.5
#for spectral filtering of first quiescent region based Euler Product

fft_hybrid=c(Re(fft_plusZ[1]),(fft_plusZ)[2:(ceiling(n/2)+0)],Re(fft_plusZ)[ceiling(n/2)+1],Conj(rev(c((fft_plusZ)[2:floor(n/2)]))))
inv_hybrid=fft(fft_hybrid,inverse=TRUE)

yspan=range(Re(inv_hybrid)/n,Im(inv_hybrid)/n)
plot(as.numeric(substr(dfreal$V1,1,22)),Re(inv_hybrid)/n,typ="l",
     ylab="Z component",ylim=c(-5,5),xlab="t",main="Riemann Siegel Z function analogue (using spectral filtered Euler Product) of \n L32 function using max(23,floor(1.25*sqrt(t/2/pi*3))) in EP",xlim=c(-40,40)+0,col="black",cex.main=0.8);grid(col="gray")
lines(as.numeric(substr(dfimag$V1,1,22)),Im(inv_hybrid)/n,col="blue")
lines(as.numeric(substr(dfZ$V1,1,22)),Re(dfZ$V2),col="magenta",lty=2)
lines(as.numeric(substr(dfZ$V1,1,22)),Re(dfZi$V2),col="cyan",lty=2)


plot(as.numeric(substr(dfreal$V1,1,22)),Re(inv_hybrid)/n-Re(dfZ$V2),typ="l",xlab="t",ylab="Error",main="Error in real(Z) component (using spectral filtered Euler Product approximation) of \n L32 function using max(23,floor(1.25*sqrt(t/2/pi*3))) in EP",col="gray",cex.main=0.8);grid(col="gray")


```



\clearpage


```{r Zfnchi32Lfunction_fouriertransform_0_pm750_res_p9, echo=FALSE, fig.cap="A comparison of the fourier transforms of the Riemann-Siegel Z function analogue of the L(\\mychi{(3,2)},s) L-function and partial Euler Product (using truncation at $1.25\\cdot \\sqrt{((\\frac{750}{2\\pi})^1\\cdot 3}$) in the complex plane at $\\sigma=0.9$ for the interval t=(-750,750) about the real axis. Off the critical line, to help use the partial Euler Product as an approximation of the Riemann-Siegel Z function only the positive frequencies (green) negative frequencies (blue) of the first and second Riemann-Siegel components are retained and spliced together to form a strong zeroth order improvement. In the middle row, the $\\textbf{lefthand panel}$ displays the true Riemann-Siegel Z function fourier transform behaviour while the $\\textbf{righthand panel}$ displays the neat splicing together of the first and second Riemann-Siegel components fourier transform behaviour.", out.width = c("49%","49%"), fig.show = "hold",  fig.height=5, warning=FALSE, cache=TRUE}


# Riemann-Siegel Z function of L32 function on critical line
# values recorded every .01 spacing in interval [-750,+750]

dfZ=read.csv("/home/john/pari/ZL32_res_p9_0_m750_p750_spacing_p01_real.csv",header=FALSE,colClasses = c("character"));
dfZ$V2=as.numeric(gsub(" ","",dfZ$V2));
dfZ=dfZ[order(as.numeric(dfZ$V1)),]

dfZi=read.csv("/home/john/pari/ZL32_res_p9_0_m750_p750_spacing_p01_imag.csv",header=FALSE,colClasses = c("character"));
dfZi$V2=as.numeric(gsub(" ","",dfZi$V2));
dfZi=dfZi[order(as.numeric(dfZi$V1)),]

fft_zeta_Zfn =  stats::fft(dfZ$V2+1i*dfZi$V2)


#first component of riemann-siegel formula based on first quiescent region
#EP(sigma+i*t)*exp(i*theta)
#using minimum 23 primes in prodeuler pari-gp function

dfplusZ=read.csv("/home/john/pari/ZL32plus_EP_res_p9_0_m750_p750_23upwards_spacing_p01_real.csv",header=FALSE,colClasses = c("character"));
dfplusZ$V2=as.numeric(gsub(" ","",dfplusZ$V2));
dfplusZ=dfplusZ[order(as.numeric(dfplusZ$V1)),]

dfplusZi=read.csv("/home/john/pari/ZL32plus_EP_res_p9_0_m750_p750_23upwards_spacing_p01_imag.csv",header=FALSE,colClasses = c("character"));
dfplusZi$V2=as.numeric(gsub(" ","",dfplusZi$V2));
dfplusZi=dfplusZi[order(as.numeric(dfplusZi$V1)),]

dfreal=dfplusZ;dfimag=dfplusZi

min_val=min(as.numeric(dfreal$V1));max_val=max(as.numeric(dfreal$V1))
dfimag=dfimag[(dfimag$V1 %in% dfreal$V1),]


fft_plusZ = stats::fft(dfreal$V2+1i*dfimag$V2)

dfreal_plus=dfreal
dfimag_plus=dfimag

lenf2=length(fft_plusZ)
delta_fft2=max(as.numeric(substr(dfreal$V1,1,12)))-min(as.numeric(substr(dfreal$V1,1,12)))
n=lenf2

#second component of riemann-siegel formula based on first quiescent region
#EP(1-(sigma+i*t))*chi(sigma+i*t)*exp(i*theta)
#using minimum 23 primes in prodeuler pari-gp function

dfminusZ=read.csv("/home/john/pari/ZL32minus_EP_res_p9_0_m750_p750_23upwards_spacing_p01_real.csv",header=FALSE,colClasses = c("character"));
dfminusZ$V2=as.numeric(gsub(" ","",dfminusZ$V2));
dfminusZ=dfminusZ[order(as.numeric(dfminusZ$V1)),]

dfminusZi=read.csv("/home/john/pari/ZL32minus_EP_res_p9_0_m750_p750_23upwards_spacing_p01_imag.csv",header=FALSE,colClasses = c("character"));
dfminusZi$V2=as.numeric(gsub(" ","",dfminusZi$V2));
dfminusZi=dfminusZi[order(as.numeric(dfminusZi$V1)),]

dfreal=dfminusZ;dfimag=dfminusZi

min_val=min(as.numeric(dfreal$V1));max_val=max(as.numeric(dfreal$V1))
dfimag=dfimag[dfimag$V1 %in% dfreal$V1,]

fft_minusZ = stats::fft(dfreal$V2+1i*dfimag$V2)

dfreal_minus=dfreal
dfimag_minus=dfimag

lenf=dim(dfreal)[1]

n=dim(dfreal)[1]

min_freq=min(as.numeric(substr(dfreal$V1,1,12)))
max_freq=max(as.numeric(substr(dfreal$V1,1,12)))

delta_fft=max_freq-min_freq
mid=floor(delta_fft/2/pi*log(floor(sqrt((max_freq/2/pi/c(1))*3))))

plot(c(-floor(n/2):(ceiling(n/2)-1))*2*pi/delta_fft,c(abs(fft_plusZ)[(ceiling(n/2)+1):n],abs(fft_plusZ)[1:(ceiling(n/2))]),xlim=c(-5,5),typ="l",xaxt="n",xlab="angular frequency (radians per sec)",ylab="|Amplitude|",main="fourier transform spectra of the first component of \n the partial Euler product Riemann-Siegel Z function \n using truncation at N1=sqrt((max(t)/2/pi)*3).")
abline(v=seq(-20,20,l=41),h=seq(0,1e5,l=6),lty=3,col="gray")
axis(1,at=seq(-20,20,l=41))
abline(v=-1/2*log((max_freq)/pi/2*3/c(1:2)^2)-0,col=rgb(1,0,0,0.3))
abline(v=1/2*log((max_freq)/pi/2*3/c(1:2)^2)-0,col=rgb(1,0,0,0.3))


yspan=range(c(rev(abs(Conj(fft_plusZ))[2:ceiling(n/2)])))
plot(c(-floor(n/2):-1)*2*pi/delta_fft,rep(0,floor(n/2)),xlim=c(-5,5),typ="l",xaxt="n",xlab="angular frequency (radians per sec)",ylab="|Amplitude|",main="piecewise fourier transform \n spectra filtering of the first component positive frequencies",col=4,ylim=yspan)
lines(c(0:(ceiling(n/2)-1))*2*pi/delta_fft,c(abs(fft_plusZ)[1:(ceiling(n/2))]),col=3)
abline(v=seq(-20,20,l=41),h=seq(0,1e5,l=6),lty=3,col="gray")
axis(1,at=seq(-20,20,l=41))
abline(v=-1/2*log((max_freq)/pi/2*3/c(1:2)^2)-0,col=rgb(1,0,0,0.3))
abline(v=1/2*log((max_freq)/pi/2*3/c(1:2)^2)-0,col=rgb(1,0,0,0.3))

n=dim(dfZ)[1]
min_freq=min(as.numeric(dfZ$V1))
max_freq=max(as.numeric(dfZ$V1))
delta_fft=max_freq-min_freq
mid=floor(delta_fft/2/pi*log(floor(sqrt((max_freq/2/pi/c(1))*5))))

plot(c(-floor(n/2):(ceiling(n/2)-1))*2*pi/delta_fft,c(abs(fft_zeta_Zfn)[(ceiling(n/2)+1):n],abs(fft_zeta_Zfn)[1:(ceiling(n/2))]),xlim=c(-5,5),typ="l",xaxt="n",xlab="angular frequency (radians per sec)",ylab="|Amplitude|",main="fourier transform spectra of the true Riemann-Siegel Z function.",cex.main=0.9)
abline(v=seq(-20,20,l=41),h=seq(0,1e5,l=6),lty=3,col="gray")
axis(1,at=seq(-20,20,l=41))
abline(v=-1/2*log((max_freq)/pi/2*3/c(1:2)^2)-0,col=rgb(1,0,0,0.3))
abline(v=1/2*log((max_freq)/pi/2*3/c(1:2)^2)-0,col=rgb(1,0,0,0.3))

n=dim(dfZ)[1]
min_freq=min(as.numeric(dfZ$V1))
max_freq=max(as.numeric(dfZ$V1))
delta_fft=max_freq-min_freq
mid=floor(delta_fft/2/pi*log(floor(sqrt((max_freq/2/pi/c(1))*5))))



yspan=range(abs(fft_hybrid))
plot(c(-floor(n/2):-1)*2*pi/delta_fft,abs(c(1/2*(fft_plusZ[ceiling(n/2)+1]+fft_minusZ[ceiling(n/2)+1]),fft_minusZ[(ceiling(n/2)+2):n])),xlim=c(-5,5),typ="l",xaxt="n",xlab="angular frequency (radians per sec)",ylab="|Amplitude|",main="piecewise fourier transform spectra filtering \n and splicing of the first component positive frequencies \n and the second component negative frequencies.",col=4,ylim=yspan)
lines(c(0:(floor(n/2)))*2*pi/delta_fft,abs(c(1/2*(fft_plusZ[1]+fft_minusZ[1]),(fft_plusZ)[2:(ceiling(n/2)+0)])),col=3)
abline(v=seq(-20,20,l=41),h=seq(0,1e5,l=6),lty=3,col="gray")
axis(1,at=seq(-20,20,l=41))
abline(v=-1/2*log((max_freq)/pi/2*3/c(1:2)^2)-0,col=rgb(1,0,0,0.3))
abline(v=1/2*log((max_freq)/pi/2*3/c(1:2)^2)-0,col=rgb(1,0,0,0.3))


n=dim(dfminusZ)[1]
min_freq=min(as.numeric(dfminusZ$V1))
max_freq=max(as.numeric(dfminusZ$V1))
delta_fft=max_freq-min_freq
mid=floor(delta_fft/2/pi*log(floor(sqrt((max_freq/2/pi/c(1))*3))))

plot(c(-floor(n/2):(ceiling(n/2)-1))*2*pi/delta_fft,c(abs(fft_minusZ)[(ceiling(n/2)+1):n],abs(fft_minusZ)[1:(ceiling(n/2))]),xlim=c(-5,5),typ="l",xaxt="n",xlab="angular frequency (radians per sec)",ylab="|Amplitude|",main="fourier transform spectra of the second component of \n the partial Euler product Riemann-Siegel Z function \n using truncation at N1=sqrt((max(t)/2/pi)*3).")
abline(v=seq(-20,20,l=41),h=seq(0,1e5,l=6),lty=3,col="gray")
axis(1,at=seq(-20,20,l=41))
abline(v=-1/2*log((max_freq)/pi/2*3/c(1:2)^2)-0,col=rgb(1,0,0,0.3))
abline(v=1/2*log((max_freq)/pi/2*3/c(1:2)^2)-0,col=rgb(1,0,0,0.3))

yspan=range(abs(fft_hybrid))
plot(c(-floor(n/2):-1)*2*pi/delta_fft,abs(fft_minusZ)[(ceiling(n/2)+1):n],xlim=c(-5,5),typ="l",xaxt="n",xlab="angular frequency (radians per sec)",ylab="|Amplitude|",main="piecewise fourier transform \n spectra filtering of the second component negative frequencies",col=4,ylim=yspan)
lines(c(0:(floor(n/2)))*2*pi/delta_fft,rep(0,ceiling(n/2)),col=3)
abline(v=seq(-20,20,l=41),h=seq(0,1e5,l=6),lty=3,col="gray")
axis(1,at=seq(-20,20,l=41))
abline(v=-1/2*log((max_freq)/pi/2*3/c(1:2)^2)-0,col=rgb(1,0,0,0.3))
abline(v=1/2*log((max_freq)/pi/2*3/c(1:2)^2)-0,col=rgb(1,0,0,0.3))


```



\clearpage


```{r Zfnchi32Lfunctionoveraninterval_anditsfouriertransform_0_pm750_sigma_0.9, echo=FALSE, fig.cap="Lefthand panel - True Z function shown in magenta (cyan) for real (imaginary) parts and spectral filtered based EP approximation shown in black (blue) for real (imaginary) parts, Right hand panel - Error in the real(Z) EP approximation. A comparison of the Riemann-Siegel Z function analogue of the L(\\mychi{(3,2)},s) L-function and spectrally filtered partial Euler Product (using truncation at $\\max (P,\\sqrt{((\\frac{t}{2\\pi})^1\\cdot 3}) $) in the complex plane at $\\sigma=0.9$ for the interval t=(-750,750) where $P_{min}={1,2,3,5,23}$ for rows 1-5. ", out.width = c("49%","49%"), fig.show = "hold",  fig.height=3.8, warning=FALSE, cache=TRUE}


# Riemann-Siegel Z function of L32 function on critical line
# values recorded every .01 spacing in interval [-750,+750]

dfZ=read.csv("/home/john/pari/ZL32_res_p9_0_m750_p750_spacing_p01_real.csv",header=FALSE,colClasses = c("character"));
dfZ$V2=as.numeric(gsub(" ","",dfZ$V2));
dfZ=dfZ[order(as.numeric(dfZ$V1)),]

dfZi=read.csv("/home/john/pari/ZL32_res_p9_0_m750_p750_spacing_p01_imag.csv",header=FALSE,colClasses = c("character"));
dfZi$V2=as.numeric(gsub(" ","",dfZi$V2));
dfZi=dfZi[order(as.numeric(dfZi$V1)),]


#Riemann-Siegel Z function of truncated Euler product at first quiescent region
#first component of riemann-siegel formula based on first quiescent region
#EP(sigma+i*t)*exp(i*theta)
#using 0 extra integers in prodeuler pari-gp function

dfplusZ=read.csv("/home/john/pari/ZL32plus_EP_res_p9_0_m750_p750_0extra_spacing_p01_real.csv",header=FALSE,colClasses = c("character"));
dfplusZ$V2=as.numeric(gsub(" ","",dfplusZ$V2));
dfplusZ=dfplusZ[order(as.numeric(dfplusZ$V1)),]

dfplusZi=read.csv("/home/john/pari/ZL32plus_EP_res_p9_0_m750_p750_0extra_spacing_p01_imag.csv",header=FALSE,colClasses = c("character"));
dfplusZi$V2=as.numeric(gsub(" ","",dfplusZi$V2));
dfplusZi=dfplusZi[order(as.numeric(dfplusZi$V1)),]

dfreal=dfplusZ;dfimag=dfplusZi

min_val=min(as.numeric(dfreal$V1));max_val=max(as.numeric(dfreal$V1))
dfimag=dfimag[(dfimag$V1 %in% dfreal$V1),]


fft_plusZ = stats::fft(dfreal$V2+1i*dfimag$V2)

dfreal_plus=dfreal
dfimag_plus=dfimag

lenf2=length(fft_plusZ)
delta_fft2=max(as.numeric(substr(dfreal$V1,1,12)))-min(as.numeric(substr(dfreal$V1,1,12)))
n=lenf2

#second component of riemann-siegel formula based on first quiescent region
#EP(1-(sigma+i*t))*chi(sigma+i*t)*exp(i*theta)
#using 0 extra integers in prodeuler pari-gp function

dfminusZ=read.csv("/home/john/pari/ZL32minus_EP_res_p9_0_m750_p750_0extra_spacing_p01_real.csv",header=FALSE,colClasses = c("character"));
dfminusZ$V2=as.numeric(gsub(" ","",dfminusZ$V2));
dfminusZ=dfminusZ[order(as.numeric(dfminusZ$V1)),]

dfminusZi=read.csv("/home/john/pari/ZL32minus_EP_res_p9_0_m750_p750_0extra_spacing_p01_imag.csv",header=FALSE,colClasses = c("character"));
dfminusZi$V2=as.numeric(gsub(" ","",dfminusZi$V2));
dfminusZi=dfminusZi[order(as.numeric(dfminusZi$V1)),]

dfreal=dfminusZ;dfimag=dfminusZi

min_val=min(as.numeric(dfreal$V1));max_val=max(as.numeric(dfreal$V1))
dfimag=dfimag[dfimag$V1 %in% dfreal$V1,]

fft_minusZ = stats::fft(dfreal$V2+1i*dfimag$V2)

dfreal_minus=dfreal
dfimag_minus=dfimag

lenf=dim(dfreal)[1]

n=dim(dfreal)[1]

min_freq=min(as.numeric(substr(dfreal$V1,1,12)))
max_freq=max(as.numeric(substr(dfreal$V1,1,12)))
delta_fft=max(as.numeric(substr(dfreal$V1,1,12)))-min(as.numeric(substr(dfreal$V1,1,12)))


#mix of plus and minus components formula when sigma != 0.5
#for spectral filtering of first quiescent region based Euler Product

fft_hybrid=c(1/2*(fft_plusZ[1]+fft_minusZ[1]),(fft_plusZ)[2:(ceiling(n/2)+0)],1/2*(fft_plusZ[ceiling(n/2)+1]+fft_minusZ[ceiling(n/2)+1]),fft_minusZ[(ceiling(n/2)+2):n])
inv_hybrid=fft(fft_hybrid,inverse=TRUE)

yspan=range(Re(inv_hybrid)/n,Im(inv_hybrid)/n)
plot(as.numeric(substr(dfreal$V1,1,22)),Re(inv_hybrid)/n,typ="l",
     ylab="Z component",ylim=c(-5,5),xlab="t",main="Riemann Siegel Z function analogue (using spectral filtered Euler Product) of \n L32 function using max(1,floor(1.25*sqrt(t/2/pi*3))) in EP",xlim=c(-40,40)+0,col="black",cex.main=0.8);grid(col="gray")
lines(as.numeric(substr(dfimag$V1,1,22)),Im(inv_hybrid)/n,col="blue")
lines(as.numeric(substr(dfZ$V1,1,22)),Re(dfZ$V2),col="magenta",lty=2)
lines(as.numeric(substr(dfZ$V1,1,22)),Re(dfZi$V2),col="cyan",lty=2)

plot(as.numeric(substr(dfreal$V1,1,22)),Re(inv_hybrid)/n-Re(dfZ$V2),typ="l",xlab="t",ylab="Error",main="Error in real(Z) component (using spectral filtered Euler Product approximation) of \n L32 function using max(1,floor(1.25*sqrt(t/2/pi*3))) in EP",col="gray",cex.main=0.8);grid(col="gray2")

#Riemann-Siegel Z function of truncated Euler product at first quiescent region
#first component of riemann-siegel formula based on first quiescent region
#EP(sigma+i*t)*exp(i*theta)
#using 0 extra integers in prodeuler pari-gp function

dfplusZ=read.csv("/home/john/pari/ZL32plus_EP_res_p9_0_m750_p750_2upwards_spacing_p01_real.csv",header=FALSE,colClasses = c("character"));
dfplusZ$V2=as.numeric(gsub(" ","",dfplusZ$V2));
dfplusZ=dfplusZ[order(as.numeric(dfplusZ$V1)),]

dfplusZi=read.csv("/home/john/pari/ZL32plus_EP_res_p9_0_m750_p750_2upwards_spacing_p01_imag.csv",header=FALSE,colClasses = c("character"));
dfplusZi$V2=as.numeric(gsub(" ","",dfplusZi$V2));
dfplusZi=dfplusZi[order(as.numeric(dfplusZi$V1)),]

dfreal=dfplusZ;dfimag=dfplusZi

min_val=min(as.numeric(dfreal$V1));max_val=max(as.numeric(dfreal$V1))
dfimag=dfimag[(dfimag$V1 %in% dfreal$V1),]


fft_plusZ = stats::fft(dfreal$V2+1i*dfimag$V2)

dfreal_plus=dfreal
dfimag_plus=dfimag

lenf2=length(fft_plusZ)
delta_fft2=max(as.numeric(substr(dfreal$V1,1,12)))-min(as.numeric(substr(dfreal$V1,1,12)))
n=lenf2

#second component of riemann-siegel formula based on first quiescent region
#EP(1-(sigma+i*t))*chi(sigma+i*t)*exp(i*theta)
#using 0 extra integers in prodeuler pari-gp function

dfminusZ=read.csv("/home/john/pari/ZL32minus_EP_res_p9_0_m750_p750_2upwards_spacing_p01_real.csv",header=FALSE,colClasses = c("character"));
dfminusZ$V2=as.numeric(gsub(" ","",dfminusZ$V2));
dfminusZ=dfminusZ[order(as.numeric(dfminusZ$V1)),]

dfminusZi=read.csv("/home/john/pari/ZL32minus_EP_res_p9_0_m750_p750_2upwards_spacing_p01_imag.csv",header=FALSE,colClasses = c("character"));
dfminusZi$V2=as.numeric(gsub(" ","",dfminusZi$V2));
dfminusZi=dfminusZi[order(as.numeric(dfminusZi$V1)),]

dfreal=dfminusZ;dfimag=dfminusZi

min_val=min(as.numeric(dfreal$V1));max_val=max(as.numeric(dfreal$V1))
dfimag=dfimag[dfimag$V1 %in% dfreal$V1,]

fft_minusZ = stats::fft(dfreal$V2+1i*dfimag$V2)

dfreal_minus=dfreal
dfimag_minus=dfimag

lenf=dim(dfreal)[1]

n=dim(dfreal)[1]

min_freq=min(as.numeric(substr(dfreal$V1,1,12)))
max_freq=max(as.numeric(substr(dfreal$V1,1,12)))
delta_fft=max(as.numeric(substr(dfreal$V1,1,12)))-min(as.numeric(substr(dfreal$V1,1,12)))


#mix of plus and minus components formula when sigma != 0.5
#for spectral filtering of first quiescent region based Euler Product

fft_hybrid=c(1/2*(fft_plusZ[1]+fft_minusZ[1]),(fft_plusZ)[2:(ceiling(n/2)+0)],1/2*(fft_plusZ[ceiling(n/2)+1]+fft_minusZ[ceiling(n/2)+1]),fft_minusZ[(ceiling(n/2)+2):n])
inv_hybrid=fft(fft_hybrid,inverse=TRUE)

yspan=range(Re(inv_hybrid)/n,Im(inv_hybrid)/n)
plot(as.numeric(substr(dfreal$V1,1,22)),Re(inv_hybrid)/n,typ="l",
     ylab="Z component",ylim=c(-5,5),xlab="t",main="Riemann Siegel Z function analogue (using spectral filtered Euler Product) of \n L32 function using max(2,floor(1.25*sqrt(t/2/pi*3))) in EP",xlim=c(-40,40)+0,col="black",cex.main=0.8);grid(col="gray")
lines(as.numeric(substr(dfimag$V1,1,22)),Im(inv_hybrid)/n,col="blue")
lines(as.numeric(substr(dfZ$V1,1,22)),Re(dfZ$V2),col="magenta",lty=2)
lines(as.numeric(substr(dfZ$V1,1,22)),Re(dfZi$V2),col="cyan",lty=2)

plot(as.numeric(substr(dfreal$V1,1,22)),Re(inv_hybrid)/n-Re(dfZ$V2),typ="l",xlab="t",ylab="Error",main="Error in real(Z) component (using spectral filtered Euler Product approximation) of \n L32 function using max(2,floor(1.25*sqrt(t/2/pi*3))) in EP",col="gray",cex.main=0.8);grid(col="gray2")

#Riemann-Siegel Z function of truncated Euler product at first quiescent region
#first component of riemann-siegel formula based on first quiescent region
#EP(sigma+i*t)*exp(i*theta)
#using 0 extra integers in prodeuler pari-gp function

dfplusZ=read.csv("/home/john/pari/ZL32plus_EP_res_p9_0_m750_p750_3upwards_spacing_p01_real.csv",header=FALSE,colClasses = c("character"));
dfplusZ$V2=as.numeric(gsub(" ","",dfplusZ$V2));
dfplusZ=dfplusZ[order(as.numeric(dfplusZ$V1)),]

dfplusZi=read.csv("/home/john/pari/ZL32plus_EP_res_p9_0_m750_p750_3upwards_spacing_p01_imag.csv",header=FALSE,colClasses = c("character"));
dfplusZi$V2=as.numeric(gsub(" ","",dfplusZi$V2));
dfplusZi=dfplusZi[order(as.numeric(dfplusZi$V1)),]

dfreal=dfplusZ;dfimag=dfplusZi

min_val=min(as.numeric(dfreal$V1));max_val=max(as.numeric(dfreal$V1))
dfimag=dfimag[(dfimag$V1 %in% dfreal$V1),]


fft_plusZ = stats::fft(dfreal$V2+1i*dfimag$V2)

dfreal_plus=dfreal
dfimag_plus=dfimag

lenf2=length(fft_plusZ)
delta_fft2=max(as.numeric(substr(dfreal$V1,1,12)))-min(as.numeric(substr(dfreal$V1,1,12)))
n=lenf2

#second component of riemann-siegel formula based on first quiescent region
#EP(1-(sigma+i*t))*chi(sigma+i*t)*exp(i*theta)
#using 0 extra integers in prodeuler pari-gp function

dfminusZ=read.csv("/home/john/pari/ZL32minus_EP_res_p9_0_m750_p750_3upwards_spacing_p01_real.csv",header=FALSE,colClasses = c("character"));
dfminusZ$V2=as.numeric(gsub(" ","",dfminusZ$V2));
dfminusZ=dfminusZ[order(as.numeric(dfminusZ$V1)),]

dfminusZi=read.csv("/home/john/pari/ZL32minus_EP_res_p9_0_m750_p750_3upwards_spacing_p01_imag.csv",header=FALSE,colClasses = c("character"));
dfminusZi$V2=as.numeric(gsub(" ","",dfminusZi$V2));
dfminusZi=dfminusZi[order(as.numeric(dfminusZi$V1)),]

dfreal=dfminusZ;dfimag=dfminusZi

min_val=min(as.numeric(dfreal$V1));max_val=max(as.numeric(dfreal$V1))
dfimag=dfimag[dfimag$V1 %in% dfreal$V1,]

fft_minusZ = stats::fft(dfreal$V2+1i*dfimag$V2)

dfreal_minus=dfreal
dfimag_minus=dfimag

lenf=dim(dfreal)[1]

n=dim(dfreal)[1]

min_freq=min(as.numeric(substr(dfreal$V1,1,12)))
max_freq=max(as.numeric(substr(dfreal$V1,1,12)))
delta_fft=max(as.numeric(substr(dfreal$V1,1,12)))-min(as.numeric(substr(dfreal$V1,1,12)))


#mix of plus and minus components formula when sigma != 0.5
#for spectral filtering of first quiescent region based Euler Product

fft_hybrid=c(1/2*(fft_plusZ[1]+fft_minusZ[1]),(fft_plusZ)[2:(ceiling(n/2)+0)],1/2*(fft_plusZ[ceiling(n/2)+1]+fft_minusZ[ceiling(n/2)+1]),fft_minusZ[(ceiling(n/2)+2):n])
inv_hybrid=fft(fft_hybrid,inverse=TRUE)

yspan=range(Re(inv_hybrid)/n,Im(inv_hybrid)/n)
plot(as.numeric(substr(dfreal$V1,1,22)),Re(inv_hybrid)/n,typ="l",
     ylab="Z component",ylim=c(-5,5),xlab="t",main="Riemann Siegel Z function analogue (using spectral filtered Euler Product) of \n L32 function using max(3,floor(1.25*sqrt(t/2/pi*3))) in EP",xlim=c(-40,40)+0,col="black",cex.main=0.8);grid(col="gray")
lines(as.numeric(substr(dfimag$V1,1,22)),Im(inv_hybrid)/n,col="blue")
lines(as.numeric(substr(dfZ$V1,1,22)),Re(dfZ$V2),col="magenta",lty=2)
lines(as.numeric(substr(dfZ$V1,1,22)),Re(dfZi$V2),col="cyan",lty=2)

plot(as.numeric(substr(dfreal$V1,1,22)),Re(inv_hybrid)/n-Re(dfZ$V2),typ="l",xlab="t",ylab="Error",main="Error in real(Z) component (using spectral filtered Euler Product approximation) of \n L32 function using max(3,floor(1.25*sqrt(t/2/pi*3))) in EP",col="gray",cex.main=0.8);grid(col="gray2")


#Riemann-Siegel Z function of truncated Euler product at first quiescent region
#first component of riemann-siegel formula based on first quiescent region
#EP(sigma+i*t)*exp(i*theta)
#using 0 extra integers in prodeuler pari-gp function

dfplusZ=read.csv("/home/john/pari/ZL32plus_EP_res_p9_0_m750_p750_5upwards_spacing_p01_real.csv",header=FALSE,colClasses = c("character"));
dfplusZ$V2=as.numeric(gsub(" ","",dfplusZ$V2));
dfplusZ=dfplusZ[order(as.numeric(dfplusZ$V1)),]

dfplusZi=read.csv("/home/john/pari/ZL32plus_EP_res_p9_0_m750_p750_5upwards_spacing_p01_imag.csv",header=FALSE,colClasses = c("character"));
dfplusZi$V2=as.numeric(gsub(" ","",dfplusZi$V2));
dfplusZi=dfplusZi[order(as.numeric(dfplusZi$V1)),]

dfreal=dfplusZ;dfimag=dfplusZi

min_val=min(as.numeric(dfreal$V1));max_val=max(as.numeric(dfreal$V1))
dfimag=dfimag[(dfimag$V1 %in% dfreal$V1),]


fft_plusZ = stats::fft(dfreal$V2+1i*dfimag$V2)

dfreal_plus=dfreal
dfimag_plus=dfimag

lenf2=length(fft_plusZ)
delta_fft2=max(as.numeric(substr(dfreal$V1,1,12)))-min(as.numeric(substr(dfreal$V1,1,12)))
n=lenf2

#second component of riemann-siegel formula based on first quiescent region
#EP(1-(sigma+i*t))*chi(sigma+i*t)*exp(i*theta)
#using 0 extra integers in prodeuler pari-gp function

dfminusZ=read.csv("/home/john/pari/ZL32minus_EP_res_p9_0_m750_p750_5upwards_spacing_p01_real.csv",header=FALSE,colClasses = c("character"));
dfminusZ$V2=as.numeric(gsub(" ","",dfminusZ$V2));
dfminusZ=dfminusZ[order(as.numeric(dfminusZ$V1)),]

dfminusZi=read.csv("/home/john/pari/ZL32minus_EP_res_p9_0_m750_p750_5upwards_spacing_p01_imag.csv",header=FALSE,colClasses = c("character"));
dfminusZi$V2=as.numeric(gsub(" ","",dfminusZi$V2));
dfminusZi=dfminusZi[order(as.numeric(dfminusZi$V1)),]

dfreal=dfminusZ;dfimag=dfminusZi

min_val=min(as.numeric(dfreal$V1));max_val=max(as.numeric(dfreal$V1))
dfimag=dfimag[dfimag$V1 %in% dfreal$V1,]

fft_minusZ = stats::fft(dfreal$V2+1i*dfimag$V2)

dfreal_minus=dfreal
dfimag_minus=dfimag

lenf=dim(dfreal)[1]

n=dim(dfreal)[1]

min_freq=min(as.numeric(substr(dfreal$V1,1,12)))
max_freq=max(as.numeric(substr(dfreal$V1,1,12)))
delta_fft=max(as.numeric(substr(dfreal$V1,1,12)))-min(as.numeric(substr(dfreal$V1,1,12)))


#mix of plus and minus components formula when sigma != 0.5
#for spectral filtering of first quiescent region based Euler Product

fft_hybrid=c(1/2*(fft_plusZ[1]+fft_minusZ[1]),(fft_plusZ)[2:(ceiling(n/2)+0)],1/2*(fft_plusZ[ceiling(n/2)+1]+fft_minusZ[ceiling(n/2)+1]),fft_minusZ[(ceiling(n/2)+2):n])
inv_hybrid=fft(fft_hybrid,inverse=TRUE)

yspan=range(Re(inv_hybrid)/n,Im(inv_hybrid)/n)
plot(as.numeric(substr(dfreal$V1,1,22)),Re(inv_hybrid)/n,typ="l",
     ylab="Z component",ylim=c(-5,5),xlab="t",main="Riemann Siegel Z function analogue (using spectral filtered Euler Product) of \n L32 function using max(5,floor(1.25*sqrt(t/2/pi*3))) in EP",xlim=c(-40,40)+0,col="black",cex.main=0.8);grid(col="gray")
lines(as.numeric(substr(dfimag$V1,1,22)),Im(inv_hybrid)/n,col="blue")
lines(as.numeric(substr(dfZ$V1,1,22)),Re(dfZ$V2),col="magenta",lty=2)
lines(as.numeric(substr(dfZ$V1,1,22)),Re(dfZi$V2),col="cyan",lty=2)

plot(as.numeric(substr(dfreal$V1,1,22)),Re(inv_hybrid)/n-Re(dfZ$V2),typ="l",xlab="t",ylab="Error",main="Error in real(Z) component (using spectral filtered Euler Product approximation) of \n L32 function using max(5,floor(1.25*sqrt(t/2/pi*3))) in EP",col="gray",cex.main=0.8);grid(col="gray2")
lines(rep((7/1.25)^2*2*pi/3,2),c(-0.65,-0.55),lty=2,col="blue")
lines(rep((11/1.25)^2*2*pi/3,2),c(-0.65,-0.55),lty=2,col="blue")
lines(rep((13/1.25)^2*2*pi/3,2),c(-0.65,-0.55),lty=2,col="blue")
lines(rep((17/1.25)^2*2*pi/3,2),c(-0.65,-0.55),lty=2,col="blue")
lines(rep((19/1.25)^2*2*pi/3,2),c(-0.65,-0.55),lty=2,col="blue")
lines(rep((23/1.25)^2*2*pi/3,2),c(-0.65,-0.55),lty=2,col="blue")
lines(-rep((7/1.25)^2*2*pi/3,2),c(-0.65,-0.55),lty=2,col="blue")
lines(-rep((11/1.25)^2*2*pi/3,2),c(-0.65,-0.55),lty=2,col="blue")
lines(-rep((13/1.25)^2*2*pi/3,2),c(-0.65,-0.55),lty=2,col="blue")
lines(-rep((17/1.25)^2*2*pi/3,2),c(-0.65,-0.55),lty=2,col="blue")
lines(-rep((19/1.25)^2*2*pi/3,2),c(-0.65,-0.55),lty=2,col="blue")
lines(-rep((23/1.25)^2*2*pi/3,2),c(-0.65,-0.55),lty=2,col="blue")
text(x=c(-1,1)*(7/1.25)^2*2*pi/3,y=-.67,"7")
text(x=c(-1,1)*(11/1.25)^2*2*pi/3,y=-.67,"11")
text(x=c(-1,1)*(13/1.25)^2*2*pi/3,y=-.67,"13")
text(x=c(-1,1)*(17/1.25)^2*2*pi/3,y=-.67,"17")
text(x=c(-1,1)*(19/1.25)^2*2*pi/3,y=-.67,"19")
text(x=c(-1,1)*(23/1.25)^2*2*pi/3,y=-.67,"23")
text(x=50,y=-0.5,"t value when next prime is included in EP")

#Riemann-Siegel Z function of truncated Euler product at first quiescent region
#first component of riemann-siegel formula based on first quiescent region
#EP(sigma+i*t)*exp(i*theta)
#using 0 extra integers in prodeuler pari-gp function

dfplusZ=read.csv("/home/john/pari/ZL32plus_EP_res_p9_0_m750_p750_23upwards_spacing_p01_real.csv",header=FALSE,colClasses = c("character"));
dfplusZ$V2=as.numeric(gsub(" ","",dfplusZ$V2));
dfplusZ=dfplusZ[order(as.numeric(dfplusZ$V1)),]

dfplusZi=read.csv("/home/john/pari/ZL32plus_EP_res_p9_0_m750_p750_23upwards_spacing_p01_imag.csv",header=FALSE,colClasses = c("character"));
dfplusZi$V2=as.numeric(gsub(" ","",dfplusZi$V2));
dfplusZi=dfplusZi[order(as.numeric(dfplusZi$V1)),]

dfreal=dfplusZ;dfimag=dfplusZi

min_val=min(as.numeric(dfreal$V1));max_val=max(as.numeric(dfreal$V1))
dfimag=dfimag[(dfimag$V1 %in% dfreal$V1),]


fft_plusZ = stats::fft(dfreal$V2+1i*dfimag$V2)

dfreal_plus=dfreal
dfimag_plus=dfimag

lenf2=length(fft_plusZ)
delta_fft2=max(as.numeric(substr(dfreal$V1,1,12)))-min(as.numeric(substr(dfreal$V1,1,12)))
n=lenf2

#second component of riemann-siegel formula based on first quiescent region
#EP(1-(sigma+i*t))*chi(sigma+i*t)*exp(i*theta)
#using 0 extra integers in prodeuler pari-gp function

dfminusZ=read.csv("/home/john/pari/ZL32minus_EP_res_p9_0_m750_p750_23upwards_spacing_p01_real.csv",header=FALSE,colClasses = c("character"));
dfminusZ$V2=as.numeric(gsub(" ","",dfminusZ$V2));
dfminusZ=dfminusZ[order(as.numeric(dfminusZ$V1)),]

dfminusZi=read.csv("/home/john/pari/ZL32minus_EP_res_p9_0_m750_p750_23upwards_spacing_p01_imag.csv",header=FALSE,colClasses = c("character"));
dfminusZi$V2=as.numeric(gsub(" ","",dfminusZi$V2));
dfminusZi=dfminusZi[order(as.numeric(dfminusZi$V1)),]

dfreal=dfminusZ;dfimag=dfminusZi

min_val=min(as.numeric(dfreal$V1));max_val=max(as.numeric(dfreal$V1))
dfimag=dfimag[dfimag$V1 %in% dfreal$V1,]

fft_minusZ = stats::fft(dfreal$V2+1i*dfimag$V2)

dfreal_minus=dfreal
dfimag_minus=dfimag

lenf=dim(dfreal)[1]

n=dim(dfreal)[1]

min_freq=min(as.numeric(substr(dfreal$V1,1,12)))
max_freq=max(as.numeric(substr(dfreal$V1,1,12)))
delta_fft=max(as.numeric(substr(dfreal$V1,1,12)))-min(as.numeric(substr(dfreal$V1,1,12)))


#mix of plus and minus components formula when sigma != 0.5
#for spectral filtering of first quiescent region based Euler Product

fft_hybrid=c(1/2*(fft_plusZ[1]+fft_minusZ[1]),(fft_plusZ)[2:(ceiling(n/2)+0)],1/2*(fft_plusZ[ceiling(n/2)+1]+fft_minusZ[ceiling(n/2)+1]),fft_minusZ[(ceiling(n/2)+2):n])
inv_hybrid=fft(fft_hybrid,inverse=TRUE)

yspan=range(Re(inv_hybrid)/n,Im(inv_hybrid)/n)
plot(as.numeric(substr(dfreal$V1,1,22)),Re(inv_hybrid)/n,typ="l",
     ylab="Z component",ylim=c(-5,5),xlab="t",main="Riemann Siegel Z function analogue (using spectral filtered Euler Product) of \n L32 function using max(23,floor(1.25*sqrt(t/2/pi*3))) in EP",xlim=c(-40,40)+0,col="black",cex.main=0.8);grid(col="gray")
lines(as.numeric(substr(dfimag$V1,1,22)),Im(inv_hybrid)/n,col="blue")
lines(as.numeric(substr(dfZ$V1,1,22)),Re(dfZ$V2),col="magenta",lty=2)
lines(as.numeric(substr(dfZ$V1,1,22)),Re(dfZi$V2),col="cyan",lty=2)


plot(as.numeric(substr(dfreal$V1,1,22)),Re(inv_hybrid)/n-Re(dfZ$V2),typ="l",xlab="t",ylab="Error",main="Error in real(Z) component (using spectral filtered Euler Product approximation) of \n L32 function using max(23,floor(1.25*sqrt(t/2/pi*3))) in EP",col="gray",cex.main=0.8);grid(col="gray")


```



\clearpage

```{r Zfnchi32Lfunction_fouriertransform_0_pm750_res_p1, echo=FALSE, fig.cap="A comparison of the fourier transforms of the Riemann-Siegel Z function analogue of the L(\\mychi{(3,2)},s) L-function and partial Euler Product (using truncation at $1.25\\cdot \\sqrt{((\\frac{750}{2\\pi})^1\\cdot 3}$) in the complex plane at $\\sigma=0.1$ for the interval t=(-750,750) about the real axis. Off the critical line, to help use the partial Euler Product as an approximation of the Riemann-Siegel Z function only the positive frequencies (green) negative frequencies (blue) of the first and second Riemann-Siegel components are retained and spliced together to form a strong zeroth order improvement. In the middle row, the $\\textbf{lefthand panel}$ displays the true Riemann-Siegel Z function fourier transform behaviour while the $\\textbf{righthand panel}$ displays the neat splicing together of the first and second Riemann-Siegel components fourier transform behaviour.", out.width = c("49%","49%"), fig.show = "hold",  fig.height=5, warning=FALSE, cache=TRUE}


# Riemann-Siegel Z function of L32 function on critical line
# values recorded every .01 spacing in interval [-750,+750]

dfZ=read.csv("/home/john/pari/ZL32_res_p1_0_m750_p750_spacing_p01_real.csv",header=FALSE,colClasses = c("character"));
dfZ$V2=as.numeric(gsub(" ","",dfZ$V2));
dfZ=dfZ[order(as.numeric(dfZ$V1)),]

dfZi=read.csv("/home/john/pari/ZL32_res_p1_0_m750_p750_spacing_p01_imag.csv",header=FALSE,colClasses = c("character"));
dfZi$V2=as.numeric(gsub(" ","",dfZi$V2));
dfZi=dfZi[order(as.numeric(dfZi$V1)),]

fft_zeta_Zfn =  stats::fft(dfZ$V2+1i*dfZi$V2)


#first component of riemann-siegel formula based on first quiescent region
#EP(sigma+i*t)*exp(i*theta)
#using minimum 23 primes in prodeuler pari-gp function

dfplusZ=read.csv("/home/john/pari/ZL32plus_EP_res_p1_0_m750_p750_23upwards_spacing_p01_real.csv",header=FALSE,colClasses = c("character"));
dfplusZ$V2=as.numeric(gsub(" ","",dfplusZ$V2));
dfplusZ=dfplusZ[order(as.numeric(dfplusZ$V1)),]

dfplusZi=read.csv("/home/john/pari/ZL32plus_EP_res_p1_0_m750_p750_23upwards_spacing_p01_imag.csv",header=FALSE,colClasses = c("character"));
dfplusZi$V2=as.numeric(gsub(" ","",dfplusZi$V2));
dfplusZi=dfplusZi[order(as.numeric(dfplusZi$V1)),]

dfreal=dfplusZ;dfimag=dfplusZi

min_val=min(as.numeric(dfreal$V1));max_val=max(as.numeric(dfreal$V1))
dfimag=dfimag[(dfimag$V1 %in% dfreal$V1),]


fft_plusZ = stats::fft(dfreal$V2+1i*dfimag$V2)

dfreal_plus=dfreal
dfimag_plus=dfimag

lenf2=length(fft_plusZ)
delta_fft2=max(as.numeric(substr(dfreal$V1,1,12)))-min(as.numeric(substr(dfreal$V1,1,12)))
n=lenf2

#second component of riemann-siegel formula based on first quiescent region
#EP(1-(sigma+i*t))*chi(sigma+i*t)*exp(i*theta)
#using minimum 23 primes in prodeuler pari-gp function

dfminusZ=read.csv("/home/john/pari/ZL32minus_EP_res_p1_0_m750_p750_23upwards_spacing_p01_real.csv",header=FALSE,colClasses = c("character"));
dfminusZ$V2=as.numeric(gsub(" ","",dfminusZ$V2));
dfminusZ=dfminusZ[order(as.numeric(dfminusZ$V1)),]

dfminusZi=read.csv("/home/john/pari/ZL32minus_EP_res_p1_0_m750_p750_23upwards_spacing_p01_imag.csv",header=FALSE,colClasses = c("character"));
dfminusZi$V2=as.numeric(gsub(" ","",dfminusZi$V2));
dfminusZi=dfminusZi[order(as.numeric(dfminusZi$V1)),]

dfreal=dfminusZ;dfimag=dfminusZi

min_val=min(as.numeric(dfreal$V1));max_val=max(as.numeric(dfreal$V1))
dfimag=dfimag[dfimag$V1 %in% dfreal$V1,]

fft_minusZ = stats::fft(dfreal$V2+1i*dfimag$V2)

dfreal_minus=dfreal
dfimag_minus=dfimag

lenf=dim(dfreal)[1]

n=dim(dfreal)[1]

min_freq=min(as.numeric(substr(dfreal$V1,1,12)))
max_freq=max(as.numeric(substr(dfreal$V1,1,12)))

delta_fft=max_freq-min_freq
mid=floor(delta_fft/2/pi*log(floor(sqrt((max_freq/2/pi/c(1))*3))))

plot(c(-floor(n/2):(ceiling(n/2)-1))*2*pi/delta_fft,c(abs(fft_plusZ)[(ceiling(n/2)+1):n],abs(fft_plusZ)[1:(ceiling(n/2))]),xlim=c(-5,5),typ="l",xaxt="n",xlab="angular frequency (radians per sec)",ylab="|Amplitude|",main="fourier transform spectra of the first component of \n the partial Euler product Riemann-Siegel Z function \n using truncation at N1=sqrt((max(t)/2/pi)*3).")
abline(v=seq(-20,20,l=41),h=seq(0,1e5,l=6),lty=3,col="gray")
axis(1,at=seq(-20,20,l=41))
abline(v=-1/2*log((max_freq)/pi/2*3/c(1:2)^2)-0,col=rgb(1,0,0,0.3))
abline(v=1/2*log((max_freq)/pi/2*3/c(1:2)^2)-0,col=rgb(1,0,0,0.3))

fft_hybrid=c(1/2*(fft_plusZ[1]+fft_minusZ[1]),(fft_plusZ)[2:(ceiling(n/2)+0)],1/2*(fft_plusZ[ceiling(n/2)+1]+fft_minusZ[ceiling(n/2)+1]),fft_minusZ[(ceiling(n/2)+2):n])

yspan=range(abs(fft_hybrid))
plot(c(-floor(n/2):-1)*2*pi/delta_fft,rep(0,floor(n/2)),xlim=c(-5,5),typ="l",xaxt="n",xlab="angular frequency (radians per sec)",ylab="|Amplitude|",main="piecewise fourier transform \n spectra filtering of the first component positive frequencies",col=4,ylim=yspan)
lines(c(0:(ceiling(n/2)-1))*2*pi/delta_fft,c(abs(fft_plusZ)[1:(ceiling(n/2))]),col=3)
abline(v=seq(-20,20,l=41),h=seq(0,1e5,l=6),lty=3,col="gray")
axis(1,at=seq(-20,20,l=41))
abline(v=-1/2*log((max_freq)/pi/2*3/c(1:2)^2)-0,col=rgb(1,0,0,0.3))
abline(v=1/2*log((max_freq)/pi/2*3/c(1:2)^2)-0,col=rgb(1,0,0,0.3))

n=dim(dfZ)[1]
min_freq=min(as.numeric(dfZ$V1))
max_freq=max(as.numeric(dfZ$V1))
delta_fft=max_freq-min_freq
mid=floor(delta_fft/2/pi*log(floor(sqrt((max_freq/2/pi/c(1))*5))))

plot(c(-floor(n/2):(ceiling(n/2)-1))*2*pi/delta_fft,c(abs(fft_zeta_Zfn)[(ceiling(n/2)+1):n],abs(fft_zeta_Zfn)[1:(ceiling(n/2))]),xlim=c(-5,5),typ="l",xaxt="n",xlab="angular frequency (radians per sec)",ylab="|Amplitude|",main="fourier transform spectra of the true Riemann-Siegel Z function.",cex.main=0.9)
abline(v=seq(-20,20,l=41),h=seq(0,1e5,l=6),lty=3,col="gray")
axis(1,at=seq(-20,20,l=41))
abline(v=-1/2*log((max_freq)/pi/2*3/c(1:2)^2)-0,col=rgb(1,0,0,0.3))
abline(v=1/2*log((max_freq)/pi/2*3/c(1:2)^2)-0,col=rgb(1,0,0,0.3))

n=dim(dfZ)[1]
min_freq=min(as.numeric(dfZ$V1))
max_freq=max(as.numeric(dfZ$V1))
delta_fft=max_freq-min_freq
mid=floor(delta_fft/2/pi*log(floor(sqrt((max_freq/2/pi/c(1))*5))))


fft_hybrid=c(1/2*(fft_plusZ[1]+fft_minusZ[1]),(fft_plusZ)[2:(ceiling(n/2)+0)],1/2*(fft_plusZ[ceiling(n/2)+1]+fft_minusZ[ceiling(n/2)+1]),fft_minusZ[(ceiling(n/2)+2):n])

yspan=range(abs(fft_hybrid))
plot(c(-floor(n/2):-1)*2*pi/delta_fft,abs(c(1/2*(fft_plusZ[ceiling(n/2)+1]+fft_minusZ[ceiling(n/2)+1]),fft_minusZ[(ceiling(n/2)+2):n])),xlim=c(-5,5),typ="l",xaxt="n",xlab="angular frequency (radians per sec)",ylab="|Amplitude|",main="piecewise fourier transform spectra filtering \n and splicing of the first component positive frequencies \n and the second component negative frequencies.",col=4,ylim=yspan)
lines(c(0:(floor(n/2)))*2*pi/delta_fft,abs(c(1/2*(fft_plusZ[1]+fft_minusZ[1]),(fft_plusZ)[2:(ceiling(n/2)+0)])),col=3)
abline(v=seq(-20,20,l=41),h=seq(0,1e5,l=6),lty=3,col="gray")
axis(1,at=seq(-20,20,l=41))
abline(v=-1/2*log((max_freq)/pi/2*3/c(1:2)^2)-0,col=rgb(1,0,0,0.3))
abline(v=1/2*log((max_freq)/pi/2*3/c(1:2)^2)-0,col=rgb(1,0,0,0.3))


n=dim(dfminusZ)[1]
min_freq=min(as.numeric(dfminusZ$V1))
max_freq=max(as.numeric(dfminusZ$V1))
delta_fft=max_freq-min_freq
mid=floor(delta_fft/2/pi*log(floor(sqrt((max_freq/2/pi/c(1))*3))))

plot(c(-floor(n/2):(ceiling(n/2)-1))*2*pi/delta_fft,c(abs(fft_minusZ)[(ceiling(n/2)+1):n],abs(fft_minusZ)[1:(ceiling(n/2))]),xlim=c(-5,5),typ="l",xaxt="n",xlab="angular frequency (radians per sec)",ylab="|Amplitude|",main="fourier transform spectra of the second component of \n the partial Euler product Riemann-Siegel Z function \n using truncation at N1=sqrt((max(t)/2/pi)*3).")
abline(v=seq(-20,20,l=41),h=seq(0,1e5,l=6),lty=3,col="gray")
axis(1,at=seq(-20,20,l=41))
abline(v=-1/2*log((max_freq)/pi/2*3/c(1:2)^2)-0,col=rgb(1,0,0,0.3))
abline(v=1/2*log((max_freq)/pi/2*3/c(1:2)^2)-0,col=rgb(1,0,0,0.3))

yspan=range(abs(fft_hybrid))
plot(c(-floor(n/2):-1)*2*pi/delta_fft,abs(fft_minusZ)[(ceiling(n/2)+1):n],xlim=c(-5,5),typ="l",xaxt="n",xlab="angular frequency (radians per sec)",ylab="|Amplitude|",main="piecewise fourier transform \n spectra filtering of the second component negative frequencies",col=4,ylim=yspan)
lines(c(0:(floor(n/2)))*2*pi/delta_fft,rep(0,ceiling(n/2)),col=3)
abline(v=seq(-20,20,l=41),h=seq(0,1e5,l=6),lty=3,col="gray")
axis(1,at=seq(-20,20,l=41))
abline(v=-1/2*log((max_freq)/pi/2*3/c(1:2)^2)-0,col=rgb(1,0,0,0.3))
abline(v=1/2*log((max_freq)/pi/2*3/c(1:2)^2)-0,col=rgb(1,0,0,0.3))


```



\clearpage


```{r Zfnchi32Lfunctionoveraninterval_anditsfouriertransform_0_pm750_sigma_0.1, echo=FALSE, fig.cap="Lefthand panel - True Z function shown in magenta (cyan) for real (imaginary) parts and spectral filtered based EP approximation shown in black (blue) for real (imaginary) parts, Right hand panel - Error in the real(Z) EP approximation. A comparison of the Riemann-Siegel Z function analogue of the L(\\mychi{(3,2)},s) L-function and spectrally filtered partial Euler Product (using truncation at $\\max (P,\\sqrt{((\\frac{t}{2\\pi})^1\\cdot 3}) $) in the complex plane at $\\sigma=0.1$ for the interval t=(-750,750) where $P_{min}={1,2,3,5,23}$ for rows 1-5. ", out.width = c("49%","49%"), fig.show = "hold",  fig.height=3.8, warning=FALSE, cache=TRUE}


# Riemann-Siegel Z function of L32 function on critical line
# values recorded every .01 spacing in interval [-750,+750]

dfZ=read.csv("/home/john/pari/ZL32_res_p1_0_m750_p750_spacing_p01_real.csv",header=FALSE,colClasses = c("character"));
dfZ$V2=as.numeric(gsub(" ","",dfZ$V2));
dfZ=dfZ[order(as.numeric(dfZ$V1)),]

dfZi=read.csv("/home/john/pari/ZL32_res_p1_0_m750_p750_spacing_p01_imag.csv",header=FALSE,colClasses = c("character"));
dfZi$V2=as.numeric(gsub(" ","",dfZi$V2));
dfZi=dfZi[order(as.numeric(dfZi$V1)),]


#Riemann-Siegel Z function of truncated Euler product at first quiescent region
#first component of riemann-siegel formula based on first quiescent region
#EP(sigma+i*t)*exp(i*theta)
#using 0 extra integers in prodeuler pari-gp function

dfplusZ=read.csv("/home/john/pari/ZL32plus_EP_res_p1_0_m750_p750_0extra_spacing_p01_real.csv",header=FALSE,colClasses = c("character"));
dfplusZ$V2=as.numeric(gsub(" ","",dfplusZ$V2));
dfplusZ=dfplusZ[order(as.numeric(dfplusZ$V1)),]

dfplusZi=read.csv("/home/john/pari/ZL32plus_EP_res_p1_0_m750_p750_0extra_spacing_p01_imag.csv",header=FALSE,colClasses = c("character"));
dfplusZi$V2=as.numeric(gsub(" ","",dfplusZi$V2));
dfplusZi=dfplusZi[order(as.numeric(dfplusZi$V1)),]

dfreal=dfplusZ;dfimag=dfplusZi

min_val=min(as.numeric(dfreal$V1));max_val=max(as.numeric(dfreal$V1))
dfimag=dfimag[(dfimag$V1 %in% dfreal$V1),]


fft_plusZ = stats::fft(dfreal$V2+1i*dfimag$V2)

dfreal_plus=dfreal
dfimag_plus=dfimag

lenf2=length(fft_plusZ)
delta_fft2=max(as.numeric(substr(dfreal$V1,1,12)))-min(as.numeric(substr(dfreal$V1,1,12)))
n=lenf2

#second component of riemann-siegel formula based on first quiescent region
#EP(1-(sigma+i*t))*chi(sigma+i*t)*exp(i*theta)
#using 0 extra integers in prodeuler pari-gp function

dfminusZ=read.csv("/home/john/pari/ZL32minus_EP_res_p1_0_m750_p750_0extra_spacing_p01_real.csv",header=FALSE,colClasses = c("character"));
dfminusZ$V2=as.numeric(gsub(" ","",dfminusZ$V2));
dfminusZ=dfminusZ[order(as.numeric(dfminusZ$V1)),]

dfminusZi=read.csv("/home/john/pari/ZL32minus_EP_res_p1_0_m750_p750_0extra_spacing_p01_imag.csv",header=FALSE,colClasses = c("character"));
dfminusZi$V2=as.numeric(gsub(" ","",dfminusZi$V2));
dfminusZi=dfminusZi[order(as.numeric(dfminusZi$V1)),]

dfreal=dfminusZ;dfimag=dfminusZi

min_val=min(as.numeric(dfreal$V1));max_val=max(as.numeric(dfreal$V1))
dfimag=dfimag[dfimag$V1 %in% dfreal$V1,]

fft_minusZ = stats::fft(dfreal$V2+1i*dfimag$V2)

dfreal_minus=dfreal
dfimag_minus=dfimag

lenf=dim(dfreal)[1]

n=dim(dfreal)[1]

min_freq=min(as.numeric(substr(dfreal$V1,1,12)))
max_freq=max(as.numeric(substr(dfreal$V1,1,12)))
delta_fft=max(as.numeric(substr(dfreal$V1,1,12)))-min(as.numeric(substr(dfreal$V1,1,12)))


#mix of plus and minus components formula when sigma != 0.5
#for spectral filtering of first quiescent region based Euler Product

fft_hybrid=c(1/2*(fft_plusZ[1]+fft_minusZ[1]),(fft_plusZ)[2:(ceiling(n/2)+0)],1/2*(fft_plusZ[ceiling(n/2)+1]+fft_minusZ[ceiling(n/2)+1]),fft_minusZ[(ceiling(n/2)+2):n])
inv_hybrid=fft(fft_hybrid,inverse=TRUE)

yspan=range(Re(inv_hybrid)/n,Im(inv_hybrid)/n)
plot(as.numeric(substr(dfreal$V1,1,22)),Re(inv_hybrid)/n,typ="l",
     ylab="Z component",ylim=c(-6,6),xlab="t",main="Riemann Siegel Z function analogue (using spectral filtered Euler Product) of \n L32 function using max(1,floor(1.25*sqrt(t/2/pi*3))) in EP",xlim=c(-40,40)+0,col="black",cex.main=0.8);grid(col="gray")
lines(as.numeric(substr(dfimag$V1,1,22)),Im(inv_hybrid)/n,col="blue")
lines(as.numeric(substr(dfZ$V1,1,22)),Re(dfZ$V2),col="magenta",lty=2)
lines(as.numeric(substr(dfZ$V1,1,22)),Re(dfZi$V2),col="cyan",lty=2)

plot(as.numeric(substr(dfreal$V1,1,22)),Re(inv_hybrid)/n-Re(dfZ$V2),typ="l",xlab="t",ylab="Error",main="Error in real(Z) component (using spectral filtered Euler Product approximation) of \n L32 function using max(1,floor(1.25*sqrt(t/2/pi*3))) in EP",col="gray",cex.main=0.8);grid(col="gray2")

#Riemann-Siegel Z function of truncated Euler product at first quiescent region
#first component of riemann-siegel formula based on first quiescent region
#EP(sigma+i*t)*exp(i*theta)
#using 0 extra integers in prodeuler pari-gp function

dfplusZ=read.csv("/home/john/pari/ZL32plus_EP_res_p1_0_m750_p750_2upwards_spacing_p01_real.csv",header=FALSE,colClasses = c("character"));
dfplusZ$V2=as.numeric(gsub(" ","",dfplusZ$V2));
dfplusZ=dfplusZ[order(as.numeric(dfplusZ$V1)),]

dfplusZi=read.csv("/home/john/pari/ZL32plus_EP_res_p1_0_m750_p750_2upwards_spacing_p01_imag.csv",header=FALSE,colClasses = c("character"));
dfplusZi$V2=as.numeric(gsub(" ","",dfplusZi$V2));
dfplusZi=dfplusZi[order(as.numeric(dfplusZi$V1)),]

dfreal=dfplusZ;dfimag=dfplusZi

min_val=min(as.numeric(dfreal$V1));max_val=max(as.numeric(dfreal$V1))
dfimag=dfimag[(dfimag$V1 %in% dfreal$V1),]


fft_plusZ = stats::fft(dfreal$V2+1i*dfimag$V2)

dfreal_plus=dfreal
dfimag_plus=dfimag

lenf2=length(fft_plusZ)
delta_fft2=max(as.numeric(substr(dfreal$V1,1,12)))-min(as.numeric(substr(dfreal$V1,1,12)))
n=lenf2

#second component of riemann-siegel formula based on first quiescent region
#EP(1-(sigma+i*t))*chi(sigma+i*t)*exp(i*theta)
#using 0 extra integers in prodeuler pari-gp function

dfminusZ=read.csv("/home/john/pari/ZL32minus_EP_res_p1_0_m750_p750_2upwards_spacing_p01_real.csv",header=FALSE,colClasses = c("character"));
dfminusZ$V2=as.numeric(gsub(" ","",dfminusZ$V2));
dfminusZ=dfminusZ[order(as.numeric(dfminusZ$V1)),]

dfminusZi=read.csv("/home/john/pari/ZL32minus_EP_res_p1_0_m750_p750_2upwards_spacing_p01_imag.csv",header=FALSE,colClasses = c("character"));
dfminusZi$V2=as.numeric(gsub(" ","",dfminusZi$V2));
dfminusZi=dfminusZi[order(as.numeric(dfminusZi$V1)),]

dfreal=dfminusZ;dfimag=dfminusZi

min_val=min(as.numeric(dfreal$V1));max_val=max(as.numeric(dfreal$V1))
dfimag=dfimag[dfimag$V1 %in% dfreal$V1,]

fft_minusZ = stats::fft(dfreal$V2+1i*dfimag$V2)

dfreal_minus=dfreal
dfimag_minus=dfimag

lenf=dim(dfreal)[1]

n=dim(dfreal)[1]

min_freq=min(as.numeric(substr(dfreal$V1,1,12)))
max_freq=max(as.numeric(substr(dfreal$V1,1,12)))
delta_fft=max(as.numeric(substr(dfreal$V1,1,12)))-min(as.numeric(substr(dfreal$V1,1,12)))


#mix of plus and minus components formula when sigma != 0.5
#for spectral filtering of first quiescent region based Euler Product

fft_hybrid=c(1/2*(fft_plusZ[1]+fft_minusZ[1]),(fft_plusZ)[2:(ceiling(n/2)+0)],1/2*(fft_plusZ[ceiling(n/2)+1]+fft_minusZ[ceiling(n/2)+1]),fft_minusZ[(ceiling(n/2)+2):n])
inv_hybrid=fft(fft_hybrid,inverse=TRUE)

yspan=range(Re(inv_hybrid)/n,Im(inv_hybrid)/n)
plot(as.numeric(substr(dfreal$V1,1,22)),Re(inv_hybrid)/n,typ="l",
     ylab="Z component",ylim=c(-6,6),xlab="t",main="Riemann Siegel Z function analogue (using spectral filtered Euler Product) of \n L32 function using max(2,floor(1.25*sqrt(t/2/pi*3))) in EP",xlim=c(-40,40)+0,col="black",cex.main=0.8);grid(col="gray")
lines(as.numeric(substr(dfimag$V1,1,22)),Im(inv_hybrid)/n,col="blue")
lines(as.numeric(substr(dfZ$V1,1,22)),Re(dfZ$V2),col="magenta",lty=2)
lines(as.numeric(substr(dfZ$V1,1,22)),Re(dfZi$V2),col="cyan",lty=2)

plot(as.numeric(substr(dfreal$V1,1,22)),Re(inv_hybrid)/n-Re(dfZ$V2),typ="l",xlab="t",ylab="Error",main="Error in real(Z) component (using spectral filtered Euler Product approximation) of \n L32 function using max(2,floor(1.25*sqrt(t/2/pi*3))) in EP",col="gray",cex.main=0.8);grid(col="gray2")

#Riemann-Siegel Z function of truncated Euler product at first quiescent region
#first component of riemann-siegel formula based on first quiescent region
#EP(sigma+i*t)*exp(i*theta)
#using 0 extra integers in prodeuler pari-gp function

dfplusZ=read.csv("/home/john/pari/ZL32plus_EP_res_p1_0_m750_p750_3upwards_spacing_p01_real.csv",header=FALSE,colClasses = c("character"));
dfplusZ$V2=as.numeric(gsub(" ","",dfplusZ$V2));
dfplusZ=dfplusZ[order(as.numeric(dfplusZ$V1)),]

dfplusZi=read.csv("/home/john/pari/ZL32plus_EP_res_p1_0_m750_p750_3upwards_spacing_p01_imag.csv",header=FALSE,colClasses = c("character"));
dfplusZi$V2=as.numeric(gsub(" ","",dfplusZi$V2));
dfplusZi=dfplusZi[order(as.numeric(dfplusZi$V1)),]

dfreal=dfplusZ;dfimag=dfplusZi

min_val=min(as.numeric(dfreal$V1));max_val=max(as.numeric(dfreal$V1))
dfimag=dfimag[(dfimag$V1 %in% dfreal$V1),]


fft_plusZ = stats::fft(dfreal$V2+1i*dfimag$V2)

dfreal_plus=dfreal
dfimag_plus=dfimag

lenf2=length(fft_plusZ)
delta_fft2=max(as.numeric(substr(dfreal$V1,1,12)))-min(as.numeric(substr(dfreal$V1,1,12)))
n=lenf2

#second component of riemann-siegel formula based on first quiescent region
#EP(1-(sigma+i*t))*chi(sigma+i*t)*exp(i*theta)
#using 0 extra integers in prodeuler pari-gp function

dfminusZ=read.csv("/home/john/pari/ZL32minus_EP_res_p1_0_m750_p750_3upwards_spacing_p01_real.csv",header=FALSE,colClasses = c("character"));
dfminusZ$V2=as.numeric(gsub(" ","",dfminusZ$V2));
dfminusZ=dfminusZ[order(as.numeric(dfminusZ$V1)),]

dfminusZi=read.csv("/home/john/pari/ZL32minus_EP_res_p1_0_m750_p750_3upwards_spacing_p01_imag.csv",header=FALSE,colClasses = c("character"));
dfminusZi$V2=as.numeric(gsub(" ","",dfminusZi$V2));
dfminusZi=dfminusZi[order(as.numeric(dfminusZi$V1)),]

dfreal=dfminusZ;dfimag=dfminusZi

min_val=min(as.numeric(dfreal$V1));max_val=max(as.numeric(dfreal$V1))
dfimag=dfimag[dfimag$V1 %in% dfreal$V1,]

fft_minusZ = stats::fft(dfreal$V2+1i*dfimag$V2)

dfreal_minus=dfreal
dfimag_minus=dfimag

lenf=dim(dfreal)[1]

n=dim(dfreal)[1]

min_freq=min(as.numeric(substr(dfreal$V1,1,12)))
max_freq=max(as.numeric(substr(dfreal$V1,1,12)))
delta_fft=max(as.numeric(substr(dfreal$V1,1,12)))-min(as.numeric(substr(dfreal$V1,1,12)))


#mix of plus and minus components formula when sigma != 0.5
#for spectral filtering of first quiescent region based Euler Product

fft_hybrid=c(1/2*(fft_plusZ[1]+fft_minusZ[1]),(fft_plusZ)[2:(ceiling(n/2)+0)],1/2*(fft_plusZ[ceiling(n/2)+1]+fft_minusZ[ceiling(n/2)+1]),fft_minusZ[(ceiling(n/2)+2):n])
inv_hybrid=fft(fft_hybrid,inverse=TRUE)

yspan=range(Re(inv_hybrid)/n,Im(inv_hybrid)/n)
plot(as.numeric(substr(dfreal$V1,1,22)),Re(inv_hybrid)/n,typ="l",
     ylab="Z component",ylim=c(-6,6),xlab="t",main="Riemann Siegel Z function analogue (using spectral filtered Euler Product) of \n L32 function using max(3,floor(1.25*sqrt(t/2/pi*3))) in EP",xlim=c(-40,40)+0,col="black",cex.main=0.8);grid(col="gray")
lines(as.numeric(substr(dfimag$V1,1,22)),Im(inv_hybrid)/n,col="blue")
lines(as.numeric(substr(dfZ$V1,1,22)),Re(dfZ$V2),col="magenta",lty=2)
lines(as.numeric(substr(dfZ$V1,1,22)),Re(dfZi$V2),col="cyan",lty=2)

plot(as.numeric(substr(dfreal$V1,1,22)),Re(inv_hybrid)/n-Re(dfZ$V2),typ="l",xlab="t",ylab="Error",main="Error in real(Z) component (using spectral filtered Euler Product approximation) of \n L32 function using max(3,floor(1.25*sqrt(t/2/pi*3))) in EP",col="gray",cex.main=0.8);grid(col="gray2")


#Riemann-Siegel Z function of truncated Euler product at first quiescent region
#first component of riemann-siegel formula based on first quiescent region
#EP(sigma+i*t)*exp(i*theta)
#using 0 extra integers in prodeuler pari-gp function

dfplusZ=read.csv("/home/john/pari/ZL32plus_EP_res_p1_0_m750_p750_5upwards_spacing_p01_real.csv",header=FALSE,colClasses = c("character"));
dfplusZ$V2=as.numeric(gsub(" ","",dfplusZ$V2));
dfplusZ=dfplusZ[order(as.numeric(dfplusZ$V1)),]

dfplusZi=read.csv("/home/john/pari/ZL32plus_EP_res_p1_0_m750_p750_5upwards_spacing_p01_imag.csv",header=FALSE,colClasses = c("character"));
dfplusZi$V2=as.numeric(gsub(" ","",dfplusZi$V2));
dfplusZi=dfplusZi[order(as.numeric(dfplusZi$V1)),]

dfreal=dfplusZ;dfimag=dfplusZi

min_val=min(as.numeric(dfreal$V1));max_val=max(as.numeric(dfreal$V1))
dfimag=dfimag[(dfimag$V1 %in% dfreal$V1),]


fft_plusZ = stats::fft(dfreal$V2+1i*dfimag$V2)

dfreal_plus=dfreal
dfimag_plus=dfimag

lenf2=length(fft_plusZ)
delta_fft2=max(as.numeric(substr(dfreal$V1,1,12)))-min(as.numeric(substr(dfreal$V1,1,12)))
n=lenf2

#second component of riemann-siegel formula based on first quiescent region
#EP(1-(sigma+i*t))*chi(sigma+i*t)*exp(i*theta)
#using 0 extra integers in prodeuler pari-gp function

dfminusZ=read.csv("/home/john/pari/ZL32minus_EP_res_p1_0_m750_p750_5upwards_spacing_p01_real.csv",header=FALSE,colClasses = c("character"));
dfminusZ$V2=as.numeric(gsub(" ","",dfminusZ$V2));
dfminusZ=dfminusZ[order(as.numeric(dfminusZ$V1)),]

dfminusZi=read.csv("/home/john/pari/ZL32minus_EP_res_p1_0_m750_p750_5upwards_spacing_p01_imag.csv",header=FALSE,colClasses = c("character"));
dfminusZi$V2=as.numeric(gsub(" ","",dfminusZi$V2));
dfminusZi=dfminusZi[order(as.numeric(dfminusZi$V1)),]

dfreal=dfminusZ;dfimag=dfminusZi

min_val=min(as.numeric(dfreal$V1));max_val=max(as.numeric(dfreal$V1))
dfimag=dfimag[dfimag$V1 %in% dfreal$V1,]

fft_minusZ = stats::fft(dfreal$V2+1i*dfimag$V2)

dfreal_minus=dfreal
dfimag_minus=dfimag

lenf=dim(dfreal)[1]

n=dim(dfreal)[1]

min_freq=min(as.numeric(substr(dfreal$V1,1,12)))
max_freq=max(as.numeric(substr(dfreal$V1,1,12)))
delta_fft=max(as.numeric(substr(dfreal$V1,1,12)))-min(as.numeric(substr(dfreal$V1,1,12)))


#mix of plus and minus components formula when sigma != 0.5
#for spectral filtering of first quiescent region based Euler Product

fft_hybrid=c(1/2*(fft_plusZ[1]+fft_minusZ[1]),(fft_plusZ)[2:(ceiling(n/2)+0)],1/2*(fft_plusZ[ceiling(n/2)+1]+fft_minusZ[ceiling(n/2)+1]),fft_minusZ[(ceiling(n/2)+2):n])
inv_hybrid=fft(fft_hybrid,inverse=TRUE)

yspan=range(Re(inv_hybrid)/n,Im(inv_hybrid)/n)
plot(as.numeric(substr(dfreal$V1,1,22)),Re(inv_hybrid)/n,typ="l",
     ylab="Z component",ylim=c(-6,6),xlab="t",main="Riemann Siegel Z function analogue (using spectral filtered Euler Product) of \n L32 function using max(5,floor(1.25*sqrt(t/2/pi*3))) in EP",xlim=c(-40,40)+0,col="black",cex.main=0.8);grid(col="gray")
lines(as.numeric(substr(dfimag$V1,1,22)),Im(inv_hybrid)/n,col="blue")
lines(as.numeric(substr(dfZ$V1,1,22)),Re(dfZ$V2),col="magenta",lty=2)
lines(as.numeric(substr(dfZ$V1,1,22)),Re(dfZi$V2),col="cyan",lty=2)

plot(as.numeric(substr(dfreal$V1,1,22)),Re(inv_hybrid)/n-Re(dfZ$V2),typ="l",xlab="t",ylab="Error",main="Error in real(Z) component (using spectral filtered Euler Product approximation) of \n L32 function using max(5,floor(1.25*sqrt(t/2/pi*3))) in EP",col="gray",cex.main=0.8);grid(col="gray2")
lines(rep((7/1.25)^2*2*pi/3,2),c(-2.65,-1.95),lty=2,col="blue")
lines(rep((11/1.25)^2*2*pi/3,2),c(-2.65,-1.95),lty=2,col="blue")
lines(rep((13/1.25)^2*2*pi/3,2),c(-2.65,-1.95),lty=2,col="blue")
lines(rep((17/1.25)^2*2*pi/3,2),c(-2.65,-1.95),lty=2,col="blue")
lines(rep((19/1.25)^2*2*pi/3,2),c(-2.65,-1.95),lty=2,col="blue")
lines(rep((23/1.25)^2*2*pi/3,2),c(-2.65,-1.95),lty=2,col="blue")
lines(-rep((7/1.25)^2*2*pi/3,2),c(-2.65,-1.95),lty=2,col="blue")
lines(-rep((11/1.25)^2*2*pi/3,2),c(-2.65,-1.95),lty=2,col="blue")
lines(-rep((13/1.25)^2*2*pi/3,2),c(-2.65,-1.95),lty=2,col="blue")
lines(-rep((17/1.25)^2*2*pi/3,2),c(-2.65,-1.95),lty=2,col="blue")
lines(-rep((19/1.25)^2*2*pi/3,2),c(-2.65,-1.95),lty=2,col="blue")
lines(-rep((23/1.25)^2*2*pi/3,2),c(-2.65,-1.95),lty=2,col="blue")
text(x=c(-1,1)*(7/1.25)^2*2*pi/3,y=-3.2,"7")
text(x=c(-1,1)*(11/1.25)^2*2*pi/3,y=-3.2,"11")
text(x=c(-1,1)*(13/1.25)^2*2*pi/3,y=-3.2,"13")
text(x=c(-1,1)*(17/1.25)^2*2*pi/3,y=-3.2,"17")
text(x=c(-1,1)*(19/1.25)^2*2*pi/3,y=-3.2,"19")
text(x=c(-1,1)*(23/1.25)^2*2*pi/3,y=-3.2,"23")
text(x=50,y=-4,"t value when next prime is included in EP")

#Riemann-Siegel Z function of truncated Euler product at first quiescent region
#first component of riemann-siegel formula based on first quiescent region
#EP(sigma+i*t)*exp(i*theta)
#using 0 extra integers in prodeuler pari-gp function

dfplusZ=read.csv("/home/john/pari/ZL32plus_EP_res_p1_0_m750_p750_23upwards_spacing_p01_real.csv",header=FALSE,colClasses = c("character"));
dfplusZ$V2=as.numeric(gsub(" ","",dfplusZ$V2));
dfplusZ=dfplusZ[order(as.numeric(dfplusZ$V1)),]

dfplusZi=read.csv("/home/john/pari/ZL32plus_EP_res_p1_0_m750_p750_23upwards_spacing_p01_imag.csv",header=FALSE,colClasses = c("character"));
dfplusZi$V2=as.numeric(gsub(" ","",dfplusZi$V2));
dfplusZi=dfplusZi[order(as.numeric(dfplusZi$V1)),]

dfreal=dfplusZ;dfimag=dfplusZi

min_val=min(as.numeric(dfreal$V1));max_val=max(as.numeric(dfreal$V1))
dfimag=dfimag[(dfimag$V1 %in% dfreal$V1),]


fft_plusZ = stats::fft(dfreal$V2+1i*dfimag$V2)

dfreal_plus=dfreal
dfimag_plus=dfimag

lenf2=length(fft_plusZ)
delta_fft2=max(as.numeric(substr(dfreal$V1,1,12)))-min(as.numeric(substr(dfreal$V1,1,12)))
n=lenf2

#second component of riemann-siegel formula based on first quiescent region
#EP(1-(sigma+i*t))*chi(sigma+i*t)*exp(i*theta)
#using 0 extra integers in prodeuler pari-gp function

dfminusZ=read.csv("/home/john/pari/ZL32minus_EP_res_p1_0_m750_p750_23upwards_spacing_p01_real.csv",header=FALSE,colClasses = c("character"));
dfminusZ$V2=as.numeric(gsub(" ","",dfminusZ$V2));
dfminusZ=dfminusZ[order(as.numeric(dfminusZ$V1)),]

dfminusZi=read.csv("/home/john/pari/ZL32minus_EP_res_p1_0_m750_p750_23upwards_spacing_p01_imag.csv",header=FALSE,colClasses = c("character"));
dfminusZi$V2=as.numeric(gsub(" ","",dfminusZi$V2));
dfminusZi=dfminusZi[order(as.numeric(dfminusZi$V1)),]

dfreal=dfminusZ;dfimag=dfminusZi

min_val=min(as.numeric(dfreal$V1));max_val=max(as.numeric(dfreal$V1))
dfimag=dfimag[dfimag$V1 %in% dfreal$V1,]

fft_minusZ = stats::fft(dfreal$V2+1i*dfimag$V2)

dfreal_minus=dfreal
dfimag_minus=dfimag

lenf=dim(dfreal)[1]

n=dim(dfreal)[1]

min_freq=min(as.numeric(substr(dfreal$V1,1,12)))
max_freq=max(as.numeric(substr(dfreal$V1,1,12)))
delta_fft=max(as.numeric(substr(dfreal$V1,1,12)))-min(as.numeric(substr(dfreal$V1,1,12)))


#mix of plus and minus components formula when sigma != 0.5
#for spectral filtering of first quiescent region based Euler Product

fft_hybrid=c(1/2*(fft_plusZ[1]+fft_minusZ[1]),(fft_plusZ)[2:(ceiling(n/2)+0)],1/2*(fft_plusZ[ceiling(n/2)+1]+fft_minusZ[ceiling(n/2)+1]),fft_minusZ[(ceiling(n/2)+2):n])
inv_hybrid=fft(fft_hybrid,inverse=TRUE)

yspan=range(Re(inv_hybrid)/n,Im(inv_hybrid)/n)
plot(as.numeric(substr(dfreal$V1,1,22)),Re(inv_hybrid)/n,typ="l",
     ylab="Z component",ylim=c(-6,6),xlab="t",main="Riemann Siegel Z function analogue (using spectral filtered Euler Product) of \n L32 function using max(23,floor(1.25*sqrt(t/2/pi*3))) in EP",xlim=c(-40,40)+0,col="black",cex.main=0.8);grid(col="gray")
lines(as.numeric(substr(dfimag$V1,1,22)),Im(inv_hybrid)/n,col="blue")
lines(as.numeric(substr(dfZ$V1,1,22)),Re(dfZ$V2),col="magenta",lty=2)
lines(as.numeric(substr(dfZ$V1,1,22)),Re(dfZi$V2),col="cyan",lty=2)


plot(as.numeric(substr(dfreal$V1,1,22)),Re(inv_hybrid)/n-Re(dfZ$V2),typ="l",xlab="t",ylab="Error",main="Error in real(Z) component (using spectral filtered Euler Product approximation) of \n L32 function using max(23,floor(1.25*sqrt(t/2/pi*3))) in EP",col="gray",cex.main=0.8);grid(col="gray")


```

\clearpage 

\newpage

## Truncated Euler Product approximation of the Riemann-Siegel Z function analogue of the L-function 2-13-1.1-c3-0-2 across the critical strip $s=2+I\cdot t$ using spectral filtering based fourier analyses

The second degree L function, 2-13-1.1-c3-0-2  [7] associated with the Modular form of Newform orbit 13.4.a.a (LMFDB label) under the arithmetic version of the L-function is written in dirichlet series  [7] form (convergent for $\sigma > 2.5$) as

\begin{equation}
L_{13.4.a.a}(s) = \sum_{k=1}^{\infty}\left(\frac{\chi_{13.4.a.a}(k)}{k^s}\right)
\end{equation}

where the dirichlet characters $\chi_{13.4.a.a}(k)$  satisfy the q-expansion
\begin{align}
f(q) &= \sum_{k\ge1} \chi_{13.4.a.a}(k)q^k \\
&= q-5q^2-7q^3+17q^4-7q^5+35q^6-13q^7-45q^8+22q^9+35q^{10}+... 
\end{align}

The functional equation for the the  2-13-1.1-c3-0-2 L-function is given by

\begin{equation}
L_{13.4.a.a}(s) = -\left[13^{2-s}(2\pi)^{2(s-2)}\frac{\Gamma(4-s)}{\Gamma(s)}\right]\cdot L_{13.4.a.a}(4-s) 
\end{equation}

The (normalised) extended Riemann Siegel Theta function for the 2-13-1.1-c3-0-2 L-function is given by

\begin{align}
\theta_{normextL13.4.a.a}(s) &= -\frac{1}{2}imag\left[\log\left(log(13)\cdot (2-s)+log(2\pi)\cdot (2(s-2))+lngamma(4-s)-lngamma(s)\right)\right] 
\end{align}

The 2-13-1.1-c3-0-2 L-function is a degree 2 L-function (d=2) with weight 4 and its conductor value is 13  [7]. Hence the first quiescent region of the dirichlet series of $L_{13.4.a.a}(s)$ is given by

\begin{equation}
N_1 = \left\lfloor \sqrt{\left(\frac{t}{2\pi}\right)^2\cdot 13} \right\rfloor = \left\lfloor \left(\frac{t}{2\pi}\right)\cdot \sqrt{13} \right\rfloor
\end{equation}

The function of interest to be approximated by partial Euler Products is the extended Riemann-Siegel Z function analogue of the 2-13-1.1-c3-0-2 L-function across the complex plane.

\begin{equation}
Z_{extL13.4.a.a}(s) = e^{I\theta_{normextL13.4.a.a}(t)}L_{13.4.a.a}(s)
\end{equation}

and the zeroth order Riemann-Siegel formula for the Riemann-Siegel Z function analogue of the 2-13-1.1-c3-0-2 L-function using partial Euler products is used as the basis of the approximation

\begin{align}
Z_{extL13.4.a.a}(s)_{EP} &\approx EP_{RS1,L_{13.4.a.a}}(s,\beta=1.25) \nonumber \\ &+ EP_{RS2,L_{13.4.a.a}}(s,\beta=1.25) + ... \qquad t \rightarrow \infty
\end{align}

using (i) equations (8), (9) and the known Euler factors  [7] of the 2-13-1.1-c3-0-2 L-function and (ii) $\beta=1.25$ is a small cushion factor in the truncation length of the included primes that is empirically observed to improve the quality of the fourier transform components of the finite Euler product arising nearby $N_1$ [2,3].

For the Riemann-Siegel Z function analogue the fourier transform components arising nearby $N_1$ are the fourier transform components namely surrounding (and including) the DC (zero) angular frequency.

Figures 7, 10 and 12 respectively for the following intervals around the real axis 

(i) $s=(2-I\cdot 750,0.5+I\cdot 750)$, 

(ii) $s=(2.3-I\cdot 750,0.9+I\cdot 750)$ and 

(iii) $s=(1.7-I\cdot 750,0.1+I\cdot 750)$ 

display the individual fourier transforms of the spectra of the two components of the zeroth order Riemann-Siegel formula approximation of the Riemann-Siegel Z function using partial Euler Products truncated at the first quiescent region as defined in equation (16). Shown in the

(lefthand panel top row); $EP_{RS1,L_{13.4.a.a}}(s,\beta=1.25)$

(lefthand panel middle row); $Z_{L_{13.4.a.a}}(s)$ - true Riemann-Siegel Z function

(lefthand panel bottom row); $EP_{RS2,L_{13.4.a.a}}(s,\beta=1.25)$

The long tails in the top and bottom rows of the lefthand panel fourier spectra arise from high frequencies generated by the finite Euler product that do not exist in finite Dirichlet Series of the same truncation length.

On the top and bottom rows of the righthand panels are spectrally filtered fourier transforms where only the low frequency components are retained from each zeroth order Riemann-Siegel formula term and in the middle row are spliced together following for figures 10 and 12 using the first 3 steps of the fourier analysis procedure described earlier in this paper and for figure 7 using the conjugate symmetry reflection procedure described in [3] (which is a simpler method available to use on the critical line). This spectral filtering and splicing provides a useful improvement in approximating the fourier transform of the true Riemann-Siegel Z function.  

\begin{enumerate}
\item To produce figures 7, 10 and 12, a discrete spectra of ~ n=150,000 was collected and stored for each interval using a spacing of 0.01. 
\item the fast fourier transform (fft) output vector is wrapped around so that the informative non-zero fft components appear next to the DC fourier component axis as positive and negative frequency components.
\item the x-axis is scaled in units of angular frequency (radians per second).
\end{enumerate}

As indicated by the red vertical lines there are broad spectral features which can be successfully captured by the assignment of the pair of bounds $\pm\frac{1}{2}(\log((UB/\pi/2)^2\cdot 13),\log((LB/\pi/2)^2\cdot 13))$, $\pm\frac{1}{2}(\log((UB/\pi/2)^2\cdot 13/2^2),\log((LB/\pi/2)^2\cdot 13/2^2))$ where UB=750,LB=-750 corresponding to the range of t values collected in the spectrum for figures 7, 10 and 12. 

Figures (8, 9), 11, 13 pair with figures 7, 10 and 12 respectively in illustrating in the lefthand panels, the performance of the averaged inverse fourier transform for the central regions compared to the real (imaginary) parts of the true Riemann-Siegel Z function shown in magenta (cyan) at the fourier grid spacing 0.01. 

That is, in the lefthand panels of figure 8 the following interval 

(i) $s=(2-I\cdot 40,0.5+I\cdot 40)$

is displayed for 3 different values of the minimum prime in partial Euler product calculation $P_{min}=\left\lfloor 1.25\cdot \max\left(\{1,2,3\},\sqrt{(\frac{t}{2\pi})^d\cdot N_C}\right)\right\rfloor$ with each row (top to bottom) respectively belonging to the minimum prime value \{1,2,3\} which is active when t=0.

In the lefthand panels of figure 9 the same interval 

(i) $s=(2-I\cdot 40,0.5+I\cdot 40)$

is displayed for 3 different values of the minimum prime in partial Euler product calculation $P_{min}=\left\lfloor 1.25\cdot \max\left(\{50, 430, 537\},\sqrt{(\frac{t}{2\pi})^d\cdot N_C}\right)\right\rfloor$ with each row (top to bottom) respectively belonging to the minimum prime value \{50, 430, 537\} which is active when t=0. 

In the lefthand panels of figures 11 and 13 the following interval is displayed for four different values of the minimum prime in partial Euler product calculation $P_{min}=\left\lfloor 1.25\cdot \max\left(\{1,2,50,537\},\sqrt{(\frac{t}{2\pi})^d\cdot N_C}\right)\right\rfloor$ with each row (top to bottom) respectively belonging to the minimum prime value \{1,2,50,537\} which is active when t=0.

(ii) $s=(2.3-I\cdot 40,0.9+I\cdot 40)$ and 

(iii) $s=(1.7-I\cdot 40,0.1+I\cdot 40)$ 

following the fourth step of the fourier analysis procedure described earlier in this paper. When $P_{min}=1$, the partial Euler Product returns the value unity.   

In the righthand panels of figures 8, 9, 11 and 13, the approximation error (real(spectrally filtered, spliced inverse fourier transform based approximation)-real(Z)) is displayed for the entire span of the input spectra

(i) $s=(2-I\cdot 750,0.5+I\cdot 750)$ 

(ii) $s=(2.3-I\cdot 750,0.9+I\cdot 750)$ and 

(iii) $s=(1.7-I\cdot 750,0.1+I\cdot 750)$ 

and there are clear error peaks that can be associated with discontinuous changes in $P_{min}$. The errors at each end $\pm750$ occur due to the rectangular window used for the input spectra. 

It can be seen from figures 8, 9, 11 and 12 

(i) in the lefthand panels that there a lot of visual overlap of the grid of true Riemann-Siegel Z function values with the partial Euler Product based approximation including t=0 except for regions with discontinuities in the real (gray) or blue (imaginary) waveforms of the approximation. The presence of the discontinuites reduces (in the lower rows) as $P_{min}$ is increased. 

(ii) in the righthand panels the magnitude of the errors in the real part of the approximation with respect to the true function values are shown and the peaks in approximation errors are observed to be removed as $P_{min}$ is increased. 

(iii) In the bottom row of figures 9, 11 and 13 with $P_{min}=537$ the approximation has a smooth performance with low errors across the entire $\pm750$ span of the input spectra except for the effect of the rectangular window of the input spectra. The value $P_{min}=537$ corresponds to the maximum prime required in the zeroth order Riemann-Siegel formula for the maximum |t| value of the input spectra $537=\left\lfloor 1.25\cdot \sqrt{(\frac{750}{2\pi})^2\cdot 13}\right\rfloor$. 


### Numerical performance issues with the partial Euler Product approximation

For the 2-13-1.1-c3-0-2 L-function, when fourier analysis for the interval $s=(2.5-I\cdot 750,0.5+I\cdot 750)$ was attempted the magnitude of the peaks in the input spectra near t=0, of one of the Riemann-Siegel formula using a minimum prime set to 537 exceeded $2^{10}$. Such large peaks prevented the R language based fourier transform code to successfully conduct fourier analysis. Hence the lower value of $\sigma=2.3$ (rather than 2.5) was used in the presented analysis where the largest peak had a magnitude of only 300.

\clearpage


```{r Zfn13p4aaModularFormLfunction_fouriertransform_0_pm750, echo=FALSE, fig.cap="A comparison of the fourier transforms of the Riemann-Siegel Z function analogue of the L-function 2-13-1.1-c3-0-2 (LMFDB label) and partial Euler Product (using truncation at $1.25\\cdot \\sqrt{((\\frac{750}{2\\pi})^2\\cdot 13}$) in the complex plane at $\\sigma=2$ for the interval t=(-750,750) about the real axis. On the critical line, to help use the partial Euler Product as an approximation of the Riemann-Siegel Z function phase conjugate reflection of the (accurate part of) partial Euler Product fourier transform about angular frequency = zero as shown in green is a strong zeroth order improvement. The middle row displays the true Riemann-Siegel Z function fourier transform behaviour.", out.width = c("49%","49%"), fig.show = "hold",  fig.height=5, warning=FALSE, cache=TRUE}


# Riemann-Siegel Z function of L32 function on critical line
# values recorded every .01 spacing in interval [-750,+750]

dfZ=read.csv("/home/john/pari/Z13p4aa_res_2p_0_m750_p750_spacing_p01_real.csv",header=FALSE,colClasses = c("character"));
dfZ$V2=as.numeric(gsub(" ","",dfZ$V2));
dfZ=dfZ[order(as.numeric(dfZ$V1)),]

dfZi=read.csv("/home/john/pari/Z13p4aa_res_2p_0_m750_p750_spacing_p01_imag.csv",header=FALSE,colClasses = c("character"));
dfZi$V2=as.numeric(gsub(" ","",dfZi$V2));
dfZi=dfZi[order(as.numeric(dfZi$V1)),]

fft_zeta_Zfn =  stats::fft(dfZ$V2+1i*dfZi$V2)


#first component of riemann-siegel formula based on first quiescent region
#EP(sigma+i*t)*exp(i*theta)
#using minimum 23 primes in prodeuler pari-gp function
 
 dfplusZ=read.csv("/home/john/pari/Zplus13p4aa_EP_res_2p_0_m750_p750_537upwards_spacing_p01_real.csv",header=FALSE,colClasses = c("character"));
 dfplusZ$V2=as.numeric(gsub(" ","",dfplusZ$V2));
 dfplusZ=dfplusZ[order(as.numeric(dfplusZ$V1)),]
 
 dfplusZi=read.csv("/home/john/pari/Zplus13p4aa_EP_res_2p_0_m750_p750_537upwards_spacing_p01_imag.csv",header=FALSE,colClasses = c("character"));
 dfplusZi$V2=as.numeric(gsub(" ","",dfplusZi$V2));
 dfplusZi=dfplusZi[order(as.numeric(dfplusZi$V1)),]
 
 dfreal=dfplusZ;dfimag=dfplusZi
 
 min_val=min(as.numeric(dfreal$V1));max_val=max(as.numeric(dfreal$V1))
 dfimag=dfimag[(dfimag$V1 %in% dfreal$V1),]
 
 
 fft_plusZ = stats::fft(dfreal$V2+1i*dfimag$V2)
 
 dfreal_plus=dfreal
 dfimag_plus=dfimag
 
 lenf2=length(fft_plusZ)
 delta_fft2=max(as.numeric(substr(dfreal$V1,1,12)))-min(as.numeric(substr(dfreal$V1,1,12)))
 n=lenf2
 
 #second component of riemann-siegel formula based on first quiescent region
 #EP(1-(sigma+i*t))*chi(sigma+i*t)*exp(i*theta)
 #using minimum 23 primes in prodeuler pari-gp function
 
 dfminusZ=read.csv("/home/john/pari/Zminus13p4aa_EP_res_2p_0_m750_p750_537upwards_spacing_p01_real.csv",header=FALSE,colClasses = c("character"));
 dfminusZ$V2=as.numeric(gsub(" ","",dfminusZ$V2));
 dfminusZ=dfminusZ[order(as.numeric(dfminusZ$V1)),]
 
 dfminusZi=read.csv("/home/john/pari/Zminus13p4aa_EP_res_2p_0_m750_p750_537upwards_spacing_p01_imag.csv",header=FALSE,colClasses = c("character"));
 dfminusZi$V2=as.numeric(gsub(" ","",dfminusZi$V2));
 dfminusZi=dfminusZi[order(as.numeric(dfminusZi$V1)),]
 
 dfreal=dfminusZ;dfimag=dfminusZi
 
 min_val=min(as.numeric(dfreal$V1));max_val=max(as.numeric(dfreal$V1))
 dfimag=dfimag[dfimag$V1 %in% dfreal$V1,]
 
 fft_minusZ = stats::fft(dfreal$V2+1i*dfimag$V2)
 
 dfreal_minus=dfreal
 dfimag_minus=dfimag
 
 lenf=dim(dfreal)[1]
 
 n=dim(dfreal)[1]
 
 min_freq=min(as.numeric(substr(dfreal$V1,1,12)))
 max_freq=max(as.numeric(substr(dfreal$V1,1,12)))
 
 delta_fft=max_freq-min_freq
 mid=floor(delta_fft/2/pi*log(floor(sqrt((max_freq/2/pi/c(1))*3))))
 
 plot(c(-floor(n/2):(ceiling(n/2)-1))*2*pi/delta_fft,c(abs(fft_plusZ)[(ceiling(n/2)+1):n],abs(fft_plusZ)[1:(ceiling(n/2))]),xlim=c(-11,11),typ="l",xaxt="n",xlab="angular frequency (radians per sec)",ylab="|Amplitude|",main="fourier transform spectra of the first component of \n the partial Euler product Riemann-Siegel Z function \n using truncation at N1=sqrt((max(t)/2/pi)^2*13).")
 abline(v=seq(-20,20,l=41),h=seq(0,1e5,l=6),lty=3,col="gray")
 axis(1,at=seq(-20,20,l=41))
abline(v=-1/2*log(((max_freq)/pi/2)^2*13/c(1:2)^2)-0,col=rgb(1,0,0,0.3))
abline(v=1/2*log(((max_freq)/pi/2)^2*13/c(1:2)^2)-0,col=rgb(1,0,0,0.3))
 
 
 plot(c(-floor(n/2):-1)*2*pi/delta_fft,c(rev(abs(Conj(fft_plusZ))[2:ceiling(n/2)])),xlim=c(-11,11),typ="l",xaxt="n",xlab="angular frequency (radians per sec)",ylab="|Amplitude|",main="piecewise fourier transform \n spectra filtering of the first component positive frequencies \n and phase conjugate reflection imputation of the negative freq half.",col=3)
 lines(c(0:(ceiling(n/2)-1))*2*pi/delta_fft,c(abs(fft_plusZ)[1:(ceiling(n/2))]),col=1)
 abline(v=seq(-20,20,l=41),h=seq(0,1e5,l=6),lty=3,col="gray")
 axis(1,at=seq(-20,20,l=41))
abline(v=-1/2*log(((max_freq)/pi/2)^2*13/c(1:2)^2)-0,col=rgb(1,0,0,0.3))
abline(v=1/2*log(((max_freq)/pi/2)^2*13/c(1:2)^2)-0,col=rgb(1,0,0,0.3))


n=dim(dfZ)[1]
min_freq=min(as.numeric(dfZ$V1))
max_freq=max(as.numeric(dfZ$V1))
delta_fft=max_freq-min_freq
mid=floor(delta_fft/2/pi*log(floor(sqrt((max_freq/2/pi/c(1))*5))))

plot(c(-floor(n/2):(ceiling(n/2)-1))*2*pi/delta_fft,c(abs(fft_zeta_Zfn)[(ceiling(n/2)+1):n],abs(fft_zeta_Zfn)[1:(ceiling(n/2))]),xlim=c(-11,11),typ="l",xaxt="n",xlab="angular frequency (radians per sec)",ylab="|Amplitude|",main="fourier transform spectra of the true Riemann-Siegel Z function.",cex.main=0.9)
abline(v=seq(-20,20,l=41),h=seq(0,1e5,l=6),lty=3,col="gray")
axis(1,at=seq(-20,20,l=41))
abline(v=-1/2*log(((max_freq)/pi/2)^2*13/c(1:2)^2)-0,col=rgb(1,0,0,0.3))
abline(v=1/2*log(((max_freq)/pi/2)^2*13/c(1:2)^2)-0,col=rgb(1,0,0,0.3))

n=dim(dfZ)[1]
min_freq=min(as.numeric(dfZ$V1))
max_freq=max(as.numeric(dfZ$V1))
delta_fft=max_freq-min_freq
mid=floor(delta_fft/2/pi*log(floor(sqrt((max_freq/2/pi/c(1))*5))))

plot(c(-floor(n/2):(ceiling(n/2)-1))*2*pi/delta_fft,c(abs(fft_zeta_Zfn)[(ceiling(n/2)+1):n],abs(fft_zeta_Zfn)[1:(ceiling(n/2))]),xlim=c(-11,11),typ="l",xaxt="n",xlab="angular frequency (radians per sec)",ylab="|Amplitude|",main="fourier transform spectra of the true Riemann-Siegel Z function.",cex.main=0.9)
abline(v=seq(-20,20,l=41),h=seq(0,1e5,l=6),lty=3,col="gray")
axis(1,at=seq(-20,20,l=41))
abline(v=-1/2*log(((max_freq)/pi/2)^2*13/c(1:2)^2)-0,col=rgb(1,0,0,0.3))
abline(v=1/2*log(((max_freq)/pi/2)^2*13/c(1:2)^2)-0,col=rgb(1,0,0,0.3))


n=dim(dfminusZ)[1]
min_freq=min(as.numeric(dfminusZ$V1))
max_freq=max(as.numeric(dfminusZ$V1))
delta_fft=max_freq-min_freq
mid=floor(delta_fft/2/pi*log(floor(sqrt((max_freq/2/pi/c(1))*3))))

plot(c(-floor(n/2):(ceiling(n/2)-1))*2*pi/delta_fft,c(abs(fft_minusZ)[(ceiling(n/2)+1):n],abs(fft_minusZ)[1:(ceiling(n/2))]),xlim=c(-11,11),typ="l",xaxt="n",xlab="angular frequency (radians per sec)",ylab="|Amplitude|",main="fourier transform spectra of the second component of \n the partial Euler product Riemann-Siegel Z function \n using truncation at N1=sqrt((max(t)/2/pi)^2*13).")
abline(v=seq(-20,20,l=41),h=seq(0,1e5,l=6),lty=3,col="gray")
axis(1,at=seq(-20,20,l=41))
abline(v=-1/2*log(((max_freq)/pi/2)^2*13/c(1:2)^2)-0,col=rgb(1,0,0,0.3))
abline(v=1/2*log(((max_freq)/pi/2)^2*13/c(1:2)^2)-0,col=rgb(1,0,0,0.3))


plot(c(-floor(n/2):-1)*2*pi/delta_fft,c(abs(fft_minusZ)[(ceiling(n/2)+1):n]),xlim=c(-11,11),typ="l",xaxt="n",xlab="angular frequency (radians per sec)",ylab="|Amplitude|",main="piecewise fourier transform \n spectra filtering of the second component negative frequencies \n and phase conjugate reflection imputation of the positive freq half.",col=1)
lines(c(0:(floor(n/2)))*2*pi/delta_fft,c(abs(fft_minusZ)[1],rev(abs(fft_minusZ)[(ceiling(n/2)+1):n])),col=3)
abline(v=seq(-20,20,l=41),h=seq(0,1e5,l=6),lty=3,col="gray")
axis(1,at=seq(-20,20,l=41))
abline(v=-1/2*log(((max_freq)/pi/2)^2*13/c(1:2)^2)-0,col=rgb(1,0,0,0.3))
abline(v=1/2*log(((max_freq)/pi/2)^2*13/c(1:2)^2)-0,col=rgb(1,0,0,0.3))

```



\clearpage


```{r Zfn13p4aaModularFormLfunctionoveraninterval_anditsfouriertransform_0_pm750, echo=FALSE, fig.cap="Lefthand panel - True Z function shown in magenta (cyan) for real (imaginary) parts and spectral filtered based EP approximation shown in black (blue) for real (imaginary) parts, Right hand panel - Error in the real(Z) EP approximation. A comparison of the Riemann-Siegel Z function analogue of the L-function 2-13-1.1-c3-0-2 (LMFDB label) and spectrally filtered partial Euler Product (using truncation at $\\max (P,\\sqrt{((\\frac{t}{2\\pi})^2\\cdot 13}) $) in the complex plane at $\\sigma=2$ for the interval t=(-750,750) where $P_{min}={1,2,3}$ for rows 1-3. ", out.width = c("49%","49%"), fig.show = "hold",  fig.height=5, warning=FALSE, cache=TRUE}


# Riemann-Siegel Z function of L32 function on critical line
# values recorded every .01 spacing in interval [-750,+750]

dfZ=read.csv("/home/john/pari/Z13p4aa_res_2p_0_m750_p750_spacing_p01_real.csv",header=FALSE,colClasses = c("character"));
dfZ$V2=as.numeric(gsub(" ","",dfZ$V2));
dfZ=dfZ[order(as.numeric(dfZ$V1)),]

dfZi=read.csv("/home/john/pari/Z13p4aa_res_2p_0_m750_p750_spacing_p01_imag.csv",header=FALSE,colClasses = c("character"));
dfZi$V2=as.numeric(gsub(" ","",dfZi$V2));
dfZi=dfZi[order(as.numeric(dfZi$V1)),]


#Riemann-Siegel Z function of truncated Euler product at first quiescent region
#first component of riemann-siegel formula based on first quiescent region
#EP(sigma+i*t)*exp(i*theta)
#using 0 extra integers in prodeuler pari-gp function

dfplusZ=read.csv("/home/john/pari/Zplus13p4aa_EP_res_2p_0_m750_p750_0extra_spacing_p01_real.csv",header=FALSE,colClasses = c("character"));
dfplusZ$V2=as.numeric(gsub(" ","",dfplusZ$V2));
dfplusZ=dfplusZ[order(as.numeric(dfplusZ$V1)),]

dfplusZi=read.csv("/home/john/pari/Zplus13p4aa_EP_res_2p_0_m750_p750_0extra_spacing_p01_imag.csv",header=FALSE,colClasses = c("character"));
dfplusZi$V2=as.numeric(gsub(" ","",dfplusZi$V2));
dfplusZi=dfplusZi[order(as.numeric(dfplusZi$V1)),]

dfreal=dfplusZ;dfimag=dfplusZi

min_val=min(as.numeric(dfreal$V1));max_val=max(as.numeric(dfreal$V1))
dfimag=dfimag[(dfimag$V1 %in% dfreal$V1),]


fft_plusZ = stats::fft(dfreal$V2+1i*dfimag$V2)

dfreal_plus=dfreal
dfimag_plus=dfimag

lenf2=length(fft_plusZ)
delta_fft2=max(as.numeric(substr(dfreal$V1,1,12)))-min(as.numeric(substr(dfreal$V1,1,12)))
n=lenf2

#second component of riemann-siegel formula based on first quiescent region
#EP(1-(sigma+i*t))*chi(sigma+i*t)*exp(i*theta)
#using 0 extra integers in prodeuler pari-gp function

dfminusZ=read.csv("/home/john/pari/Zminus13p4aa_EP_res_2p_0_m750_p750_0extra_spacing_p01_real.csv",header=FALSE,colClasses = c("character"));
dfminusZ$V2=as.numeric(gsub(" ","",dfminusZ$V2));
dfminusZ=dfminusZ[order(as.numeric(dfminusZ$V1)),]

dfminusZi=read.csv("/home/john/pari/Zminus13p4aa_EP_res_2p_0_m750_p750_0extra_spacing_p01_imag.csv",header=FALSE,colClasses = c("character"));
dfminusZi$V2=as.numeric(gsub(" ","",dfminusZi$V2));
dfminusZi=dfminusZi[order(as.numeric(dfminusZi$V1)),]

dfreal=dfminusZ;dfimag=dfminusZi

min_val=min(as.numeric(dfreal$V1));max_val=max(as.numeric(dfreal$V1))
dfimag=dfimag[dfimag$V1 %in% dfreal$V1,]

fft_minusZ = stats::fft(dfreal$V2+1i*dfimag$V2)

dfreal_minus=dfreal
dfimag_minus=dfimag

lenf=dim(dfreal)[1]

n=dim(dfreal)[1]

min_freq=min(as.numeric(substr(dfreal$V1,1,12)))
max_freq=max(as.numeric(substr(dfreal$V1,1,12)))
delta_fft=max(as.numeric(substr(dfreal$V1,1,12)))-min(as.numeric(substr(dfreal$V1,1,12)))


#symmetric formula when sigma=0.5
#for spectral filtering of first quiescent region based Euler Product

fft_hybrid=c(Re(fft_plusZ[1]),(fft_plusZ)[2:(ceiling(n/2)+0)],Re(fft_plusZ)[ceiling(n/2)+1],Conj(rev(c((fft_plusZ)[2:floor(n/2)]))))
inv_hybrid=fft(fft_hybrid,inverse=TRUE)

yspan=range(Re(inv_hybrid)/n,Im(inv_hybrid)/n)
plot(as.numeric(substr(dfreal$V1,1,22)),Re(inv_hybrid)/n,typ="l",
     ylab="Z component",ylim=c(-11,11),xlab="t",main="Riemann Siegel Z function analogue (using spectral filtered Euler Product) of \n Modular form 13.4.a.a function using max(1,floor(1.25*sqrt((t/2/pi)^2*13))) in EP",xlim=c(-40,40)+0,col="black",cex.main=0.8);grid(col="gray")
lines(as.numeric(substr(dfimag$V1,1,22)),Im(inv_hybrid)/n,col="blue")
lines(as.numeric(substr(dfZ$V1,1,22)),Re(dfZ$V2),col="magenta",lty=2)
lines(as.numeric(substr(dfZ$V1,1,22)),Re(dfZi$V2),col="cyan",lty=2)
lines(rep((2/1.25)^1*2*pi/sqrt(13),2),c(-8,-5),lty=2,col="blue")
lines(rep((3/1.25)^1*2*pi/sqrt(13),2),c(5,8),lty=2,col="blue")
lines(-rep((2/1.25)^1*2*pi/sqrt(13),2),c(-8,-5),lty=2,col="blue")
lines(-rep((3/1.25)^1*2*pi/sqrt(13),2),c(5,8),lty=2,col="blue")
text(x=c(-1,1)*(2/1.25)^1*2*pi/sqrt(13),y=-9,"2")
text(x=c(-1,1)*(3/1.25)^1*2*pi/sqrt(13),y=9,"3")
text(x=-10,y=-11,"t value when next prime is included in EP",cex=0.7)

plot(as.numeric(substr(dfreal$V1,1,22)),Re(inv_hybrid)/n-Re(dfZ$V2),typ="l",xlab="t",ylab="Error",main="Error in real(Z) component (using spectral filtered Euler Product approximation) of \n Modular form 13.4.a.a function using max(1,floor(1.25*sqrt((t/2/pi)^2*13))) in EP",col="gray",cex.main=0.8);grid(col="gray2")

#Riemann-Siegel Z function of truncated Euler product at first quiescent region
#first component of riemann-siegel formula based on first quiescent region
#EP(sigma+i*t)*exp(i*theta)
#using 0 extra integers in prodeuler pari-gp function

dfplusZ=read.csv("/home/john/pari/Zplus13p4aa_EP_res_2p_0_m750_p750_2upwards_spacing_p01_real.csv",header=FALSE,colClasses = c("character"));
dfplusZ$V2=as.numeric(gsub(" ","",dfplusZ$V2));
dfplusZ=dfplusZ[order(as.numeric(dfplusZ$V1)),]

dfplusZi=read.csv("/home/john/pari/Zplus13p4aa_EP_res_2p_0_m750_p750_2upwards_spacing_p01_imag.csv",header=FALSE,colClasses = c("character"));
dfplusZi$V2=as.numeric(gsub(" ","",dfplusZi$V2));
dfplusZi=dfplusZi[order(as.numeric(dfplusZi$V1)),]

dfreal=dfplusZ;dfimag=dfplusZi

min_val=min(as.numeric(dfreal$V1));max_val=max(as.numeric(dfreal$V1))
dfimag=dfimag[(dfimag$V1 %in% dfreal$V1),]


fft_plusZ = stats::fft(dfreal$V2+1i*dfimag$V2)

dfreal_plus=dfreal
dfimag_plus=dfimag

lenf2=length(fft_plusZ)
delta_fft2=max(as.numeric(substr(dfreal$V1,1,12)))-min(as.numeric(substr(dfreal$V1,1,12)))
n=lenf2

#second component of riemann-siegel formula based on first quiescent region
#EP(1-(sigma+i*t))*chi(sigma+i*t)*exp(i*theta)
#using 0 extra integers in prodeuler pari-gp function

dfminusZ=read.csv("/home/john/pari/Zminus13p4aa_EP_res_2p_0_m750_p750_2upwards_spacing_p01_real.csv",header=FALSE,colClasses = c("character"));
dfminusZ$V2=as.numeric(gsub(" ","",dfminusZ$V2));
dfminusZ=dfminusZ[order(as.numeric(dfminusZ$V1)),]

dfminusZi=read.csv("/home/john/pari/Zminus13p4aa_EP_res_2p_0_m750_p750_2upwards_spacing_p01_imag.csv",header=FALSE,colClasses = c("character"));
dfminusZi$V2=as.numeric(gsub(" ","",dfminusZi$V2));
dfminusZi=dfminusZi[order(as.numeric(dfminusZi$V1)),]

dfreal=dfminusZ;dfimag=dfminusZi

min_val=min(as.numeric(dfreal$V1));max_val=max(as.numeric(dfreal$V1))
dfimag=dfimag[dfimag$V1 %in% dfreal$V1,]

fft_minusZ = stats::fft(dfreal$V2+1i*dfimag$V2)

dfreal_minus=dfreal
dfimag_minus=dfimag

lenf=dim(dfreal)[1]

n=dim(dfreal)[1]

min_freq=min(as.numeric(substr(dfreal$V1,1,12)))
max_freq=max(as.numeric(substr(dfreal$V1,1,12)))
delta_fft=max(as.numeric(substr(dfreal$V1,1,12)))-min(as.numeric(substr(dfreal$V1,1,12)))


#symmetric formula when sigma=0.5
#for spectral filtering of first quiescent region based Euler Product

fft_hybrid=c(Re(fft_plusZ[1]),(fft_plusZ)[2:(ceiling(n/2)+0)],Re(fft_plusZ)[ceiling(n/2)+1],Conj(rev(c((fft_plusZ)[2:floor(n/2)]))))
inv_hybrid=fft(fft_hybrid,inverse=TRUE)

yspan=range(Re(inv_hybrid)/n,Im(inv_hybrid)/n)
plot(as.numeric(substr(dfreal$V1,1,22)),Re(inv_hybrid)/n,typ="l",
     ylab="Z component",ylim=c(-11,11),xlab="t",main="Riemann Siegel Z function analogue (using spectral filtered Euler Product) of \n Modular form 13.4.a.a L function using max(2,floor(1.25*sqrt((t/2/pi)^2*13))) in EP",xlim=c(-40,40)+0,col="black",cex.main=0.8);grid(col="gray")
lines(as.numeric(substr(dfimag$V1,1,22)),Im(inv_hybrid)/n,col="blue")
lines(as.numeric(substr(dfZ$V1,1,22)),Re(dfZ$V2),col="magenta",lty=2)
lines(as.numeric(substr(dfZ$V1,1,22)),Re(dfZi$V2),col="cyan",lty=2)
lines(rep((3/1.25)^1*2*pi/sqrt(13),2),c(5,8),lty=2,col="blue")
lines(-rep((3/1.25)^1*2*pi/sqrt(13),2),c(5,8),lty=2,col="blue")
text(x=c(-1,1)*(3/1.25)^1*2*pi/sqrt(13),y=9,"3")
text(x=0,y=11,"t value when next prime is included in EP",cex=0.7)

plot(as.numeric(substr(dfreal$V1,1,22)),Re(inv_hybrid)/n-Re(dfZ$V2),typ="l",xlab="t",ylab="Error",main="Error in real(Z) component (using spectral filtered Euler Product approximation) of \n Modular form 13.4.a.a L function using max(2,floor(1.25*sqrt((t/2/pi)^2*13))) in EP",col="gray",cex.main=0.8);grid(col="gray2")

#Riemann-Siegel Z function of truncated Euler product at first quiescent region
#first component of riemann-siegel formula based on first quiescent region
#EP(sigma+i*t)*exp(i*theta)
#using 0 extra integers in prodeuler pari-gp function

dfplusZ=read.csv("/home/john/pari/Zplus13p4aa_EP_res_2p_0_m750_p750_3upwards_spacing_p01_real.csv",header=FALSE,colClasses = c("character"));
dfplusZ$V2=as.numeric(gsub(" ","",dfplusZ$V2));
dfplusZ=dfplusZ[order(as.numeric(dfplusZ$V1)),]

dfplusZi=read.csv("/home/john/pari/Zplus13p4aa_EP_res_2p_0_m750_p750_3upwards_spacing_p01_imag.csv",header=FALSE,colClasses = c("character"));
dfplusZi$V2=as.numeric(gsub(" ","",dfplusZi$V2));
dfplusZi=dfplusZi[order(as.numeric(dfplusZi$V1)),]

dfreal=dfplusZ;dfimag=dfplusZi

min_val=min(as.numeric(dfreal$V1));max_val=max(as.numeric(dfreal$V1))
dfimag=dfimag[(dfimag$V1 %in% dfreal$V1),]


fft_plusZ = stats::fft(dfreal$V2+1i*dfimag$V2)

dfreal_plus=dfreal
dfimag_plus=dfimag

lenf2=length(fft_plusZ)
delta_fft2=max(as.numeric(substr(dfreal$V1,1,12)))-min(as.numeric(substr(dfreal$V1,1,12)))
n=lenf2

#second component of riemann-siegel formula based on first quiescent region
#EP(1-(sigma+i*t))*chi(sigma+i*t)*exp(i*theta)
#using 0 extra integers in prodeuler pari-gp function

dfminusZ=read.csv("/home/john/pari/Zminus13p4aa_EP_res_2p_0_m750_p750_3upwards_spacing_p01_real.csv",header=FALSE,colClasses = c("character"));
dfminusZ$V2=as.numeric(gsub(" ","",dfminusZ$V2));
dfminusZ=dfminusZ[order(as.numeric(dfminusZ$V1)),]

dfminusZi=read.csv("/home/john/pari/Zminus13p4aa_EP_res_2p_0_m750_p750_3upwards_spacing_p01_imag.csv",header=FALSE,colClasses = c("character"));
dfminusZi$V2=as.numeric(gsub(" ","",dfminusZi$V2));
dfminusZi=dfminusZi[order(as.numeric(dfminusZi$V1)),]

dfreal=dfminusZ;dfimag=dfminusZi

min_val=min(as.numeric(dfreal$V1));max_val=max(as.numeric(dfreal$V1))
dfimag=dfimag[dfimag$V1 %in% dfreal$V1,]

fft_minusZ = stats::fft(dfreal$V2+1i*dfimag$V2)

dfreal_minus=dfreal
dfimag_minus=dfimag

lenf=dim(dfreal)[1]

n=dim(dfreal)[1]

min_freq=min(as.numeric(substr(dfreal$V1,1,12)))
max_freq=max(as.numeric(substr(dfreal$V1,1,12)))
delta_fft=max(as.numeric(substr(dfreal$V1,1,12)))-min(as.numeric(substr(dfreal$V1,1,12)))


#symmetric formula when sigma=0.5
#for spectral filtering of first quiescent region based Euler Product

fft_hybrid=c(Re(fft_plusZ[1]),(fft_plusZ)[2:(ceiling(n/2)+0)],Re(fft_plusZ)[ceiling(n/2)+1],Conj(rev(c((fft_plusZ)[2:floor(n/2)]))))
inv_hybrid=fft(fft_hybrid,inverse=TRUE)

yspan=range(Re(inv_hybrid)/n,Im(inv_hybrid)/n)
plot(as.numeric(substr(dfreal$V1,1,22)),Re(inv_hybrid)/n,typ="l",
     ylab="Z component",ylim=c(-5,5),xlab="t",main="Riemann Siegel Z function analogue (using spectral filtered Euler Product) of \n Modular form 13.4.a.a L function using max(3,floor(1.25*sqrt((t/2/pi)^2*13))) in EP",xlim=c(-40,40)+0,col="black",cex.main=0.8);grid(col="gray")
lines(as.numeric(substr(dfimag$V1,1,22)),Im(inv_hybrid)/n,col="blue")
lines(as.numeric(substr(dfZ$V1,1,22)),Re(dfZ$V2),col="magenta",lty=2)
lines(as.numeric(substr(dfZ$V1,1,22)),Re(dfZi$V2),col="cyan",lty=2)
lines(rep((5/1.25)^1*2*pi/sqrt(13),2),c(-3,-1.5),lty=2,col="blue")
lines(-rep((5/1.25)^1*2*pi/sqrt(13),2),c(1.5,3),lty=2,col="blue")
text(x=(5/1.25)^1*2*pi/sqrt(13),y=-3.5,"5")
text(x=-(5/1.25)^1*2*pi/sqrt(13),y=3.5,"5")
text(x=0,y=-4.5,"t value when next prime is included in EP",cex=0.7)

plot(as.numeric(substr(dfreal$V1,1,22)),Re(inv_hybrid)/n-Re(dfZ$V2),typ="l",xlab="t",ylab="Error",main="Error in real(Z) component (using spectral filtered Euler Product approximation) of \n Modular form 13.4.a.a L function using max(3,floor(1.25*sqrt((t/2/pi)^2*1))) in EP",col="gray",cex.main=0.8);grid(col="gray2")

```


```{r Zfn13p4aaModularFormLfunctionoveraninterval_anditsfouriertransform_0_pm750_pt2, echo=FALSE, fig.cap="Lefthand panel - True Z function shown in magenta (cyan) for real (imaginary) parts and spectral filtered based EP approximation shown in black (blue) for real (imaginary) parts, Right hand panel - Error in the real(Z) EP approximation. A comparison of the Riemann-Siegel Z function analogue of the L-function 2-13-1.1-c3-0-2 (LMFDB label) and spectrally filtered partial Euler Product (using truncation at $\\max (P,\\sqrt{((\\frac{t}{2\\pi})^2\\cdot 13}) $) in the complex plane at $\\sigma=2$ for the interval t=(-750,750) where $P_{min}={50,430,537}$ for rows 1-3. ", out.width = c("49%","49%"), fig.show = "hold",  fig.height=5, warning=FALSE, cache=TRUE}


#Riemann-Siegel Z function of truncated Euler product at first quiescent region
#first component of riemann-siegel formula based on first quiescent region
#EP(sigma+i*t)*exp(i*theta)
#using 0 extra integers in prodeuler pari-gp function

dfplusZ=read.csv("/home/john/pari/Zplus13p4aa_EP_res_2p_0_m750_p750_50upwards_spacing_p01_real.csv",header=FALSE,colClasses = c("character"));
dfplusZ$V2=as.numeric(gsub(" ","",dfplusZ$V2));
dfplusZ=dfplusZ[order(as.numeric(dfplusZ$V1)),]

dfplusZi=read.csv("/home/john/pari/Zplus13p4aa_EP_res_2p_0_m750_p750_50upwards_spacing_p01_imag.csv",header=FALSE,colClasses = c("character"));
dfplusZi$V2=as.numeric(gsub(" ","",dfplusZi$V2));
dfplusZi=dfplusZi[order(as.numeric(dfplusZi$V1)),]

dfreal=dfplusZ;dfimag=dfplusZi

min_val=min(as.numeric(dfreal$V1));max_val=max(as.numeric(dfreal$V1))
dfimag=dfimag[(dfimag$V1 %in% dfreal$V1),]


fft_plusZ = stats::fft(dfreal$V2+1i*dfimag$V2)

dfreal_plus=dfreal
dfimag_plus=dfimag

lenf2=length(fft_plusZ)
delta_fft2=max(as.numeric(substr(dfreal$V1,1,12)))-min(as.numeric(substr(dfreal$V1,1,12)))
n=lenf2

#second component of riemann-siegel formula based on first quiescent region
#EP(1-(sigma+i*t))*chi(sigma+i*t)*exp(i*theta)
#using 0 extra integers in prodeuler pari-gp function

dfminusZ=read.csv("/home/john/pari/Zminus13p4aa_EP_res_2p_0_m750_p750_50upwards_spacing_p01_real.csv",header=FALSE,colClasses = c("character"));
dfminusZ$V2=as.numeric(gsub(" ","",dfminusZ$V2));
dfminusZ=dfminusZ[order(as.numeric(dfminusZ$V1)),]

dfminusZi=read.csv("/home/john/pari/Zminus13p4aa_EP_res_2p_0_m750_p750_50upwards_spacing_p01_imag.csv",header=FALSE,colClasses = c("character"));
dfminusZi$V2=as.numeric(gsub(" ","",dfminusZi$V2));
dfminusZi=dfminusZi[order(as.numeric(dfminusZi$V1)),]

dfreal=dfminusZ;dfimag=dfminusZi

min_val=min(as.numeric(dfreal$V1));max_val=max(as.numeric(dfreal$V1))
dfimag=dfimag[dfimag$V1 %in% dfreal$V1,]

fft_minusZ = stats::fft(dfreal$V2+1i*dfimag$V2)

dfreal_minus=dfreal
dfimag_minus=dfimag

lenf=dim(dfreal)[1]

n=dim(dfreal)[1]

min_freq=min(as.numeric(substr(dfreal$V1,1,12)))
max_freq=max(as.numeric(substr(dfreal$V1,1,12)))
delta_fft=max(as.numeric(substr(dfreal$V1,1,12)))-min(as.numeric(substr(dfreal$V1,1,12)))


#symmetric formula when sigma=0.5
#for spectral filtering of first quiescent region based Euler Product

fft_hybrid=c(Re(fft_plusZ[1]),(fft_plusZ)[2:(ceiling(n/2)+0)],Re(fft_plusZ)[ceiling(n/2)+1],Conj(rev(c((fft_plusZ)[2:floor(n/2)]))))
inv_hybrid=fft(fft_hybrid,inverse=TRUE)

yspan=range(Re(inv_hybrid)/n,Im(inv_hybrid)/n)
plot(as.numeric(substr(dfreal$V1,1,22)),Re(inv_hybrid)/n,typ="l",
     ylab="Z component",ylim=c(-11,11),xlab="t",main="Riemann Siegel Z function analogue (using spectral filtered Euler Product) of \n Modular form 13.4.a.a function using max(50,floor(1.25*sqrt((t/2/pi)^2*13))) in EP",xlim=c(-40,40)+0,col="black",cex.main=0.8);grid(col="gray")
lines(as.numeric(substr(dfimag$V1,1,22)),Im(inv_hybrid)/n,col="blue")
lines(as.numeric(substr(dfZ$V1,1,22)),Re(dfZ$V2),col="magenta",lty=2)
lines(as.numeric(substr(dfZ$V1,1,22)),Re(dfZi$V2),col="cyan",lty=2)

plot(as.numeric(substr(dfreal$V1,1,22)),Re(inv_hybrid)/n-Re(dfZ$V2),typ="l",xlab="t",ylab="Error",main="Error in real(Z) component (using spectral filtered Euler Product approximation) of \n Modular form 13.4.a.a function using max(5,floor(1.25*sqrt((t/2/pi)^2*13))) in EP",col="gray",cex.main=0.8);grid(col="gray2")
lines(-rep((53/1.25)^1*2*pi/sqrt(13),2),c(-.4,-.15),lty=2,col="blue")
lines(rep((53/1.25)^1*2*pi/sqrt(13),2),c(.15,.4),lty=2,col="blue")
text(x=-(53/1.25)^1*2*pi/sqrt(13),y=-.5,"53")
text(x=(53/1.25)^1*2*pi/sqrt(13),y=.5,"53")
text(x=0,y=-.65,"t value when next prime is included in EP",cex=0.7)

#Riemann-Siegel Z function of truncated Euler product at first quiescent region
#first component of riemann-siegel formula based on first quiescent region
#EP(sigma+i*t)*exp(i*theta)
#using 0 extra integers in prodeuler pari-gp function

dfplusZ=read.csv("/home/john/pari/Zplus13p4aa_EP_res_2p_0_m750_p750_430upwards_spacing_p01_real.csv",header=FALSE,colClasses = c("character"));
dfplusZ$V2=as.numeric(gsub(" ","",dfplusZ$V2));
dfplusZ=dfplusZ[order(as.numeric(dfplusZ$V1)),]

dfplusZi=read.csv("/home/john/pari/Zplus13p4aa_EP_res_2p_0_m750_p750_430upwards_spacing_p01_imag.csv",header=FALSE,colClasses = c("character"));
dfplusZi$V2=as.numeric(gsub(" ","",dfplusZi$V2));
dfplusZi=dfplusZi[order(as.numeric(dfplusZi$V1)),]

dfreal=dfplusZ;dfimag=dfplusZi

min_val=min(as.numeric(dfreal$V1));max_val=max(as.numeric(dfreal$V1))
dfimag=dfimag[(dfimag$V1 %in% dfreal$V1),]


fft_plusZ = stats::fft(dfreal$V2+1i*dfimag$V2)

dfreal_plus=dfreal
dfimag_plus=dfimag

lenf2=length(fft_plusZ)
delta_fft2=max(as.numeric(substr(dfreal$V1,1,12)))-min(as.numeric(substr(dfreal$V1,1,12)))
n=lenf2

#second component of riemann-siegel formula based on first quiescent region
#EP(1-(sigma+i*t))*chi(sigma+i*t)*exp(i*theta)
#using 0 extra integers in prodeuler pari-gp function

dfminusZ=read.csv("/home/john/pari/Zminus13p4aa_EP_res_2p_0_m750_p750_430upwards_spacing_p01_real.csv",header=FALSE,colClasses = c("character"));
dfminusZ$V2=as.numeric(gsub(" ","",dfminusZ$V2));
dfminusZ=dfminusZ[order(as.numeric(dfminusZ$V1)),]

dfminusZi=read.csv("/home/john/pari/Zminus13p4aa_EP_res_2p_0_m750_p750_430upwards_spacing_p01_imag.csv",header=FALSE,colClasses = c("character"));
dfminusZi$V2=as.numeric(gsub(" ","",dfminusZi$V2));
dfminusZi=dfminusZi[order(as.numeric(dfminusZi$V1)),]

dfreal=dfminusZ;dfimag=dfminusZi

min_val=min(as.numeric(dfreal$V1));max_val=max(as.numeric(dfreal$V1))
dfimag=dfimag[dfimag$V1 %in% dfreal$V1,]

fft_minusZ = stats::fft(dfreal$V2+1i*dfimag$V2)

dfreal_minus=dfreal
dfimag_minus=dfimag

lenf=dim(dfreal)[1]

n=dim(dfreal)[1]

min_freq=min(as.numeric(substr(dfreal$V1,1,12)))
max_freq=max(as.numeric(substr(dfreal$V1,1,12)))
delta_fft=max(as.numeric(substr(dfreal$V1,1,12)))-min(as.numeric(substr(dfreal$V1,1,12)))


#symmetric formula when sigma=0.5
#for spectral filtering of first quiescent region based Euler Product

fft_hybrid=c(Re(fft_plusZ[1]),(fft_plusZ)[2:(ceiling(n/2)+0)],Re(fft_plusZ)[ceiling(n/2)+1],Conj(rev(c((fft_plusZ)[2:floor(n/2)]))))
inv_hybrid=fft(fft_hybrid,inverse=TRUE)

yspan=range(Re(inv_hybrid)/n,Im(inv_hybrid)/n)
plot(as.numeric(substr(dfreal$V1,1,22)),Re(inv_hybrid)/n,typ="l",
     ylab="Z component",ylim=c(-11,11),xlab="t",main="Riemann Siegel Z function analogue (using spectral filtered Euler Product) of \n Modular form 13.4.a.a  L-function using max(430,floor(1.25*sqrt((t/2/pi)^2*13))) in EP",xlim=c(-40,40)+0,col="black",cex.main=0.8);grid(col="gray")
lines(as.numeric(substr(dfimag$V1,1,22)),Im(inv_hybrid)/n,col="blue")
lines(as.numeric(substr(dfZ$V1,1,22)),Re(dfZ$V2),col="magenta",lty=2)
lines(as.numeric(substr(dfZ$V1,1,22)),Re(dfZi$V2),col="cyan",lty=2)


plot(as.numeric(substr(dfreal$V1,1,22)),Re(inv_hybrid)/n-Re(dfZ$V2),typ="l",xlab="t",ylab="Error",main="Error in real(Z) component (using spectral filtered Euler Product approximation) of \n Modular form 13.4.a.a function using max(430,floor(1.25*sqrt((t/2/pi)^2*13))) in EP",col="gray",cex.main=0.8);grid(col="gray")
lines(rep((431/1.25)^1*2*pi/sqrt(13),2),c(.4,.15),lty=2,col="blue")
lines(-rep((431/1.25)^1*2*pi/sqrt(13),2),c(-.15,-.4),lty=2,col="blue")
text(x=(431/1.25)^1*2*pi/sqrt(13),y=.5,"431")
text(x=-(431/1.25)^1*2*pi/sqrt(13),y=-.5,"431")
text(x=0,y=-.6,"t value when next prime is included in EP",cex=0.7)

#Riemann-Siegel Z function of truncated Euler product at first quiescent region
#first component of riemann-siegel formula based on first quiescent region
#EP(sigma+i*t)*exp(i*theta)
#using 0 extra integers in prodeuler pari-gp function

dfplusZ=read.csv("/home/john/pari/Zplus13p4aa_EP_res_2p_0_m750_p750_537upwards_spacing_p01_real.csv",header=FALSE,colClasses = c("character"));
dfplusZ$V2=as.numeric(gsub(" ","",dfplusZ$V2));
dfplusZ=dfplusZ[order(as.numeric(dfplusZ$V1)),]

dfplusZi=read.csv("/home/john/pari/Zplus13p4aa_EP_res_2p_0_m750_p750_537upwards_spacing_p01_imag.csv",header=FALSE,colClasses = c("character"));
dfplusZi$V2=as.numeric(gsub(" ","",dfplusZi$V2));
dfplusZi=dfplusZi[order(as.numeric(dfplusZi$V1)),]

dfreal=dfplusZ;dfimag=dfplusZi

min_val=min(as.numeric(dfreal$V1));max_val=max(as.numeric(dfreal$V1))
dfimag=dfimag[(dfimag$V1 %in% dfreal$V1),]


fft_plusZ = stats::fft(dfreal$V2+1i*dfimag$V2)

dfreal_plus=dfreal
dfimag_plus=dfimag

lenf2=length(fft_plusZ)
delta_fft2=max(as.numeric(substr(dfreal$V1,1,12)))-min(as.numeric(substr(dfreal$V1,1,12)))
n=lenf2

#second component of riemann-siegel formula based on first quiescent region
#EP(1-(sigma+i*t))*chi(sigma+i*t)*exp(i*theta)
#using 0 extra integers in prodeuler pari-gp function

dfminusZ=read.csv("/home/john/pari/Zminus13p4aa_EP_res_2p_0_m750_p750_537upwards_spacing_p01_real.csv",header=FALSE,colClasses = c("character"));
dfminusZ$V2=as.numeric(gsub(" ","",dfminusZ$V2));
dfminusZ=dfminusZ[order(as.numeric(dfminusZ$V1)),]

dfminusZi=read.csv("/home/john/pari/Zminus13p4aa_EP_res_2p_0_m750_p750_537upwards_spacing_p01_imag.csv",header=FALSE,colClasses = c("character"));
dfminusZi$V2=as.numeric(gsub(" ","",dfminusZi$V2));
dfminusZi=dfminusZi[order(as.numeric(dfminusZi$V1)),]

dfreal=dfminusZ;dfimag=dfminusZi

min_val=min(as.numeric(dfreal$V1));max_val=max(as.numeric(dfreal$V1))
dfimag=dfimag[dfimag$V1 %in% dfreal$V1,]

fft_minusZ = stats::fft(dfreal$V2+1i*dfimag$V2)

dfreal_minus=dfreal
dfimag_minus=dfimag

lenf=dim(dfreal)[1]

n=dim(dfreal)[1]

min_freq=min(as.numeric(substr(dfreal$V1,1,12)))
max_freq=max(as.numeric(substr(dfreal$V1,1,12)))
delta_fft=max(as.numeric(substr(dfreal$V1,1,12)))-min(as.numeric(substr(dfreal$V1,1,12)))


#symmetric formula when sigma=0.5
#for spectral filtering of first quiescent region based Euler Product

fft_hybrid=c(Re(fft_plusZ[1]),(fft_plusZ)[2:(ceiling(n/2)+0)],Re(fft_plusZ)[ceiling(n/2)+1],Conj(rev(c((fft_plusZ)[2:floor(n/2)]))))
inv_hybrid=fft(fft_hybrid,inverse=TRUE)

yspan=range(Re(inv_hybrid)/n,Im(inv_hybrid)/n)
plot(as.numeric(substr(dfreal$V1,1,22)),Re(inv_hybrid)/n,typ="l",
     ylab="Z component",ylim=c(-11,11),xlab="t",main="Riemann Siegel Z function analogue (using spectral filtered Euler Product) of \n Modular form 13.4.a.a  L-function using max(537,floor(1.25*sqrt((t/2/pi)^2*13))) in EP",xlim=c(-40,40)+0,col="black",cex.main=0.8);grid(col="gray")
lines(as.numeric(substr(dfimag$V1,1,22)),Im(inv_hybrid)/n,col="blue")
lines(as.numeric(substr(dfZ$V1,1,22)),Re(dfZ$V2),col="magenta",lty=2)
lines(as.numeric(substr(dfZ$V1,1,22)),Re(dfZi$V2),col="cyan",lty=2)


plot(as.numeric(substr(dfreal$V1,1,22)),Re(inv_hybrid)/n-Re(dfZ$V2),typ="l",xlab="t",ylab="Error",main="Error in real(Z) component (using spectral filtered Euler Product approximation) of \n Modular form 13.4.a.a function using max(537,floor(1.25*sqrt((t/2/pi)^2*13))) in EP",col="gray",cex.main=0.8);grid(col="gray")

```



\clearpage


```{r Zfn13p4aaModularFormLfunction_fouriertransform_0_pm750_res_2p3, echo=FALSE, fig.cap="A comparison of the fourier transforms of the Riemann-Siegel Z function analogue of the L-function 2-13-1.1-c3-0-2 (LMFDB label) and partial Euler Product (using truncation at $1.25\\cdot \\sqrt{((\\frac{750}{2\\pi})^2\\cdot 13}$) in the complex plane at $\\sigma=2.3$ for the interval t=(-750,750) about the real axis. Off the critical line, to help use the partial Euler Product as an approximation of the Riemann-Siegel Z function only the positive frequencies (green) negative frequencies (blue) of the first and second Riemann-Siegel components are retained and spliced together to form a strong zeroth order improvement. In the middle row, the $\\textbf{lefthand panel}$ displays the true Riemann-Siegel Z function fourier transform behaviour while the $\\textbf{righthand panel}$ displays the neat splicing together of the first and second Riemann-Siegel components fourier transform behaviour.", out.width = c("49%","49%"), fig.show = "hold",  fig.height=5, warning=FALSE, cache=TRUE}


# Riemann-Siegel Z function of L32 function on critical line
# values recorded every .01 spacing in interval [-750,+750]

dfZ=read.csv("/home/john/pari/Z13p4aa_res_2p3_0_m750_p750_spacing_p01_real.csv",header=FALSE,colClasses = c("character"));
dfZ$V2=as.numeric(gsub(" ","",dfZ$V2));
dfZ=dfZ[order(as.numeric(dfZ$V1)),]

dfZi=read.csv("/home/john/pari/Z13p4aa_res_2p3_0_m750_p750_spacing_p01_imag.csv",header=FALSE,colClasses = c("character"));
dfZi$V2=as.numeric(gsub(" ","",dfZi$V2));
dfZi=dfZi[order(as.numeric(dfZi$V1)),]

fft_zeta_Zfn =  stats::fft(dfZ$V2+1i*dfZi$V2)


#first component of riemann-siegel formula based on first quiescent region
#EP(sigma+i*t)*exp(i*theta)
#using minimum 23 primes in prodeuler pari-gp function

dfplusZ=read.csv("/home/john/pari/Zplus13p4aa_EP_res_2p3_0_m750_p750_537upwards_spacing_p01_real.csv",header=FALSE,colClasses = c("character"));
dfplusZ$V2=as.numeric(gsub(" ","",dfplusZ$V2));
dfplusZ=dfplusZ[order(as.numeric(dfplusZ$V1)),]

dfplusZi=read.csv("/home/john/pari/Zplus13p4aa_EP_res_2p3_0_m750_p750_537upwards_spacing_p01_imag.csv",header=FALSE,colClasses = c("character"));
dfplusZi$V2=as.numeric(gsub(" ","",dfplusZi$V2));
dfplusZi=dfplusZi[order(as.numeric(dfplusZi$V1)),]

dfreal=dfplusZ;dfimag=dfplusZi

min_val=min(as.numeric(dfreal$V1));max_val=max(as.numeric(dfreal$V1))
dfimag=dfimag[(dfimag$V1 %in% dfreal$V1),]


fft_plusZ = stats::fft(dfreal$V2+1i*dfimag$V2)

dfreal_plus=dfreal
dfimag_plus=dfimag

lenf2=length(fft_plusZ)
delta_fft2=max(as.numeric(substr(dfreal$V1,1,12)))-min(as.numeric(substr(dfreal$V1,1,12)))
n=lenf2

#second component of riemann-siegel formula based on first quiescent region
#EP(1-(sigma+i*t))*chi(sigma+i*t)*exp(i*theta)
#using minimum 23 primes in prodeuler pari-gp function

dfminusZ=read.csv("/home/john/pari/Zminus13p4aa_EP_res_2p3_0_m750_p750_537upwards_spacing_p01_real.csv",header=FALSE,colClasses = c("character"));
dfminusZ$V2=as.numeric(gsub(" ","",dfminusZ$V2));
dfminusZ=dfminusZ[order(as.numeric(dfminusZ$V1)),]

dfminusZi=read.csv("/home/john/pari/Zminus13p4aa_EP_res_2p3_0_m750_p750_537upwards_spacing_p01_imag.csv",header=FALSE,colClasses = c("character"));
dfminusZi$V2=as.numeric(gsub(" ","",dfminusZi$V2));
dfminusZi=dfminusZi[order(as.numeric(dfminusZi$V1)),]

dfreal=dfminusZ;dfimag=dfminusZi

min_val=min(as.numeric(dfreal$V1));max_val=max(as.numeric(dfreal$V1))
dfimag=dfimag[dfimag$V1 %in% dfreal$V1,]

fft_minusZ = stats::fft(dfreal$V2+1i*dfimag$V2)

dfreal_minus=dfreal
dfimag_minus=dfimag

lenf=dim(dfreal)[1]

n=dim(dfreal)[1]

min_freq=min(as.numeric(substr(dfreal$V1,1,12)))
max_freq=max(as.numeric(substr(dfreal$V1,1,12)))

delta_fft=max_freq-min_freq
mid=floor(delta_fft/2/pi*log(floor(sqrt((max_freq/2/pi/c(1))^2*13))))

plot(c(-floor(n/2):(ceiling(n/2)-1))*2*pi/delta_fft,c(abs(fft_plusZ)[(ceiling(n/2)+1):n],abs(fft_plusZ)[1:(ceiling(n/2))]),xlim=c(-11,11),typ="l",xaxt="n",xlab="angular frequency (radians per sec)",ylab="|Amplitude|",main="fourier transform spectra of the first component of \n the partial Euler product Riemann-Siegel Z function \n using truncation at N1=sqrt((max(t)/2/pi)^2*13).")
abline(v=seq(-20,20,l=41),h=seq(0,1e5,l=6),lty=3,col="gray")
axis(1,at=seq(-20,20,l=41))
abline(v=-1/2*log(((max_freq)/pi/2)^2*13/c(1:2)^2)-0,col=rgb(1,0,0,0.3))
abline(v=1/2*log(((max_freq)/pi/2)^2*13/c(1:2)^2)-0,col=rgb(1,0,0,0.3))


yspan=range(abs(fft_plusZ))
plot(c(-floor(n/2):-1)*2*pi/delta_fft,rep(0,floor(n/2)),xlim=c(-11,11),typ="l",xaxt="n",xlab="angular frequency (radians per sec)",ylab="|Amplitude|",main="piecewise fourier transform \n spectra filtering of the first component positive frequencies \n and phase conjugate reflection imputation of the negative freq half.",col=4,ylim=yspan)
lines(c(0:(ceiling(n/2)-1))*2*pi/delta_fft,c(abs(fft_plusZ)[1:(ceiling(n/2))]),col=3)
abline(v=seq(-20,20,l=41),h=seq(0,1e5,l=6),lty=3,col="gray")
axis(1,at=seq(-20,20,l=41))
abline(v=-1/2*log(((max_freq)/pi/2)^2*13/c(1:2)^2)-0,col=rgb(1,0,0,0.3))
abline(v=1/2*log(((max_freq)/pi/2)^2*13/c(1:2)^2)-0,col=rgb(1,0,0,0.3))


n=dim(dfZ)[1]
min_freq=min(as.numeric(dfZ$V1))
max_freq=max(as.numeric(dfZ$V1))
delta_fft=max_freq-min_freq
mid=floor(delta_fft/2/pi*log(floor(sqrt((max_freq/2/pi/c(1))^2*13))))

plot(c(-floor(n/2):(ceiling(n/2)-1))*2*pi/delta_fft,c(abs(fft_zeta_Zfn)[(ceiling(n/2)+1):n],abs(fft_zeta_Zfn)[1:(ceiling(n/2))]),xlim=c(-11,11),typ="l",xaxt="n",xlab="angular frequency (radians per sec)",ylab="|Amplitude|",main="fourier transform spectra of the true Riemann-Siegel Z function.",cex.main=0.9)
abline(v=seq(-20,20,l=41),h=seq(0,1e5,l=6),lty=3,col="gray")
axis(1,at=seq(-20,20,l=41))
abline(v=-1/2*log(((max_freq)/pi/2)^2*13/c(1:2)^2)-0,col=rgb(1,0,0,0.3))
abline(v=1/2*log(((max_freq)/pi/2)^2*13/c(1:2)^2)-0,col=rgb(1,0,0,0.3))

n=dim(dfZ)[1]
min_freq=min(as.numeric(dfZ$V1))
max_freq=max(as.numeric(dfZ$V1))
delta_fft=max_freq-min_freq
mid=floor(delta_fft/2/pi*log(floor(sqrt((max_freq/2/pi/c(1))^2*13))))

fft_hybrid=c(1/2*(fft_plusZ[1]+fft_minusZ[1]),(fft_plusZ)[2:(ceiling(n/2)+0)],1/2*(fft_plusZ[ceiling(n/2)+1]+fft_minusZ[ceiling(n/2)+1]),fft_minusZ[(ceiling(n/2)+2):n])


yspan=range(abs(fft_hybrid))
plot(c(-floor(n/2):-1)*2*pi/delta_fft,abs(c(1/2*(fft_plusZ[ceiling(n/2)+1]+fft_minusZ[ceiling(n/2)+1]),fft_minusZ[(ceiling(n/2)+2):n])),xlim=c(-11,11),typ="l",xaxt="n",xlab="angular frequency (radians per sec)",ylab="|Amplitude|",main="piecewise fourier transform spectra filtering \n and splicing of the first component positive frequencies \n and the second component negative frequencies.",col=4,ylim=c(0,25000))
lines(c(0:(floor(n/2)))*2*pi/delta_fft,abs(c(1/2*(fft_plusZ[1]+fft_minusZ[1]),(fft_plusZ)[2:(ceiling(n/2)+0)])),col=3)
abline(v=seq(-20,20,l=41),h=seq(0,1e5,l=6),lty=3,col="gray")
axis(1,at=seq(-20,20,l=41))
abline(v=-1/2*log(((max_freq)/pi/2)^2*13/c(1:2)^2)-0,col=rgb(1,0,0,0.3))
abline(v=1/2*log(((max_freq)/pi/2)^2*13/c(1:2)^2)-0,col=rgb(1,0,0,0.3))


n=dim(dfminusZ)[1]
min_freq=min(as.numeric(dfminusZ$V1))
max_freq=max(as.numeric(dfminusZ$V1))
delta_fft=max_freq-min_freq
mid=floor(delta_fft/2/pi*log(floor(sqrt((max_freq/2/pi/c(1))^2*13))))

plot(c(-floor(n/2):(ceiling(n/2)-1))*2*pi/delta_fft,c(abs(fft_minusZ)[(ceiling(n/2)+1):n],abs(fft_minusZ)[1:(ceiling(n/2))]),xlim=c(-11,11),typ="l",xaxt="n",xlab="angular frequency (radians per sec)",ylab="|Amplitude|",main="fourier transform spectra of the second component of \n the partial Euler product Riemann-Siegel Z function \n using truncation at N1=sqrt((max(t)/2/pi)^2*13).")
abline(v=seq(-20,20,l=41),h=seq(0,1e5,l=6),lty=3,col="gray")
axis(1,at=seq(-20,20,l=41))
abline(v=-1/2*log(((max_freq)/pi/2)^2*13/c(1:2)^2)-0,col=rgb(1,0,0,0.3))
abline(v=1/2*log(((max_freq)/pi/2)^2*13/c(1:2)^2)-0,col=rgb(1,0,0,0.3))

yspan=range(abs(fft_hybrid))
plot(c(-floor(n/2):-1)*2*pi/delta_fft,c(abs(fft_minusZ)[(ceiling(n/2)+1):n]),xlim=c(-11,11),typ="l",xaxt="n",xlab="angular frequency (radians per sec)",ylab="|Amplitude|",main="piecewise fourier transform \n spectra filtering of the second component negative frequencies \n and phase conjugate reflection imputation of the positive freq half.",col=4,ylim=yspan)
lines(c(0:(floor(n/2)))*2*pi/delta_fft,rep(0,ceiling(n/2)),col=3)
abline(v=seq(-20,20,l=41),h=seq(0,1e5,l=6),lty=3,col="gray")
axis(1,at=seq(-20,20,l=41))
abline(v=-1/2*log(((max_freq)/pi/2)^2*13/c(1:2)^2)-0,col=rgb(1,0,0,0.3))
abline(v=1/2*log(((max_freq)/pi/2)^2*13/c(1:2)^2)-0,col=rgb(1,0,0,0.3))

```



\clearpage

```{r Zfn13p4aaModularFormLfunctionoveraninterval_anditsfouriertransform_0_pm750_2p3, echo=FALSE, fig.cap="Lefthand panel - True Z function shown in magenta (cyan) for real (imaginary) parts and spectral filtered based EP approximation shown in black (blue) for real (imaginary) parts, Right hand panel - Error in the real(Z) EP approximation. A comparison of the Riemann-Siegel Z function analogue of the L-function 2-13-1.1-c3-0-2 (LMFDB label) and spectrally filtered partial Euler Product (using truncation at $\\max (P,\\sqrt{((\\frac{t}{2\\pi})^2\\cdot 13}) $) in the complex plane at $\\sigma=2.3$ for the interval t=(-750,750) where $P_{min}={1,2,50,537}$ for rows 1-4. ", out.width = c("49%","49%"), fig.show = "hold",  fig.height=4.5, warning=FALSE, cache=TRUE}


# Riemann-Siegel Z function of L32 function on critical line
# values recorded every .01 spacing in interval [-750,+750]

dfZ=read.csv("/home/john/pari/Z13p4aa_res_2p3_0_m750_p750_spacing_p01_real.csv",header=FALSE,colClasses = c("character"));
dfZ$V2=as.numeric(gsub(" ","",dfZ$V2));
dfZ=dfZ[order(as.numeric(dfZ$V1)),]

dfZi=read.csv("/home/john/pari/Z13p4aa_res_2p3_0_m750_p750_spacing_p01_imag.csv",header=FALSE,colClasses = c("character"));
dfZi$V2=as.numeric(gsub(" ","",dfZi$V2));
dfZi=dfZi[order(as.numeric(dfZi$V1)),]


#Riemann-Siegel Z function of truncated Euler product at first quiescent region
#first component of riemann-siegel formula based on first quiescent region
#EP(sigma+i*t)*exp(i*theta)
#using 0 extra integers in prodeuler pari-gp function

dfplusZ=read.csv("/home/john/pari/Zplus13p4aa_EP_res_2p3_0_m750_p750_0extra_spacing_p01_real.csv",header=FALSE,colClasses = c("character"));
dfplusZ$V2=as.numeric(gsub(" ","",dfplusZ$V2));
dfplusZ=dfplusZ[order(as.numeric(dfplusZ$V1)),]

dfplusZi=read.csv("/home/john/pari/Zplus13p4aa_EP_res_2p3_0_m750_p750_0extra_spacing_p01_imag.csv",header=FALSE,colClasses = c("character"));
dfplusZi$V2=as.numeric(gsub(" ","",dfplusZi$V2));
dfplusZi=dfplusZi[order(as.numeric(dfplusZi$V1)),]

dfreal=dfplusZ;dfimag=dfplusZi

min_val=min(as.numeric(dfreal$V1));max_val=max(as.numeric(dfreal$V1))
dfimag=dfimag[(dfimag$V1 %in% dfreal$V1),]


fft_plusZ = stats::fft(dfreal$V2+1i*dfimag$V2)

dfreal_plus=dfreal
dfimag_plus=dfimag

lenf2=length(fft_plusZ)
delta_fft2=max(as.numeric(substr(dfreal$V1,1,12)))-min(as.numeric(substr(dfreal$V1,1,12)))
n=lenf2

#second component of riemann-siegel formula based on first quiescent region
#EP(1-(sigma+i*t))*chi(sigma+i*t)*exp(i*theta)
#using 0 extra integers in prodeuler pari-gp function

dfminusZ=read.csv("/home/john/pari/Zminus13p4aa_EP_res_2p3_0_m750_p750_0extra_spacing_p01_real.csv",header=FALSE,colClasses = c("character"));
dfminusZ$V2=as.numeric(gsub(" ","",dfminusZ$V2));
dfminusZ=dfminusZ[order(as.numeric(dfminusZ$V1)),]

dfminusZi=read.csv("/home/john/pari/Zminus13p4aa_EP_res_2p3_0_m750_p750_0extra_spacing_p01_imag.csv",header=FALSE,colClasses = c("character"));
dfminusZi$V2=as.numeric(gsub(" ","",dfminusZi$V2));
dfminusZi=dfminusZi[order(as.numeric(dfminusZi$V1)),]

dfreal=dfminusZ;dfimag=dfminusZi

min_val=min(as.numeric(dfreal$V1));max_val=max(as.numeric(dfreal$V1))
dfimag=dfimag[dfimag$V1 %in% dfreal$V1,]

fft_minusZ = stats::fft(dfreal$V2+1i*dfimag$V2)

dfreal_minus=dfreal
dfimag_minus=dfimag

lenf=dim(dfreal)[1]

n=dim(dfreal)[1]

min_freq=min(as.numeric(substr(dfreal$V1,1,12)))
max_freq=max(as.numeric(substr(dfreal$V1,1,12)))
delta_fft=max(as.numeric(substr(dfreal$V1,1,12)))-min(as.numeric(substr(dfreal$V1,1,12)))


#symmetric formula when sigma=0.5
#for spectral filtering of first quiescent region based Euler Product

fft_hybrid=c(1/2*(fft_plusZ[1]+fft_minusZ[1]),(fft_plusZ)[2:(ceiling(n/2)+0)],1/2*(fft_plusZ[ceiling(n/2)+1]+fft_minusZ[ceiling(n/2)+1]),fft_minusZ[(ceiling(n/2)+2):n])
inv_hybrid=fft(fft_hybrid,inverse=TRUE)

yspan=range(Re(inv_hybrid)/n,Im(inv_hybrid)/n)
plot(as.numeric(substr(dfreal$V1,1,22)),Re(inv_hybrid)/n,typ="l",
     ylab="Z component",ylim=c(-11,11),xlab="t",main="Riemann Siegel Z function analogue (using spectral filtered Euler Product) of \n Modular form 13.4.a.a function using max(1,floor(1.25*sqrt((t/2/pi)^2*13))) in EP",xlim=c(-40,40)+0,col="black",cex.main=0.8);grid(col="gray")
lines(as.numeric(substr(dfimag$V1,1,22)),Im(inv_hybrid)/n,col="blue")
lines(as.numeric(substr(dfZ$V1,1,22)),Re(dfZ$V2),col="magenta",lty=2)
lines(as.numeric(substr(dfZ$V1,1,22)),Re(dfZi$V2),col="cyan",lty=2)
lines(rep((2/1.25)^1*2*pi/sqrt(13),2),c(-8,-5),lty=2,col="blue")
lines(rep((3/1.25)^1*2*pi/sqrt(13),2),c(5,8),lty=2,col="blue")
lines(-rep((2/1.25)^1*2*pi/sqrt(13),2),c(-8,-5),lty=2,col="blue")
lines(-rep((3/1.25)^1*2*pi/sqrt(13),2),c(5,8),lty=2,col="blue")
text(x=c(-1,1)*(2/1.25)^1*2*pi/sqrt(13),y=-9,"2")
text(x=c(-1,1)*(3/1.25)^1*2*pi/sqrt(13),y=9,"3")
text(x=-10,y=-11,"t value when next prime is included in EP",cex=0.7)

plot(as.numeric(substr(dfreal$V1,1,22)),Re(inv_hybrid)/n-Re(dfZ$V2),typ="l",xlab="t",ylab="Error",main="Error in real(Z) component (using spectral filtered Euler Product approximation) of \n Modular form 13.4.a.a function using max(1,floor(1.25*sqrt((t/2/pi)^2*13))) in EP",col="gray",cex.main=0.8);grid(col="gray2")

#Riemann-Siegel Z function of truncated Euler product at first quiescent region
#first component of riemann-siegel formula based on first quiescent region
#EP(sigma+i*t)*exp(i*theta)
#using 0 extra integers in prodeuler pari-gp function

dfplusZ=read.csv("/home/john/pari/Zplus13p4aa_EP_res_2p3_0_m750_p750_2upwards_spacing_p01_real.csv",header=FALSE,colClasses = c("character"));
dfplusZ$V2=as.numeric(gsub(" ","",dfplusZ$V2));
dfplusZ=dfplusZ[order(as.numeric(dfplusZ$V1)),]

dfplusZi=read.csv("/home/john/pari/Zplus13p4aa_EP_res_2p3_0_m750_p750_2upwards_spacing_p01_imag.csv",header=FALSE,colClasses = c("character"));
dfplusZi$V2=as.numeric(gsub(" ","",dfplusZi$V2));
dfplusZi=dfplusZi[order(as.numeric(dfplusZi$V1)),]

dfreal=dfplusZ;dfimag=dfplusZi

min_val=min(as.numeric(dfreal$V1));max_val=max(as.numeric(dfreal$V1))
dfimag=dfimag[(dfimag$V1 %in% dfreal$V1),]


fft_plusZ = stats::fft(dfreal$V2+1i*dfimag$V2)

dfreal_plus=dfreal
dfimag_plus=dfimag

lenf2=length(fft_plusZ)
delta_fft2=max(as.numeric(substr(dfreal$V1,1,12)))-min(as.numeric(substr(dfreal$V1,1,12)))
n=lenf2

#second component of riemann-siegel formula based on first quiescent region
#EP(1-(sigma+i*t))*chi(sigma+i*t)*exp(i*theta)
#using 0 extra integers in prodeuler pari-gp function

dfminusZ=read.csv("/home/john/pari/Zminus13p4aa_EP_res_2p3_0_m750_p750_2upwards_spacing_p01_real.csv",header=FALSE,colClasses = c("character"));
dfminusZ$V2=as.numeric(gsub(" ","",dfminusZ$V2));
dfminusZ=dfminusZ[order(as.numeric(dfminusZ$V1)),]

dfminusZi=read.csv("/home/john/pari/Zminus13p4aa_EP_res_2p3_0_m750_p750_2upwards_spacing_p01_imag.csv",header=FALSE,colClasses = c("character"));
dfminusZi$V2=as.numeric(gsub(" ","",dfminusZi$V2));
dfminusZi=dfminusZi[order(as.numeric(dfminusZi$V1)),]

dfreal=dfminusZ;dfimag=dfminusZi

min_val=min(as.numeric(dfreal$V1));max_val=max(as.numeric(dfreal$V1))
dfimag=dfimag[dfimag$V1 %in% dfreal$V1,]

fft_minusZ = stats::fft(dfreal$V2+1i*dfimag$V2)

dfreal_minus=dfreal
dfimag_minus=dfimag

lenf=dim(dfreal)[1]

n=dim(dfreal)[1]

min_freq=min(as.numeric(substr(dfreal$V1,1,12)))
max_freq=max(as.numeric(substr(dfreal$V1,1,12)))
delta_fft=max(as.numeric(substr(dfreal$V1,1,12)))-min(as.numeric(substr(dfreal$V1,1,12)))


#symmetric formula when sigma=0.5
#for spectral filtering of first quiescent region based Euler Product

fft_hybrid=c(1/2*(fft_plusZ[1]+fft_minusZ[1]),(fft_plusZ)[2:(ceiling(n/2)+0)],1/2*(fft_plusZ[ceiling(n/2)+1]+fft_minusZ[ceiling(n/2)+1]),fft_minusZ[(ceiling(n/2)+2):n])
inv_hybrid=fft(fft_hybrid,inverse=TRUE)

yspan=range(Re(inv_hybrid)/n,Im(inv_hybrid)/n)
plot(as.numeric(substr(dfreal$V1,1,22)),Re(inv_hybrid)/n,typ="l",
     ylab="Z component",ylim=c(-11,11),xlab="t",main="Riemann Siegel Z function analogue (using spectral filtered Euler Product) of \n Modular form 13.4.a.a L function using max(2,floor(1.25*sqrt((t/2/pi)^2*13))) in EP",xlim=c(-40,40)+0,col="black",cex.main=0.8);grid(col="gray")
lines(as.numeric(substr(dfimag$V1,1,22)),Im(inv_hybrid)/n,col="blue")
lines(as.numeric(substr(dfZ$V1,1,22)),Re(dfZ$V2),col="magenta",lty=2)
lines(as.numeric(substr(dfZ$V1,1,22)),Re(dfZi$V2),col="cyan",lty=2)
lines(rep((3/1.25)^1*2*pi/sqrt(13),2),c(5,8),lty=2,col="blue")
lines(-rep((3/1.25)^1*2*pi/sqrt(13),2),c(5,8),lty=2,col="blue")
text(x=c(-1,1)*(3/1.25)^1*2*pi/sqrt(13),y=9,"3")
text(x=0,y=11,"t value when next prime is included in EP",cex=0.7)

plot(as.numeric(substr(dfreal$V1,1,22)),Re(inv_hybrid)/n-Re(dfZ$V2),typ="l",xlab="t",ylab="Error",main="Error in real(Z) component (using spectral filtered Euler Product approximation) of \n Modular form 13.4.a.a L function using max(2,floor(1.25*sqrt((t/2/pi)^2*13))) in EP",col="gray",cex.main=0.8);grid(col="gray2")

#Riemann-Siegel Z function of truncated Euler product at first quiescent region
#first component of riemann-siegel formula based on first quiescent region
#EP(sigma+i*t)*exp(i*theta)
#using 0 extra integers in prodeuler pari-gp function

dfplusZ=read.csv("/home/john/pari/Zplus13p4aa_EP_res_2p3_0_m750_p750_50upwards_spacing_p01_real.csv",header=FALSE,colClasses = c("character"));
dfplusZ$V2=as.numeric(gsub(" ","",dfplusZ$V2));
dfplusZ=dfplusZ[order(as.numeric(dfplusZ$V1)),]

dfplusZi=read.csv("/home/john/pari/Zplus13p4aa_EP_res_2p3_0_m750_p750_50upwards_spacing_p01_imag.csv",header=FALSE,colClasses = c("character"));
dfplusZi$V2=as.numeric(gsub(" ","",dfplusZi$V2));
dfplusZi=dfplusZi[order(as.numeric(dfplusZi$V1)),]

dfreal=dfplusZ;dfimag=dfplusZi

min_val=min(as.numeric(dfreal$V1));max_val=max(as.numeric(dfreal$V1))
dfimag=dfimag[(dfimag$V1 %in% dfreal$V1),]


fft_plusZ = stats::fft(dfreal$V2+1i*dfimag$V2)

dfreal_plus=dfreal
dfimag_plus=dfimag

lenf2=length(fft_plusZ)
delta_fft2=max(as.numeric(substr(dfreal$V1,1,12)))-min(as.numeric(substr(dfreal$V1,1,12)))
n=lenf2

#second component of riemann-siegel formula based on first quiescent region
#EP(1-(sigma+i*t))*chi(sigma+i*t)*exp(i*theta)
#using 0 extra integers in prodeuler pari-gp function

dfminusZ=read.csv("/home/john/pari/Zminus13p4aa_EP_res_2p3_0_m750_p750_50upwards_spacing_p01_real.csv",header=FALSE,colClasses = c("character"));
dfminusZ$V2=as.numeric(gsub(" ","",dfminusZ$V2));
dfminusZ=dfminusZ[order(as.numeric(dfminusZ$V1)),]

dfminusZi=read.csv("/home/john/pari/Zminus13p4aa_EP_res_2p3_0_m750_p750_50upwards_spacing_p01_imag.csv",header=FALSE,colClasses = c("character"));
dfminusZi$V2=as.numeric(gsub(" ","",dfminusZi$V2));
dfminusZi=dfminusZi[order(as.numeric(dfminusZi$V1)),]

dfreal=dfminusZ;dfimag=dfminusZi

min_val=min(as.numeric(dfreal$V1));max_val=max(as.numeric(dfreal$V1))
dfimag=dfimag[dfimag$V1 %in% dfreal$V1,]

fft_minusZ = stats::fft(dfreal$V2+1i*dfimag$V2)

dfreal_minus=dfreal
dfimag_minus=dfimag

lenf=dim(dfreal)[1]

n=dim(dfreal)[1]

min_freq=min(as.numeric(substr(dfreal$V1,1,12)))
max_freq=max(as.numeric(substr(dfreal$V1,1,12)))
delta_fft=max(as.numeric(substr(dfreal$V1,1,12)))-min(as.numeric(substr(dfreal$V1,1,12)))


#symmetric formula when sigma=0.5
#for spectral filtering of first quiescent region based Euler Product

fft_hybrid=c(1/2*(fft_plusZ[1]+fft_minusZ[1]),(fft_plusZ)[2:(ceiling(n/2)+0)],1/2*(fft_plusZ[ceiling(n/2)+1]+fft_minusZ[ceiling(n/2)+1]),fft_minusZ[(ceiling(n/2)+2):n])
inv_hybrid=fft(fft_hybrid,inverse=TRUE)

yspan=range(Re(inv_hybrid)/n,Im(inv_hybrid)/n)
plot(as.numeric(substr(dfreal$V1,1,22)),Re(inv_hybrid)/n,typ="l",
     ylab="Z component",ylim=c(-11,11),xlab="t",main="Riemann Siegel Z function analogue (using spectral filtered Euler Product) of \n Modular form 13.4.a.a function using max(50,floor(1.25*sqrt((t/2/pi)^2*13))) in EP",xlim=c(-40,40)+0,col="black",cex.main=0.8);grid(col="gray")
lines(as.numeric(substr(dfimag$V1,1,22)),Im(inv_hybrid)/n,col="blue")
lines(as.numeric(substr(dfZ$V1,1,22)),Re(dfZ$V2),col="magenta",lty=2)
lines(as.numeric(substr(dfZ$V1,1,22)),Re(dfZi$V2),col="cyan",lty=2)

plot(as.numeric(substr(dfreal$V1,1,22)),Re(inv_hybrid)/n-Re(dfZ$V2),typ="l",xlab="t",ylab="Error",main="Error in real(Z) component (using spectral filtered Euler Product approximation) of \n Modular form 13.4.a.a function using max(5,floor(1.25*sqrt((t/2/pi)^2*13))) in EP",col="gray",cex.main=0.8);grid(col="gray2")
lines(-rep((53/1.25)^1*2*pi/sqrt(13),2),c(-.4,-.15),lty=2,col="blue")
lines(rep((53/1.25)^1*2*pi/sqrt(13),2),c(.15,.4),lty=2,col="blue")
text(x=-(53/1.25)^1*2*pi/sqrt(13),y=-.5,"53")
text(x=(53/1.25)^1*2*pi/sqrt(13),y=.5,"53")
text(x=0,y=-.65,"t value when next prime is included in EP",cex=0.7)

#Riemann-Siegel Z function of truncated Euler product at first quiescent region
#first component of riemann-siegel formula based on first quiescent region
#EP(sigma+i*t)*exp(i*theta)
#using 0 extra integers in prodeuler pari-gp function

dfplusZ=read.csv("/home/john/pari/Zplus13p4aa_EP_res_2p3_0_m750_p750_537upwards_spacing_p01_real.csv",header=FALSE,colClasses = c("character"));
dfplusZ$V2=as.numeric(gsub(" ","",dfplusZ$V2));
dfplusZ=dfplusZ[order(as.numeric(dfplusZ$V1)),]

dfplusZi=read.csv("/home/john/pari/Zplus13p4aa_EP_res_2p3_0_m750_p750_537upwards_spacing_p01_imag.csv",header=FALSE,colClasses = c("character"));
dfplusZi$V2=as.numeric(gsub(" ","",dfplusZi$V2));
dfplusZi=dfplusZi[order(as.numeric(dfplusZi$V1)),]

dfreal=dfplusZ;dfimag=dfplusZi

min_val=min(as.numeric(dfreal$V1));max_val=max(as.numeric(dfreal$V1))
dfimag=dfimag[(dfimag$V1 %in% dfreal$V1),]


fft_plusZ = stats::fft(dfreal$V2+1i*dfimag$V2)

dfreal_plus=dfreal
dfimag_plus=dfimag

lenf2=length(fft_plusZ)
delta_fft2=max(as.numeric(substr(dfreal$V1,1,12)))-min(as.numeric(substr(dfreal$V1,1,12)))
n=lenf2

#second component of riemann-siegel formula based on first quiescent region
#EP(1-(sigma+i*t))*chi(sigma+i*t)*exp(i*theta)
#using 0 extra integers in prodeuler pari-gp function

dfminusZ=read.csv("/home/john/pari/Zminus13p4aa_EP_res_2p3_0_m750_p750_537upwards_spacing_p01_real.csv",header=FALSE,colClasses = c("character"));
dfminusZ$V2=as.numeric(gsub(" ","",dfminusZ$V2));
dfminusZ=dfminusZ[order(as.numeric(dfminusZ$V1)),]

dfminusZi=read.csv("/home/john/pari/Zminus13p4aa_EP_res_2p3_0_m750_p750_537upwards_spacing_p01_imag.csv",header=FALSE,colClasses = c("character"));
dfminusZi$V2=as.numeric(gsub(" ","",dfminusZi$V2));
dfminusZi=dfminusZi[order(as.numeric(dfminusZi$V1)),]

dfreal=dfminusZ;dfimag=dfminusZi

min_val=min(as.numeric(dfreal$V1));max_val=max(as.numeric(dfreal$V1))
dfimag=dfimag[dfimag$V1 %in% dfreal$V1,]

fft_minusZ = stats::fft(dfreal$V2+1i*dfimag$V2)

dfreal_minus=dfreal
dfimag_minus=dfimag

lenf=dim(dfreal)[1]

n=dim(dfreal)[1]

min_freq=min(as.numeric(substr(dfreal$V1,1,12)))
max_freq=max(as.numeric(substr(dfreal$V1,1,12)))
delta_fft=max(as.numeric(substr(dfreal$V1,1,12)))-min(as.numeric(substr(dfreal$V1,1,12)))


#symmetric formula when sigma=0.5
#for spectral filtering of first quiescent region based Euler Product

fft_hybrid=c(1/2*(fft_plusZ[1]+fft_minusZ[1]),(fft_plusZ)[2:(ceiling(n/2)+0)],1/2*(fft_plusZ[ceiling(n/2)+1]+fft_minusZ[ceiling(n/2)+1]),fft_minusZ[(ceiling(n/2)+2):n])
inv_hybrid=fft(fft_hybrid,inverse=TRUE)

yspan=range(Re(inv_hybrid)/n,Im(inv_hybrid)/n)
plot(as.numeric(substr(dfreal$V1,1,22)),Re(inv_hybrid)/n,typ="l",
     ylab="Z component",ylim=c(-11,11),xlab="t",main="Riemann Siegel Z function analogue (using spectral filtered Euler Product) of \n Modular form 13.4.a.a  L-function using max(537,floor(1.25*sqrt((t/2/pi)^2*13))) in EP",xlim=c(-40,40)+0,col="black",cex.main=0.8);grid(col="gray")
lines(as.numeric(substr(dfimag$V1,1,22)),Im(inv_hybrid)/n,col="blue")
lines(as.numeric(substr(dfZ$V1,1,22)),Re(dfZ$V2),col="magenta",lty=2)
lines(as.numeric(substr(dfZ$V1,1,22)),Re(dfZi$V2),col="cyan",lty=2)


plot(as.numeric(substr(dfreal$V1,1,22)),Re(inv_hybrid)/n-Re(dfZ$V2),typ="l",xlab="t",ylab="Error",main="Error in real(Z) component (using spectral filtered Euler Product approximation) of \n Modular form 13.4.a.a function using max(537,floor(1.25*sqrt((t/2/pi)^2*13))) in EP",col="gray",cex.main=0.8);grid(col="gray")

```

\clearpage 



```{r Zfn13p4aaModularFormLfunction_fouriertransform_0_pm750_res_1p7, echo=FALSE, fig.cap="A comparison of the fourier transforms of the Riemann-Siegel Z function analogue of the L-function 2-13-1.1-c3-0-2 (LMFDB label) and partial Euler Product (using truncation at $1.25\\cdot \\sqrt{((\\frac{750}{2\\pi})^2\\cdot 13}$) in the complex plane at $\\sigma=1.7$ for the interval t=(-750,750) about the real axis. Off the critical line, to help use the partial Euler Product as an approximation of the Riemann-Siegel Z function only the positive frequencies (green) negative frequencies (blue) of the first and second Riemann-Siegel components are retained and spliced together to form a strong zeroth order improvement. In the middle row, the $\\textbf{lefthand panel}$ displays the true Riemann-Siegel Z function fourier transform behaviour while the $\\textbf{righthand panel}$ displays the neat splicing together of the first and second Riemann-Siegel components fourier transform behaviour.", out.width = c("49%","49%"), fig.show = "hold",  fig.height=5, warning=FALSE, cache=TRUE}


# Riemann-Siegel Z function of L32 function on critical line
# values recorded every .01 spacing in interval [-750,+750]

dfZ=read.csv("/home/john/pari/Z13p4aa_res_1p7_0_m750_p750_spacing_p01_real.csv",header=FALSE,colClasses = c("character"));
dfZ$V2=as.numeric(gsub(" ","",dfZ$V2));
dfZ=dfZ[order(as.numeric(dfZ$V1)),]

dfZi=read.csv("/home/john/pari/Z13p4aa_res_1p7_0_m750_p750_spacing_p01_imag.csv",header=FALSE,colClasses = c("character"));
dfZi$V2=as.numeric(gsub(" ","",dfZi$V2));
dfZi=dfZi[order(as.numeric(dfZi$V1)),]

fft_zeta_Zfn =  stats::fft(dfZ$V2+1i*dfZi$V2)


#first component of riemann-siegel formula based on first quiescent region
#EP(sigma+i*t)*exp(i*theta)
#using minimum 23 primes in prodeuler pari-gp function

dfplusZ=read.csv("/home/john/pari/Zplus13p4aa_EP_res_1p7_0_m750_p750_537upwards_spacing_p01_real.csv",header=FALSE,colClasses = c("character"));
dfplusZ$V2=as.numeric(gsub(" ","",dfplusZ$V2));
dfplusZ=dfplusZ[order(as.numeric(dfplusZ$V1)),]

dfplusZi=read.csv("/home/john/pari/Zplus13p4aa_EP_res_1p7_0_m750_p750_537upwards_spacing_p01_imag.csv",header=FALSE,colClasses = c("character"));
dfplusZi$V2=as.numeric(gsub(" ","",dfplusZi$V2));
dfplusZi=dfplusZi[order(as.numeric(dfplusZi$V1)),]

dfreal=dfplusZ;dfimag=dfplusZi

min_val=min(as.numeric(dfreal$V1));max_val=max(as.numeric(dfreal$V1))
dfimag=dfimag[(dfimag$V1 %in% dfreal$V1),]


fft_plusZ = stats::fft(dfreal$V2+1i*dfimag$V2)

dfreal_plus=dfreal
dfimag_plus=dfimag

lenf2=length(fft_plusZ)
delta_fft2=max(as.numeric(substr(dfreal$V1,1,12)))-min(as.numeric(substr(dfreal$V1,1,12)))
n=lenf2

#second component of riemann-siegel formula based on first quiescent region
#EP(1-(sigma+i*t))*chi(sigma+i*t)*exp(i*theta)
#using minimum 23 primes in prodeuler pari-gp function

dfminusZ=read.csv("/home/john/pari/Zminus13p4aa_EP_res_1p7_0_m750_p750_537upwards_spacing_p01_real.csv",header=FALSE,colClasses = c("character"));
dfminusZ$V2=as.numeric(gsub(" ","",dfminusZ$V2));
dfminusZ=dfminusZ[order(as.numeric(dfminusZ$V1)),]

dfminusZi=read.csv("/home/john/pari/Zminus13p4aa_EP_res_1p7_0_m750_p750_537upwards_spacing_p01_imag.csv",header=FALSE,colClasses = c("character"));
dfminusZi$V2=as.numeric(gsub(" ","",dfminusZi$V2));
dfminusZi=dfminusZi[order(as.numeric(dfminusZi$V1)),]

dfreal=dfminusZ;dfimag=dfminusZi

min_val=min(as.numeric(dfreal$V1));max_val=max(as.numeric(dfreal$V1))
dfimag=dfimag[dfimag$V1 %in% dfreal$V1,]

fft_minusZ = stats::fft(dfreal$V2+1i*dfimag$V2)

dfreal_minus=dfreal
dfimag_minus=dfimag

lenf=dim(dfreal)[1]

n=dim(dfreal)[1]

min_freq=min(as.numeric(substr(dfreal$V1,1,12)))
max_freq=max(as.numeric(substr(dfreal$V1,1,12)))

delta_fft=max_freq-min_freq
mid=floor(delta_fft/2/pi*log(floor(sqrt((max_freq/2/pi/c(1))^2*13))))

fft_hybrid=c(1/2*(fft_plusZ[1]+fft_minusZ[1]),(fft_plusZ)[2:(ceiling(n/2)+0)],1/2*(fft_plusZ[ceiling(n/2)+1]+fft_minusZ[ceiling(n/2)+1]),fft_minusZ[(ceiling(n/2)+2):n])

yspan=range(abs(fft_hybrid))
plot(c(-floor(n/2):(ceiling(n/2)-1))*2*pi/delta_fft,c(abs(fft_plusZ)[(ceiling(n/2)+1):n],abs(fft_plusZ)[1:(ceiling(n/2))]),xlim=c(-11,11),typ="l",xaxt="n",xlab="angular frequency (radians per sec)",ylab="|Amplitude|",main="fourier transform spectra of the first component of \n the partial Euler product Riemann-Siegel Z function \n using truncation at N1=sqrt((max(t)/2/pi)^2*13).",ylim=yspan)
abline(v=seq(-20,20,l=41),h=seq(0,1e5,l=6),lty=3,col="gray")
axis(1,at=seq(-20,20,l=41))
abline(v=-1/2*log(((max_freq)/pi/2)^2*13/c(1:2)^2)-0,col=rgb(1,0,0,0.3))
abline(v=1/2*log(((max_freq)/pi/2)^2*13/c(1:2)^2)-0,col=rgb(1,0,0,0.3))


yspan=range(abs(fft_hybrid))
plot(c(-floor(n/2):-1)*2*pi/delta_fft,rep(0,floor(n/2)),xlim=c(-11,11),typ="l",xaxt="n",xlab="angular frequency (radians per sec)",ylab="|Amplitude|",main="piecewise fourier transform \n spectra filtering of the first component positive frequencies \n and phase conjugate reflection imputation of the negative freq half.",col=4,ylim=yspan)
lines(c(0:(ceiling(n/2)-1))*2*pi/delta_fft,c(abs(fft_plusZ)[1:(ceiling(n/2))]),col=3)
abline(v=seq(-20,20,l=41),h=seq(0,1e5,l=6),lty=3,col="gray")
axis(1,at=seq(-20,20,l=41))
abline(v=-1/2*log(((max_freq)/pi/2)^2*13/c(1:2)^2)-0,col=rgb(1,0,0,0.3))
abline(v=1/2*log(((max_freq)/pi/2)^2*13/c(1:2)^2)-0,col=rgb(1,0,0,0.3))


n=dim(dfZ)[1]
min_freq=min(as.numeric(dfZ$V1))
max_freq=max(as.numeric(dfZ$V1))
delta_fft=max_freq-min_freq
mid=floor(delta_fft/2/pi*log(floor(sqrt((max_freq/2/pi/c(1))^2*13))))

plot(c(-floor(n/2):(ceiling(n/2)-1))*2*pi/delta_fft,c(abs(fft_zeta_Zfn)[(ceiling(n/2)+1):n],abs(fft_zeta_Zfn)[1:(ceiling(n/2))]),xlim=c(-11,11),typ="l",xaxt="n",xlab="angular frequency (radians per sec)",ylab="|Amplitude|",main="fourier transform spectra of the true Riemann-Siegel Z function.",cex.main=0.9)
abline(v=seq(-20,20,l=41),h=seq(0,1e5,l=6),lty=3,col="gray")
axis(1,at=seq(-20,20,l=41))
abline(v=-1/2*log(((max_freq)/pi/2)^2*13/c(1:2)^2)-0,col=rgb(1,0,0,0.3))
abline(v=1/2*log(((max_freq)/pi/2)^2*13/c(1:2)^2)-0,col=rgb(1,0,0,0.3))

n=dim(dfZ)[1]
min_freq=min(as.numeric(dfZ$V1))
max_freq=max(as.numeric(dfZ$V1))
delta_fft=max_freq-min_freq
mid=floor(delta_fft/2/pi*log(floor(sqrt((max_freq/2/pi/c(1))^2*13))))



yspan=range(abs(fft_hybrid))
plot(c(-floor(n/2):-1)*2*pi/delta_fft,abs(c(1/2*(fft_plusZ[ceiling(n/2)+1]+fft_minusZ[ceiling(n/2)+1]),fft_minusZ[(ceiling(n/2)+2):n])),xlim=c(-11,11),typ="l",xaxt="n",xlab="angular frequency (radians per sec)",ylab="|Amplitude|",main="piecewise fourier transform spectra filtering \n and splicing of the first component positive frequencies \n and the second component negative frequencies.",col=4,ylim=yspan)
lines(c(0:(floor(n/2)))*2*pi/delta_fft,abs(c(1/2*(fft_plusZ[1]+fft_minusZ[1]),(fft_plusZ)[2:(ceiling(n/2)+0)])),col=3)
abline(v=seq(-20,20,l=41),h=seq(0,1e5,l=6),lty=3,col="gray")
axis(1,at=seq(-20,20,l=41))
abline(v=-1/2*log(((max_freq)/pi/2)^2*13/c(1:2)^2)-0,col=rgb(1,0,0,0.3))
abline(v=1/2*log(((max_freq)/pi/2)^2*13/c(1:2)^2)-0,col=rgb(1,0,0,0.3))


n=dim(dfminusZ)[1]
min_freq=min(as.numeric(dfminusZ$V1))
max_freq=max(as.numeric(dfminusZ$V1))
delta_fft=max_freq-min_freq
mid=floor(delta_fft/2/pi*log(floor(sqrt((max_freq/2/pi/c(1))^2*13))))

plot(c(-floor(n/2):(ceiling(n/2)-1))*2*pi/delta_fft,c(abs(fft_minusZ)[(ceiling(n/2)+1):n],abs(fft_minusZ)[1:(ceiling(n/2))]),xlim=c(-11,11),typ="l",xaxt="n",xlab="angular frequency (radians per sec)",ylab="|Amplitude|",main="fourier transform spectra of the second component of \n the partial Euler product Riemann-Siegel Z function \n using truncation at N1=sqrt((max(t)/2/pi)^2*13).")
abline(v=seq(-20,20,l=41),h=seq(0,1e5,l=6),lty=3,col="gray")
axis(1,at=seq(-20,20,l=41))
abline(v=-1/2*log(((max_freq)/pi/2)^2*13/c(1:2)^2)-0,col=rgb(1,0,0,0.3))
abline(v=1/2*log(((max_freq)/pi/2)^2*13/c(1:2)^2)-0,col=rgb(1,0,0,0.3))

yspan=range(abs(fft_hybrid))
plot(c(-floor(n/2):-1)*2*pi/delta_fft,c(abs(fft_minusZ)[(ceiling(n/2)+1):n]),xlim=c(-11,11),typ="l",xaxt="n",xlab="angular frequency (radians per sec)",ylab="|Amplitude|",main="piecewise fourier transform \n spectra filtering of the second component negative frequencies \n and phase conjugate reflection imputation of the positive freq half.",col=4,ylim=yspan)
lines(c(0:(floor(n/2)))*2*pi/delta_fft,rep(0,ceiling(n/2)),col=3)
abline(v=seq(-20,20,l=41),h=seq(0,1e5,l=6),lty=3,col="gray")
axis(1,at=seq(-20,20,l=41))
abline(v=-1/2*log(((max_freq)/pi/2)^2*13/c(1:2)^2)-0,col=rgb(1,0,0,0.3))
abline(v=1/2*log(((max_freq)/pi/2)^2*13/c(1:2)^2)-0,col=rgb(1,0,0,0.3))

```



\clearpage

```{r Zfn13p4aaModularFormLfunctionoveraninterval_anditsfouriertransform_0_pm750_1p7, echo=FALSE, fig.cap="Lefthand panel - True Z function shown in magenta (cyan) for real (imaginary) parts and spectral filtered based EP approximation shown in black (blue) for real (imaginary) parts, Right hand panel - Error in the real(Z) EP approximation. A comparison of the Riemann-Siegel Z function analogue of the L-function 2-13-1.1-c3-0-2 (LMFDB label) and spectrally filtered partial Euler Product (using truncation at $\\max (P,\\sqrt{((\\frac{t}{2\\pi})^2\\cdot 13}) $) in the complex plane at $\\sigma=1.7$ for the interval t=(-750,750) where $P_{min}={1,2,50,537}$ for rows 1-4. ", out.width = c("49%","49%"), fig.show = "hold",  fig.height=4.5, warning=FALSE, cache=TRUE}


# Riemann-Siegel Z function of L32 function on critical line
# values recorded every .01 spacing in interval [-750,+750]

dfZ=read.csv("/home/john/pari/Z13p4aa_res_1p7_0_m750_p750_spacing_p01_real.csv",header=FALSE,colClasses = c("character"));
dfZ$V2=as.numeric(gsub(" ","",dfZ$V2));
dfZ=dfZ[order(as.numeric(dfZ$V1)),]

dfZi=read.csv("/home/john/pari/Z13p4aa_res_1p7_0_m750_p750_spacing_p01_imag.csv",header=FALSE,colClasses = c("character"));
dfZi$V2=as.numeric(gsub(" ","",dfZi$V2));
dfZi=dfZi[order(as.numeric(dfZi$V1)),]


#Riemann-Siegel Z function of truncated Euler product at first quiescent region
#first component of riemann-siegel formula based on first quiescent region
#EP(sigma+i*t)*exp(i*theta)
#using 0 extra integers in prodeuler pari-gp function

dfplusZ=read.csv("/home/john/pari/Zplus13p4aa_EP_res_1p7_0_m750_p750_0extra_spacing_p01_real.csv",header=FALSE,colClasses = c("character"));
dfplusZ$V2=as.numeric(gsub(" ","",dfplusZ$V2));
dfplusZ=dfplusZ[order(as.numeric(dfplusZ$V1)),]

dfplusZi=read.csv("/home/john/pari/Zplus13p4aa_EP_res_1p7_0_m750_p750_0extra_spacing_p01_imag.csv",header=FALSE,colClasses = c("character"));
dfplusZi$V2=as.numeric(gsub(" ","",dfplusZi$V2));
dfplusZi=dfplusZi[order(as.numeric(dfplusZi$V1)),]

dfreal=dfplusZ;dfimag=dfplusZi

min_val=min(as.numeric(dfreal$V1));max_val=max(as.numeric(dfreal$V1))
dfimag=dfimag[(dfimag$V1 %in% dfreal$V1),]


fft_plusZ = stats::fft(dfreal$V2+1i*dfimag$V2)

dfreal_plus=dfreal
dfimag_plus=dfimag

lenf2=length(fft_plusZ)
delta_fft2=max(as.numeric(substr(dfreal$V1,1,12)))-min(as.numeric(substr(dfreal$V1,1,12)))
n=lenf2

#second component of riemann-siegel formula based on first quiescent region
#EP(1-(sigma+i*t))*chi(sigma+i*t)*exp(i*theta)
#using 0 extra integers in prodeuler pari-gp function

dfminusZ=read.csv("/home/john/pari/Zminus13p4aa_EP_res_1p7_0_m750_p750_0extra_spacing_p01_real.csv",header=FALSE,colClasses = c("character"));
dfminusZ$V2=as.numeric(gsub(" ","",dfminusZ$V2));
dfminusZ=dfminusZ[order(as.numeric(dfminusZ$V1)),]

dfminusZi=read.csv("/home/john/pari/Zminus13p4aa_EP_res_1p7_0_m750_p750_0extra_spacing_p01_imag.csv",header=FALSE,colClasses = c("character"));
dfminusZi$V2=as.numeric(gsub(" ","",dfminusZi$V2));
dfminusZi=dfminusZi[order(as.numeric(dfminusZi$V1)),]

dfreal=dfminusZ;dfimag=dfminusZi

min_val=min(as.numeric(dfreal$V1));max_val=max(as.numeric(dfreal$V1))
dfimag=dfimag[dfimag$V1 %in% dfreal$V1,]

fft_minusZ = stats::fft(dfreal$V2+1i*dfimag$V2)

dfreal_minus=dfreal
dfimag_minus=dfimag

lenf=dim(dfreal)[1]

n=dim(dfreal)[1]

min_freq=min(as.numeric(substr(dfreal$V1,1,12)))
max_freq=max(as.numeric(substr(dfreal$V1,1,12)))
delta_fft=max(as.numeric(substr(dfreal$V1,1,12)))-min(as.numeric(substr(dfreal$V1,1,12)))


#symmetric formula when sigma=0.5
#for spectral filtering of first quiescent region based Euler Product

fft_hybrid=c(1/2*(fft_plusZ[1]+fft_minusZ[1]),(fft_plusZ)[2:(ceiling(n/2)+0)],1/2*(fft_plusZ[ceiling(n/2)+1]+fft_minusZ[ceiling(n/2)+1]),fft_minusZ[(ceiling(n/2)+2):n])
inv_hybrid=fft(fft_hybrid,inverse=TRUE)

yspan=range(Re(inv_hybrid)/n,Im(inv_hybrid)/n)
plot(as.numeric(substr(dfreal$V1,1,22)),Re(inv_hybrid)/n,typ="l",
     ylab="Z component",ylim=c(-15,15),xlab="t",main="Riemann Siegel Z function analogue (using spectral filtered Euler Product) of \n Modular form 13.4.a.a function using max(1,floor(1.25*sqrt((t/2/pi)^2*13))) in EP",xlim=c(-40,40)+0,col="black",cex.main=0.8);grid(col="gray")
lines(as.numeric(substr(dfimag$V1,1,22)),Im(inv_hybrid)/n,col="blue")
lines(as.numeric(substr(dfZ$V1,1,22)),Re(dfZ$V2),col="magenta",lty=2)
lines(as.numeric(substr(dfZ$V1,1,22)),Re(dfZi$V2),col="cyan",lty=2)
lines(rep((2/1.25)^1*2*pi/sqrt(13),2),c(-8,-5),lty=2,col="blue")
lines(rep((3/1.25)^1*2*pi/sqrt(13),2),c(5,8),lty=2,col="blue")
lines(-rep((2/1.25)^1*2*pi/sqrt(13),2),c(-8,-5),lty=2,col="blue")
lines(-rep((3/1.25)^1*2*pi/sqrt(13),2),c(5,8),lty=2,col="blue")
text(x=c(-1,1)*(2/1.25)^1*2*pi/sqrt(13),y=-9,"2")
text(x=c(-1,1)*(3/1.25)^1*2*pi/sqrt(13),y=9,"3")
text(x=-10,y=-11,"t value when next prime is included in EP",cex=0.7)

plot(as.numeric(substr(dfreal$V1,1,22)),Re(inv_hybrid)/n-Re(dfZ$V2),typ="l",xlab="t",ylab="Error",main="Error in real(Z) component (using spectral filtered Euler Product approximation) of \n Modular form 13.4.a.a function using max(1,floor(1.25*sqrt((t/2/pi)^2*13))) in EP",col="gray",cex.main=0.8);grid(col="gray2")

#Riemann-Siegel Z function of truncated Euler product at first quiescent region
#first component of riemann-siegel formula based on first quiescent region
#EP(sigma+i*t)*exp(i*theta)
#using 0 extra integers in prodeuler pari-gp function

dfplusZ=read.csv("/home/john/pari/Zplus13p4aa_EP_res_1p7_0_m750_p750_2upwards_spacing_p01_real.csv",header=FALSE,colClasses = c("character"));
dfplusZ$V2=as.numeric(gsub(" ","",dfplusZ$V2));
dfplusZ=dfplusZ[order(as.numeric(dfplusZ$V1)),]

dfplusZi=read.csv("/home/john/pari/Zplus13p4aa_EP_res_1p7_0_m750_p750_2upwards_spacing_p01_imag.csv",header=FALSE,colClasses = c("character"));
dfplusZi$V2=as.numeric(gsub(" ","",dfplusZi$V2));
dfplusZi=dfplusZi[order(as.numeric(dfplusZi$V1)),]

dfreal=dfplusZ;dfimag=dfplusZi

min_val=min(as.numeric(dfreal$V1));max_val=max(as.numeric(dfreal$V1))
dfimag=dfimag[(dfimag$V1 %in% dfreal$V1),]


fft_plusZ = stats::fft(dfreal$V2+1i*dfimag$V2)

dfreal_plus=dfreal
dfimag_plus=dfimag

lenf2=length(fft_plusZ)
delta_fft2=max(as.numeric(substr(dfreal$V1,1,12)))-min(as.numeric(substr(dfreal$V1,1,12)))
n=lenf2

#second component of riemann-siegel formula based on first quiescent region
#EP(1-(sigma+i*t))*chi(sigma+i*t)*exp(i*theta)
#using 0 extra integers in prodeuler pari-gp function

dfminusZ=read.csv("/home/john/pari/Zminus13p4aa_EP_res_1p7_0_m750_p750_2upwards_spacing_p01_real.csv",header=FALSE,colClasses = c("character"));
dfminusZ$V2=as.numeric(gsub(" ","",dfminusZ$V2));
dfminusZ=dfminusZ[order(as.numeric(dfminusZ$V1)),]

dfminusZi=read.csv("/home/john/pari/Zminus13p4aa_EP_res_1p7_0_m750_p750_2upwards_spacing_p01_imag.csv",header=FALSE,colClasses = c("character"));
dfminusZi$V2=as.numeric(gsub(" ","",dfminusZi$V2));
dfminusZi=dfminusZi[order(as.numeric(dfminusZi$V1)),]

dfreal=dfminusZ;dfimag=dfminusZi

min_val=min(as.numeric(dfreal$V1));max_val=max(as.numeric(dfreal$V1))
dfimag=dfimag[dfimag$V1 %in% dfreal$V1,]

fft_minusZ = stats::fft(dfreal$V2+1i*dfimag$V2)

dfreal_minus=dfreal
dfimag_minus=dfimag

lenf=dim(dfreal)[1]

n=dim(dfreal)[1]

min_freq=min(as.numeric(substr(dfreal$V1,1,12)))
max_freq=max(as.numeric(substr(dfreal$V1,1,12)))
delta_fft=max(as.numeric(substr(dfreal$V1,1,12)))-min(as.numeric(substr(dfreal$V1,1,12)))


#symmetric formula when sigma=0.5
#for spectral filtering of first quiescent region based Euler Product

fft_hybrid=c(1/2*(fft_plusZ[1]+fft_minusZ[1]),(fft_plusZ)[2:(ceiling(n/2)+0)],1/2*(fft_plusZ[ceiling(n/2)+1]+fft_minusZ[ceiling(n/2)+1]),fft_minusZ[(ceiling(n/2)+2):n])
inv_hybrid=fft(fft_hybrid,inverse=TRUE)

yspan=range(Re(inv_hybrid)/n,Im(inv_hybrid)/n)
plot(as.numeric(substr(dfreal$V1,1,22)),Re(inv_hybrid)/n,typ="l",
     ylab="Z component",ylim=c(-15,15),xlab="t",main="Riemann Siegel Z function analogue (using spectral filtered Euler Product) of \n Modular form 13.4.a.a L function using max(2,floor(1.25*sqrt((t/2/pi)^2*13))) in EP",xlim=c(-40,40)+0,col="black",cex.main=0.8);grid(col="gray")
lines(as.numeric(substr(dfimag$V1,1,22)),Im(inv_hybrid)/n,col="blue")
lines(as.numeric(substr(dfZ$V1,1,22)),Re(dfZ$V2),col="magenta",lty=2)
lines(as.numeric(substr(dfZ$V1,1,22)),Re(dfZi$V2),col="cyan",lty=2)
lines(rep((3/1.25)^1*2*pi/sqrt(13),2),c(5,8),lty=2,col="blue")
lines(-rep((3/1.25)^1*2*pi/sqrt(13),2),c(5,8),lty=2,col="blue")
text(x=c(-1,1)*(3/1.25)^1*2*pi/sqrt(13),y=9,"3")
text(x=0,y=11,"t value when next prime is included in EP",cex=0.7)

plot(as.numeric(substr(dfreal$V1,1,22)),Re(inv_hybrid)/n-Re(dfZ$V2),typ="l",xlab="t",ylab="Error",main="Error in real(Z) component (using spectral filtered Euler Product approximation) of \n Modular form 13.4.a.a L function using max(2,floor(1.25*sqrt((t/2/pi)^2*13))) in EP",col="gray",cex.main=0.8);grid(col="gray2")

#Riemann-Siegel Z function of truncated Euler product at first quiescent region
#first component of riemann-siegel formula based on first quiescent region
#EP(sigma+i*t)*exp(i*theta)
#using 0 extra integers in prodeuler pari-gp function

dfplusZ=read.csv("/home/john/pari/Zplus13p4aa_EP_res_1p7_0_m750_p750_50upwards_spacing_p01_real.csv",header=FALSE,colClasses = c("character"));
dfplusZ$V2=as.numeric(gsub(" ","",dfplusZ$V2));
dfplusZ=dfplusZ[order(as.numeric(dfplusZ$V1)),]

dfplusZi=read.csv("/home/john/pari/Zplus13p4aa_EP_res_1p7_0_m750_p750_50upwards_spacing_p01_imag.csv",header=FALSE,colClasses = c("character"));
dfplusZi$V2=as.numeric(gsub(" ","",dfplusZi$V2));
dfplusZi=dfplusZi[order(as.numeric(dfplusZi$V1)),]

dfreal=dfplusZ;dfimag=dfplusZi

min_val=min(as.numeric(dfreal$V1));max_val=max(as.numeric(dfreal$V1))
dfimag=dfimag[(dfimag$V1 %in% dfreal$V1),]


fft_plusZ = stats::fft(dfreal$V2+1i*dfimag$V2)

dfreal_plus=dfreal
dfimag_plus=dfimag

lenf2=length(fft_plusZ)
delta_fft2=max(as.numeric(substr(dfreal$V1,1,12)))-min(as.numeric(substr(dfreal$V1,1,12)))
n=lenf2

#second component of riemann-siegel formula based on first quiescent region
#EP(1-(sigma+i*t))*chi(sigma+i*t)*exp(i*theta)
#using 0 extra integers in prodeuler pari-gp function

dfminusZ=read.csv("/home/john/pari/Zminus13p4aa_EP_res_1p7_0_m750_p750_50upwards_spacing_p01_real.csv",header=FALSE,colClasses = c("character"));
dfminusZ$V2=as.numeric(gsub(" ","",dfminusZ$V2));
dfminusZ=dfminusZ[order(as.numeric(dfminusZ$V1)),]

dfminusZi=read.csv("/home/john/pari/Zminus13p4aa_EP_res_1p7_0_m750_p750_50upwards_spacing_p01_imag.csv",header=FALSE,colClasses = c("character"));
dfminusZi$V2=as.numeric(gsub(" ","",dfminusZi$V2));
dfminusZi=dfminusZi[order(as.numeric(dfminusZi$V1)),]

dfreal=dfminusZ;dfimag=dfminusZi

min_val=min(as.numeric(dfreal$V1));max_val=max(as.numeric(dfreal$V1))
dfimag=dfimag[dfimag$V1 %in% dfreal$V1,]

fft_minusZ = stats::fft(dfreal$V2+1i*dfimag$V2)

dfreal_minus=dfreal
dfimag_minus=dfimag

lenf=dim(dfreal)[1]

n=dim(dfreal)[1]

min_freq=min(as.numeric(substr(dfreal$V1,1,12)))
max_freq=max(as.numeric(substr(dfreal$V1,1,12)))
delta_fft=max(as.numeric(substr(dfreal$V1,1,12)))-min(as.numeric(substr(dfreal$V1,1,12)))


#symmetric formula when sigma=0.5
#for spectral filtering of first quiescent region based Euler Product

fft_hybrid=c(1/2*(fft_plusZ[1]+fft_minusZ[1]),(fft_plusZ)[2:(ceiling(n/2)+0)],1/2*(fft_plusZ[ceiling(n/2)+1]+fft_minusZ[ceiling(n/2)+1]),fft_minusZ[(ceiling(n/2)+2):n])
inv_hybrid=fft(fft_hybrid,inverse=TRUE)

yspan=range(Re(inv_hybrid)/n,Im(inv_hybrid)/n)
plot(as.numeric(substr(dfreal$V1,1,22)),Re(inv_hybrid)/n,typ="l",
     ylab="Z component",ylim=c(-15,15),xlab="t",main="Riemann Siegel Z function analogue (using spectral filtered Euler Product) of \n Modular form 13.4.a.a function using max(50,floor(1.25*sqrt((t/2/pi)^2*13))) in EP",xlim=c(-40,40)+0,col="black",cex.main=0.8);grid(col="gray")
lines(as.numeric(substr(dfimag$V1,1,22)),Im(inv_hybrid)/n,col="blue")
lines(as.numeric(substr(dfZ$V1,1,22)),Re(dfZ$V2),col="magenta",lty=2)
lines(as.numeric(substr(dfZ$V1,1,22)),Re(dfZi$V2),col="cyan",lty=2)

plot(as.numeric(substr(dfreal$V1,1,22)),Re(inv_hybrid)/n-Re(dfZ$V2),typ="l",xlab="t",ylab="Error",main="Error in real(Z) component (using spectral filtered Euler Product approximation) of \n Modular form 13.4.a.a function using max(5,floor(1.25*sqrt((t/2/pi)^2*13))) in EP",col="gray",cex.main=0.8);grid(col="gray2")
lines(-rep((53/1.25)^1*2*pi/sqrt(13),2),c(-6,-2),lty=2,col="blue")
lines(rep((53/1.25)^1*2*pi/sqrt(13),2),c(2,6),lty=2,col="blue")
text(x=-(53/1.25)^1*2*pi/sqrt(13),y=-8,"53")
text(x=(53/1.25)^1*2*pi/sqrt(13),y=8,"53")
text(x=0,y=-12,"t value when next prime is included in EP",cex=0.7)

#Riemann-Siegel Z function of truncated Euler product at first quiescent region
#first component of riemann-siegel formula based on first quiescent region
#EP(sigma+i*t)*exp(i*theta)
#using 0 extra integers in prodeuler pari-gp function

dfplusZ=read.csv("/home/john/pari/Zplus13p4aa_EP_res_1p7_0_m750_p750_537upwards_spacing_p01_real.csv",header=FALSE,colClasses = c("character"));
dfplusZ$V2=as.numeric(gsub(" ","",dfplusZ$V2));
dfplusZ=dfplusZ[order(as.numeric(dfplusZ$V1)),]

dfplusZi=read.csv("/home/john/pari/Zplus13p4aa_EP_res_1p7_0_m750_p750_537upwards_spacing_p01_imag.csv",header=FALSE,colClasses = c("character"));
dfplusZi$V2=as.numeric(gsub(" ","",dfplusZi$V2));
dfplusZi=dfplusZi[order(as.numeric(dfplusZi$V1)),]

dfreal=dfplusZ;dfimag=dfplusZi

min_val=min(as.numeric(dfreal$V1));max_val=max(as.numeric(dfreal$V1))
dfimag=dfimag[(dfimag$V1 %in% dfreal$V1),]


fft_plusZ = stats::fft(dfreal$V2+1i*dfimag$V2)

dfreal_plus=dfreal
dfimag_plus=dfimag

lenf2=length(fft_plusZ)
delta_fft2=max(as.numeric(substr(dfreal$V1,1,12)))-min(as.numeric(substr(dfreal$V1,1,12)))
n=lenf2

#second component of riemann-siegel formula based on first quiescent region
#EP(1-(sigma+i*t))*chi(sigma+i*t)*exp(i*theta)
#using 0 extra integers in prodeuler pari-gp function

dfminusZ=read.csv("/home/john/pari/Zminus13p4aa_EP_res_1p7_0_m750_p750_537upwards_spacing_p01_real.csv",header=FALSE,colClasses = c("character"));
dfminusZ$V2=as.numeric(gsub(" ","",dfminusZ$V2));
dfminusZ=dfminusZ[order(as.numeric(dfminusZ$V1)),]

dfminusZi=read.csv("/home/john/pari/Zminus13p4aa_EP_res_1p7_0_m750_p750_537upwards_spacing_p01_imag.csv",header=FALSE,colClasses = c("character"));
dfminusZi$V2=as.numeric(gsub(" ","",dfminusZi$V2));
dfminusZi=dfminusZi[order(as.numeric(dfminusZi$V1)),]

dfreal=dfminusZ;dfimag=dfminusZi

min_val=min(as.numeric(dfreal$V1));max_val=max(as.numeric(dfreal$V1))
dfimag=dfimag[dfimag$V1 %in% dfreal$V1,]

fft_minusZ = stats::fft(dfreal$V2+1i*dfimag$V2)

dfreal_minus=dfreal
dfimag_minus=dfimag

lenf=dim(dfreal)[1]

n=dim(dfreal)[1]

min_freq=min(as.numeric(substr(dfreal$V1,1,12)))
max_freq=max(as.numeric(substr(dfreal$V1,1,12)))
delta_fft=max(as.numeric(substr(dfreal$V1,1,12)))-min(as.numeric(substr(dfreal$V1,1,12)))


#symmetric formula when sigma=0.5
#for spectral filtering of first quiescent region based Euler Product

fft_hybrid=c(1/2*(fft_plusZ[1]+fft_minusZ[1]),(fft_plusZ)[2:(ceiling(n/2)+0)],1/2*(fft_plusZ[ceiling(n/2)+1]+fft_minusZ[ceiling(n/2)+1]),fft_minusZ[(ceiling(n/2)+2):n])
inv_hybrid=fft(fft_hybrid,inverse=TRUE)

yspan=range(Re(inv_hybrid)/n,Im(inv_hybrid)/n)
plot(as.numeric(substr(dfreal$V1,1,22)),Re(inv_hybrid)/n,typ="l",
     ylab="Z component",ylim=c(-15,15),xlab="t",main="Riemann Siegel Z function analogue (using spectral filtered Euler Product) of \n Modular form 13.4.a.a  L-function using max(537,floor(1.25*sqrt((t/2/pi)^2*13))) in EP",xlim=c(-40,40)+0,col="black",cex.main=0.8);grid(col="gray")
lines(as.numeric(substr(dfimag$V1,1,22)),Im(inv_hybrid)/n,col="blue")
lines(as.numeric(substr(dfZ$V1,1,22)),Re(dfZ$V2),col="magenta",lty=2)
lines(as.numeric(substr(dfZ$V1,1,22)),Re(dfZi$V2),col="cyan",lty=2)


plot(as.numeric(substr(dfreal$V1,1,22)),Re(inv_hybrid)/n-Re(dfZ$V2),typ="l",xlab="t",ylab="Error",main="Error in real(Z) component (using spectral filtered Euler Product approximation) of \n Modular form 13.4.a.a function using max(537,floor(1.25*sqrt((t/2/pi)^2*13))) in EP",col="gray",cex.main=0.8);grid(col="gray")

```

\clearpage 


## Conclusions 


The above fourier analysis based partial Euler Product approximation of the Riemann-Siegel Z function analogues of L-function without poles provides examples of standalone useful accuracy performance within the critical strip around the real axis. However numerical issues may arise in low precision fourier analysis further away from the critical line. 

In the appendix, a counterexample shows standalone accuracy of the partial Euler Product approximation of the Riemann-Siegel Z function analogues of L-function is likely not possible near a L-function pole without adding a correction term modelling the pole behaviour.  



\newpage

## References

1. Martin, J.P.D. "A useful approximation of the Riemann Zeta function away from the real axis using spectral filtering of the partial Euler product" (2025)
http://dx.doi.org/10.6084/m9.figshare.28528652

2. Martin, J.P.D. "Crucial steps for robust first quiescent region truncated partial Euler Product based approximations of closely spaced Riemann Zeta function non-trivial zeroes" (2025)
http://dx.doi.org/10.6084/m9.figshare.29095232

3. Martin, J.P.D. "Examples of spectrally filtered first quiescent region truncated partial Euler Product based approximations of Riemann Siegel Z functions for different L-functions and the two Davenport-Heilbronn 5-periodic functions on the critical line away from the real axis" (2025)
http://dx.doi.org/10.6084/m9.figshare.29577545

4. Edwards, H.M. (1974). Riemann's zeta function. Pure and Applied Mathematics 58. New York-London: Academic Press. ISBN 0-12-232750-0. Zbl 0315.10035.

5. Riemann, Bernhard (1859). "?ber die Anzahl der Primzahlen unter einer gegebenen Gr?sse". Monatsberichte der Berliner Akademie.. In Gesammelte Werke, Teubner, Leipzig (1892), Reprinted by Dover, New York (1953).

6. Titchmarsh, E.C. (1986) The Theory of the Riemann Zeta Function. 2nd Revised Heath-Brown, D.R. ) Edition, Oxford University Press, Oxford.

7. The LMFDB Collaboration, The L-functions and Modular Forms Database, http://www.lmfdb.org

8. Berry, M. V. "The Riemann-Siegel Expansion for the Zeta Function: High Orders and Remainders." Proc. Roy. Soc. London A 450, 439-462, 1995.

9. J. Arias De Reyna, "High precision computation of Riemann's Zeta function by the Riemann-Siegel formula", Mathematics of Computation Vol 80, no. 274, 2011, Pages 995–1009

10. The PARI~Group, PARI/GP version 2.12.0, Univ. Bordeaux, 2018,
\url{http://pari.math.u-bordeaux.fr/}.

11. R Core Team (2017). R: A language and environment for statistical computing.
R Foundation for Statistical Computing, Vienna, Austria. \url{https://www.R-project.org/}.

12. RStudio Team (2015). RStudio: Integrated Development for R. RStudio, Inc., Boston, MA \url{http://www.rstudio.com/}.


\newpage

## Appendix A - Examining the spectral filtered first quiescent region partial Euler Product approximation performance about the real axis

The first degree L function, Riemann Zeta L function 1-1-1.1-r0-0-0  [7] under the arithmetic version of the L-function is written in dirichlet series form as

\begin{equation}
\zeta(s) = \sum_{k=1}^{\infty}\left(\frac{1}{k^s}\right)
\end{equation}

The above infinite dirichlet series is only convergent for $\Re(s) > 1$ with its known non-trivial zeroes (so far) lying on the critical line $s=0.5+I\cdot t$

The Riemann Zeta function is defined [1-3], in the complex plane by the integral 

\begin{equation}
\zeta(s) = \frac{\prod(-s)}{2\pi i}\int_{C_{\epsilon,\delta}} \frac{(-x)^s}{(e^{x}-1)x}dx
\end{equation}

where $s \thinspace \epsilon \thinspace \mathbb{C}$ and $C_{\epsilon,\delta}$ is the contour about the imaginary poles.

The Riemann Zeta function has been shown to obey the functional equation  [4-7]

\begin{align}
\zeta(s) &= \mychi(s)\zeta(1-s) \\
&= 2^s\pi^{s-1}sin(\frac{\pi s}{2})\Gamma(1-s)\zeta(1-s)
\end{align}

The (normalised) extended Riemann Siegel Theta function for the Riemann Zeta L-function is given by

\begin{align}
\theta_{\zeta}(s) &= -\frac{1}{2}imag\left[(s-1/2)\cdot\log(\pi)+lngamma((1-s)/2)-lngamma(s/2)\right]
\end{align}

The Riemann Zeta L-function is a degree 1 L-function (d=1) and its conductor value is 1  [7]. Hence the first quiescent region of the dirichlet series of $\zeta(s)$ is given by

\begin{equation}
N_1 = \left\lfloor \sqrt{\left(\frac{t}{2\pi}\right)^1\cdot 1} \right\rfloor = \left\lfloor \sqrt{\frac{t}{2\pi}} \right\rfloor
\end{equation}

The function of interest to be approximated by partial Euler Products is the extended Riemann-Siegel Z function of the Riemann Zeta L-function across the complex plane

\begin{equation}
Z_{ext\zeta}(s) = e^{I\theta_{ext\zeta}(t)}\zeta(s)
\end{equation}

where $\sqrt{\zeta(s)\zeta(1-s)|\chi(s)|}$ is an alternate (but discontinuous) expression for the extended Riemann-Siegel Z function.

The zeroth order Riemann-Siegel formula for the Riemann-Siegel Z function analogue of the Riemann Zeta L-function using partial Euler products is used as the basis of the approximation

\begin{align}
Z_{ext\zeta}(s)_{EP} &\approx EP_{RS1,\zeta}(s,\beta=1.25) \nonumber \\ &+ EP_{RS2,\zeta}(s,\beta=1.25) + ... \qquad t \rightarrow \infty
\end{align}

using (i) equations (8) & (9) and the known Euler factors  [7] of the $\zeta(s)$ L-function and (ii) $\beta=1.25$ is a small cushion factor in the truncation length of the included primes that is empirically observed to improve the quality of the fourier transform components of the finite Euler product arising nearby $N_1$ [2,3]. For the Riemann-Siegel Z function analogue the fourier transform components arising nearby $N_1$ are the fourier transform components namely surrounding (and including) the DC (zero) angular frequency.

Importantly, $\zeta(s)$ has known pole [4-7] at s=1 and thus $\zeta(s)$ serves as a counterexample of a L-function with a pole on to gauge the spectrally filtered partial Euler Product based approximation considered in this paper in the presence of a pole.

Figures 14, 15, 16 respectively illustrate in the lefthand panels, the performance of the averaged inverse fourier transform around the real axis compared to the real (imaginary) parts of the true Riemann-Siegel Z function shown in magenta (cyan) at the fourier grid spacing 0.01. That is, in the lefthand panels of figures 14, 15, 16 the following interval is displayed for five different values of the minimum prime in partial Euler product calculation $P_{min}=\left\lfloor 1.25\cdot \max\left(\{1,2,3,5,13\},\sqrt{(\frac{t}{2\pi})^d\cdot N_C}\right)\right\rfloor$ with each row (top to bottom) respectively belonging to the minimum prime value \{1,2,3,5,13\} which is active when t=0.

(i) $s=(0.5-I\cdot 40,0.5+I\cdot 40)$ 

(ii) $s=(0.9-I\cdot 40,0.9+I\cdot 40)$ and 

(iii) $s=(0.1-I\cdot 40,0.1+I\cdot 40)$ 

following the fourth step of the fourier analysis procedure described earlier in this paper. When $P_{min}=1$, the partial Euler Product returns the value unity.   

In the righthand panels, the approximation error (real(spectrally filtered, spliced inverse fourier transform based approximation)-real(Z)) is displayed over the entire span of the input spectra

(i) $s=(0.5-I\cdot 750,0.5+I\cdot 750)$ 

(ii) $s=(0.9-I\cdot 750,0.9+I\cdot 750)$ and 

(iii) $s=(0.1-I\cdot 750,0.1+I\cdot 750)$ 

It can be seen from figures 14, 15 and 16 that as the number of primes involved in the partial Euler Product approximation increases there is a growing error in the approximation with respect to the t=0 region.  







```{r Zfnzeta_andtruncatedEPfouriertransform_0_pm750, echo=FALSE, fig.cap="Lefthand panel - True Z function shown in magenta (cyan) for real (imaginary) parts and spectral filtered based EP approximation shown in black (blue) for real (imaginary) parts, Right hand panel - Error in the real(Z) EP approximation. A comparison of the Riemann-Siegel Z function of the Riemann Zeta L-function and spectrally filtered partial Euler Product (using truncation at $\\max (P,\\sqrt{((\\frac{t}{2\\pi})^1\\cdot 1}) $) in the complex plane at $\\sigma=0.5$ for the interval t=(-750,750) where $P_{min}={1,2,3,5,13}$ for rows 1-5. The approximation error around t=0 does not disappear by adding primes.", out.width = c("49%","49%"), fig.show = "hold",  fig.height=3.8, warning=FALSE, cache=TRUE}

# Riemann-Siegel Z function of Riemann Zeta function on critical line
# values recorded every .01 spacing in interval [-750,+750]

dfZ=read.csv("/home/john/pari/Zzeta_res_p5_0_m750_p750_spacing_p01_real.csv",header=FALSE,colClasses = c("character"));
dfZ$V2=as.numeric(gsub(" ","",dfZ$V2));
dfZ=dfZ[order(as.numeric(dfZ$V1)),]

dfZi=read.csv("/home/john/pari/Zzeta_res_p5_0_m750_p750_spacing_p01_imag.csv",header=FALSE,colClasses = c("character"));
dfZi$V2=as.numeric(gsub(" ","",dfZi$V2));
dfZi=dfZi[order(as.numeric(dfZi$V1)),]


#Riemann-Siegel Z function of truncated Euler product at first quiescent region
#first component of riemann-siegel formula based on first quiescent region
#EP(sigma+i*t)*exp(i*theta)
#using 0 extra integers in prodeuler pari-gp function

dfplusZ=read.csv("/home/john/pari/Zplus_EPonly_res_p5_0_m750_p750_0extra_spacing_p01_real.csv",header=FALSE,colClasses = c("character"));
dfplusZ$V2=as.numeric(gsub(" ","",dfplusZ$V2));
dfplusZ=dfplusZ[order(as.numeric(dfplusZ$V1)),]

dfplusZi=read.csv("/home/john/pari/Zplus_EPonly_res_p5_0_m750_p750_0extra_spacing_p01_imag.csv",header=FALSE,colClasses = c("character"));
dfplusZi$V2=as.numeric(gsub(" ","",dfplusZi$V2));
dfplusZi=dfplusZi[order(as.numeric(dfplusZi$V1)),]

dfreal=dfplusZ;dfimag=dfplusZi

min_val=min(as.numeric(dfreal$V1));max_val=max(as.numeric(dfreal$V1))
dfimag=dfimag[(dfimag$V1 %in% dfreal$V1),]


fft_plusZ = stats::fft(dfreal$V2+1i*dfimag$V2)

dfreal_plus=dfreal
dfimag_plus=dfimag

lenf2=length(fft_plusZ)
delta_fft2=max(as.numeric(substr(dfreal$V1,1,12)))-min(as.numeric(substr(dfreal$V1,1,12)))
n=lenf2

#second component of riemann-siegel formula based on first quiescent region
#EP(1-(sigma+i*t))*chi(sigma+i*t)*exp(i*theta)
#using 0 extra integers in prodeuler pari-gp function

dfminusZ=read.csv("/home/john/pari/Zminus_EPonly_res_p5_0_m750_p750_0extra_spacing_p01_real.csv",header=FALSE,colClasses = c("character"));
dfminusZ$V2=as.numeric(gsub(" ","",dfminusZ$V2));
dfminusZ=dfminusZ[order(as.numeric(dfminusZ$V1)),]

dfminusZi=read.csv("/home/john/pari/Zminus_EPonly_res_p5_0_m750_p750_0extra_spacing_p01_imag.csv",header=FALSE,colClasses = c("character"));
dfminusZi$V2=as.numeric(gsub(" ","",dfminusZi$V2));
dfminusZi=dfminusZi[order(as.numeric(dfminusZi$V1)),]

dfreal=dfminusZ;dfimag=dfminusZi

min_val=min(as.numeric(dfreal$V1));max_val=max(as.numeric(dfreal$V1))
dfimag=dfimag[dfimag$V1 %in% dfreal$V1,]

fft_minusZ = stats::fft(dfreal$V2+1i*dfimag$V2)

dfreal_minus=dfreal
dfimag_minus=dfimag

lenf=dim(dfreal)[1]

n=dim(dfreal)[1]

min_freq=min(as.numeric(substr(dfreal$V1,1,12)))
max_freq=max(as.numeric(substr(dfreal$V1,1,12)))
delta_fft=max(as.numeric(substr(dfreal$V1,1,12)))-min(as.numeric(substr(dfreal$V1,1,12)))


#symmetric formula when sigma=0.5
#for spectral filtering of first quiescent region based Euler Product

fft_hybrid=c(Re(fft_plusZ[1]),(fft_plusZ)[2:(ceiling(n/2)+0)],Re(fft_plusZ)[ceiling(n/2)+1],Conj(rev(c((fft_plusZ)[2:floor(n/2)]))))
inv_hybrid=fft(fft_hybrid,inverse=TRUE)

yspan=range(Re(inv_hybrid)/n,Im(inv_hybrid)/n)
plot(as.numeric(substr(dfreal$V1,1,22)),Re(inv_hybrid)/n,typ="l",
     ylim=c(-2,3),xlab="t",main="Riemann Siegel Z function analogue (using spectral filtered Euler Product) of \n Riemann Zeta function using floor(1.25*sqrt(t)/2/pi) upwards in EP",xlim=c(-40,40)+0,col="gray",cex.main=0.6);grid(col="gray")#,ylim=c(-.75,15),,xlim=c(100055,100060),xlim=c(100170,100173)
lines(as.numeric(substr(dfimag$V1,1,22)),Im(inv_hybrid)/n,col="blue")
lines(as.numeric(substr(dfZ$V1,1,22)),Re(dfZ$V2),col="magenta",lty=2)
lines(as.numeric(substr(dfZ$V1,1,22)),Re(dfZi$V2),col="cyan",lty=2)
lines(-rep((2/1.25)^2*2*pi/1,2),c(-0.5,0.5),lty=2,col="blue")
lines(rep((2/1.25)^2*2*pi/1,2),c(-0.5,0.5),lty=2,col="blue")
text(x=c(-1,1)*(2/1.25)^2*2*pi/1,y=-.67,"2")
text(x=0,y=-2,"t value when next prime is included in EP")
lines(-rep((3/1.25)^2*2*pi/1,2),c(-1.5,-0.5),lty=2,col="blue")
lines(rep((3/1.25)^2*2*pi/1,2),c(-1.5,-0.5),lty=2,col="blue")
text(x=c(-1,1)*(3/1.25)^2*2*pi/1,y=-2,"3")

plot(as.numeric(substr(dfreal$V1,1,22)),Re(inv_hybrid)/n-Re(dfZ$V2),typ="l",xlab="t",ylab="Error",main="Error in real(Z) component (using spectral filtered Euler Product approximation) of \n Riemann Zeta Z function using max(1,floor(1.25*sqrt(t/2/pi*1))) in EP",col="gray",cex.main=0.8);grid(col="gray2")

#first component of riemann-siegel formula based on first quiescent region
#EP(sigma+i*t)*exp(i*theta)
#using 2 and upwards in prodeuler pari-gp function for all t

dfplusZ=read.csv("/home/john/pari/Zplus_EPonly_res_p5_0_m750_p750_2upwards_spacing_p01_real.csv",header=FALSE,colClasses = c("character"));
dfplusZ$V2=as.numeric(gsub(" ","",dfplusZ$V2));
dfplusZ=dfplusZ[order(as.numeric(dfplusZ$V1)),]

dfplusZi=read.csv("/home/john/pari/Zplus_EPonly_res_p5_0_m750_p750_2upwards_spacing_p01_imag.csv",header=FALSE,colClasses = c("character"));
dfplusZi$V2=as.numeric(gsub(" ","",dfplusZi$V2));
dfplusZi=dfplusZi[order(as.numeric(dfplusZi$V1)),]

dfreal=dfplusZ;dfimag=dfplusZi

min_val=min(as.numeric(dfreal$V1));max_val=max(as.numeric(dfreal$V1))
dfimag=dfimag[(dfimag$V1 %in% dfreal$V1),]


fft_plusZ = stats::fft(dfreal$V2+1i*dfimag$V2)

dfreal_plus=dfreal
dfimag_plus=dfimag

lenf2=length(fft_plusZ)
delta_fft2=max(as.numeric(substr(dfreal$V1,1,12)))-min(as.numeric(substr(dfreal$V1,1,12)))
n=lenf2

#second component of riemann-siegel formula based on first quiescent region
#EP(1-(sigma+i*t))*chi(sigma+i*t)*exp(i*theta)
#using 2 and upwards in prodeuler pari-gp function for all t

dfminusZ=read.csv("/home/john/pari/Zminus_EPonly_res_p5_0_m750_p750_2upwards_spacing_p01_real.csv",header=FALSE,colClasses = c("character"));
dfminusZ$V2=as.numeric(gsub(" ","",dfminusZ$V2));
dfminusZ=dfminusZ[order(as.numeric(dfminusZ$V1)),]

dfminusZi=read.csv("/home/john/pari/Zminus_EPonly_res_p5_0_m750_p750_2upwards_spacing_p01_imag.csv",header=FALSE,colClasses = c("character"));
dfminusZi$V2=as.numeric(gsub(" ","",dfminusZi$V2));
dfminusZi=dfminusZi[order(as.numeric(dfminusZi$V1)),]

dfreal=dfminusZ;dfimag=dfminusZi

min_val=min(as.numeric(dfreal$V1));max_val=max(as.numeric(dfreal$V1))
dfimag=dfimag[dfimag$V1 %in% dfreal$V1,]

fft_minusZ = stats::fft(dfreal$V2+1i*dfimag$V2)

dfreal_minus=dfreal
dfimag_minus=dfimag

lenf=dim(dfreal)[1]

n=dim(dfreal)[1]

min_freq=min(as.numeric(substr(dfreal$V1,1,12)))
max_freq=max(as.numeric(substr(dfreal$V1,1,12)))
delta_fft=max(as.numeric(substr(dfreal$V1,1,12)))-min(as.numeric(substr(dfreal$V1,1,12)))


#symmetric formula when sigma=0.5
#for spectral filtering of first quiescent region based Euler Product

fft_hybrid=c(Re(fft_plusZ[1]),(fft_plusZ)[2:(ceiling(n/2)+0)],Re(fft_plusZ)[ceiling(n/2)+1],Conj(rev(c((fft_plusZ)[2:floor(n/2)]))))
inv_hybrid=fft(fft_hybrid,inverse=TRUE)

yspan=range(Re(inv_hybrid)/n,Im(inv_hybrid)/n)
plot(as.numeric(substr(dfreal$V1,1,22)),Re(inv_hybrid)/n,typ="l",
     ylim=c(-2,3),xlab="t",main="Riemann Siegel Z function analogue (using spectral filtered Euler Product) of \n Riemann Zeta function using 2 upwards for all t",xlim=c(-40,40)+0,col="gray",cex.main=0.6);grid(col="gray")#,ylim=c(-.75,15),,xlim=c(100055,100060),xlim=c(100170,100173)
lines(as.numeric(substr(dfimag$V1,1,22)),Im(inv_hybrid)/n,col="blue")
lines(as.numeric(substr(dfZ$V1,1,22)),Re(dfZ$V2),col="magenta",lty=2)
lines(as.numeric(substr(dfZ$V1,1,22)),Re(dfZi$V2),col="cyan",lty=2)
lines(-rep((3/1.25)^2*2*pi/1,2),c(-1.2,-0.2),lty=2,col="blue")
lines(rep((3/1.25)^2*2*pi/1,2),c(-1.2,-0.2),lty=2,col="blue")
text(x=c(-1,1)*(3/1.25)^2*2*pi/1,y=-1.5,"3")
text(x=0,y=-2,"t value when next prime is included in EP")

plot(as.numeric(substr(dfreal$V1,1,22)),Re(inv_hybrid)/n-Re(dfZ$V2),typ="l",xlab="t",ylab="Error",main="Error in real(Z) component (using spectral filtered Euler Product approximation) of \n Riemann Zeta Z function using max(1,floor(1.25*sqrt(t/2/pi*1))) in EP",col="gray",cex.main=0.8);grid(col="gray2")
lines(-rep((3/1.25)^2*2*pi/1,2),c(0.1,0.6),lty=2,col="blue")
lines(-rep((5/1.25)^2*2*pi/1,2),c(-0.6,-0.1),lty=2,col="blue")
lines(-rep((7/1.25)^2*2*pi/1,2),c(-0.6,-0.1),lty=2,col="blue")
lines(rep((3/1.25)^2*2*pi/1,2),c(0.1,0.6),lty=2,col="blue")
lines(rep((5/1.25)^2*2*pi/1,2),c(-0.6,-0.1),lty=2,col="blue")
lines(rep((7/1.25)^2*2*pi/1,2),c(-0.6,-0.1),lty=2,col="blue")
text(x=c(-1,1)*(3/1.25)^2*2*pi/1,y=0.8,"3")
text(x=c(-1,1)*(5/1.25)^2*2*pi/1,y=-0.8,"5")
text(x=c(-1,1)*(7/1.25)^2*2*pi/1,y=-0.8,"7")
text(x=0,y=-1.2,"t value when next prime is included in EP")


#first component of riemann-siegel formula based on first quiescent region
#EP(sigma+i*t)*exp(i*theta)
#using 3 and upwards in prodeuler pari-gp function for all t

dfplusZ=read.csv("/home/john/pari/Zplus_EPonly_res_p5_0_m750_p750_3upwards_spacing_p01_real.csv",header=FALSE,colClasses = c("character"));
dfplusZ$V2=as.numeric(gsub(" ","",dfplusZ$V2));
dfplusZ=dfplusZ[order(as.numeric(dfplusZ$V1)),]

dfplusZi=read.csv("/home/john/pari/Zplus_EPonly_res_p5_0_m750_p750_3upwards_spacing_p01_imag.csv",header=FALSE,colClasses = c("character"));
dfplusZi$V2=as.numeric(gsub(" ","",dfplusZi$V2));
dfplusZi=dfplusZi[order(as.numeric(dfplusZi$V1)),]

dfreal=dfplusZ;dfimag=dfplusZi

min_val=min(as.numeric(dfreal$V1));max_val=max(as.numeric(dfreal$V1))
dfimag=dfimag[(dfimag$V1 %in% dfreal$V1),]


fft_plusZ = stats::fft(dfreal$V2+1i*dfimag$V2)

dfreal_plus=dfreal
dfimag_plus=dfimag

lenf2=length(fft_plusZ)
delta_fft2=max(as.numeric(substr(dfreal$V1,1,12)))-min(as.numeric(substr(dfreal$V1,1,12)))
n=lenf2

#second component of riemann-siegel formula based on first quiescent region
#EP(1-(sigma+i*t))*chi(sigma+i*t)*exp(i*theta)
#using 3 and upwards in prodeuler pari-gp function for all t

dfminusZ=read.csv("/home/john/pari/Zminus_EPonly_res_p5_0_m750_p750_3upwards_spacing_p01_real.csv",header=FALSE,colClasses = c("character"));
dfminusZ$V2=as.numeric(gsub(" ","",dfminusZ$V2));
dfminusZ=dfminusZ[order(as.numeric(dfminusZ$V1)),]

dfminusZi=read.csv("/home/john/pari/Zminus_EPonly_res_p5_0_m750_p750_3upwards_spacing_p01_imag.csv",header=FALSE,colClasses = c("character"));
dfminusZi$V2=as.numeric(gsub(" ","",dfminusZi$V2));
dfminusZi=dfminusZi[order(as.numeric(dfminusZi$V1)),]

dfreal=dfminusZ;dfimag=dfminusZi

min_val=min(as.numeric(dfreal$V1));max_val=max(as.numeric(dfreal$V1))
dfimag=dfimag[dfimag$V1 %in% dfreal$V1,]

fft_minusZ = stats::fft(dfreal$V2+1i*dfimag$V2)

dfreal_minus=dfreal
dfimag_minus=dfimag

lenf=dim(dfreal)[1]

n=dim(dfreal)[1]

min_freq=min(as.numeric(substr(dfreal$V1,1,12)))
max_freq=max(as.numeric(substr(dfreal$V1,1,12)))
delta_fft=max(as.numeric(substr(dfreal$V1,1,12)))-min(as.numeric(substr(dfreal$V1,1,12)))


#symmetric formula when sigma=0.5
#for spectral filtering of first quiescent region based Euler Product

fft_hybrid=c(Re(fft_plusZ[1]),(fft_plusZ)[2:(ceiling(n/2)+0)],Re(fft_plusZ)[ceiling(n/2)+1],Conj(rev(c((fft_plusZ)[2:floor(n/2)]))))
inv_hybrid=fft(fft_hybrid,inverse=TRUE)

yspan=range(Re(inv_hybrid)/n,Im(inv_hybrid)/n)
plot(as.numeric(substr(dfreal$V1,1,22)),Re(inv_hybrid)/n,typ="l",
     ylim=c(-2,3),xlab="t",main="Riemann Siegel Z function analogue (using spectral filtered Euler Product) of \n Riemann Zeta function using 3 upwards for all t",xlim=c(-40,40)+0,col="gray",cex.main=0.6);grid(col="gray")#,ylim=c(-.75,15),,xlim=c(100055,100060),xlim=c(100170,100173)
lines(as.numeric(substr(dfimag$V1,1,22)),Im(inv_hybrid)/n,col="blue")
lines(as.numeric(substr(dfZi$V1,1,22)),Re(dfZ$V2),col="magenta",lty=2)
lines(as.numeric(substr(dfZ$V1,1,22)),Re(dfZi$V2),col="cyan",lty=2)

plot(as.numeric(substr(dfreal$V1,1,22)),Re(inv_hybrid)/n-Re(dfZ$V2),typ="l",xlab="t",ylab="Error",main="Error in real(Z) component (using spectral filtered Euler Product approximation) of \n Riemann Zeta Z function using max(1,floor(1.25*sqrt(t/2/pi*1))) in EP",col="gray",cex.main=0.8);grid(col="gray2")
lines(-rep((5/1.25)^2*2*pi/1,2),c(-0.6,-0.1),lty=2,col="blue")
lines(-rep((7/1.25)^2*2*pi/1,2),c(-0.6,-0.1),lty=2,col="blue")
lines(rep((5/1.25)^2*2*pi/1,2),c(-0.6,-0.1),lty=2,col="blue")
lines(rep((7/1.25)^2*2*pi/1,2),c(-0.6,-0.1),lty=2,col="blue")
text(x=c(-1,1)*(5/1.25)^2*2*pi/1,y=-0.8,"5")
text(x=c(-1,1)*(7/1.25)^2*2*pi/1,y=-0.8,"7")
text(x=0,y=-1.2,"t value when next prime is included in EP")


#first component of riemann-siegel formula based on first quiescent region
#EP(sigma+i*t)*exp(i*theta)
#using 5 and upwards in prodeuler pari-gp function for all t

dfplusZ=read.csv("/home/john/pari/Zplus_EPonly_res_p5_0_m750_p750_5upwards_spacing_p01_real.csv",header=FALSE,colClasses = c("character"));
dfplusZ$V2=as.numeric(gsub(" ","",dfplusZ$V2));
dfplusZ=dfplusZ[order(as.numeric(dfplusZ$V1)),]

dfplusZi=read.csv("/home/john/pari/Zplus_EPonly_res_p5_0_m750_p750_5upwards_spacing_p01_imag.csv",header=FALSE,colClasses = c("character"));
dfplusZi$V2=as.numeric(gsub(" ","",dfplusZi$V2));
dfplusZi=dfplusZi[order(as.numeric(dfplusZi$V1)),]

dfreal=dfplusZ;dfimag=dfplusZi

min_val=min(as.numeric(dfreal$V1));max_val=max(as.numeric(dfreal$V1))
dfimag=dfimag[(dfimag$V1 %in% dfreal$V1),]


fft_plusZ = stats::fft(dfreal$V2+1i*dfimag$V2)

dfreal_plus=dfreal
dfimag_plus=dfimag

lenf2=length(fft_plusZ)
delta_fft2=max(as.numeric(substr(dfreal$V1,1,12)))-min(as.numeric(substr(dfreal$V1,1,12)))
n=lenf2

#second component of riemann-siegel formula based on first quiescent region
#EP(1-(sigma+i*t))*chi(sigma+i*t)*exp(i*theta)
#using 5 and upwards in prodeuler pari-gp function for all t

dfminusZ=read.csv("/home/john/pari/Zminus_EPonly_res_p5_0_m750_p750_5upwards_spacing_p01_real.csv",header=FALSE,colClasses = c("character"));
dfminusZ$V2=as.numeric(gsub(" ","",dfminusZ$V2));
dfminusZ=dfminusZ[order(as.numeric(dfminusZ$V1)),]

dfminusZi=read.csv("/home/john/pari/Zminus_EPonly_res_p5_0_m750_p750_5upwards_spacing_p01_imag.csv",header=FALSE,colClasses = c("character"));
dfminusZi$V2=as.numeric(gsub(" ","",dfminusZi$V2));
dfminusZi=dfminusZi[order(as.numeric(dfminusZi$V1)),]

dfreal=dfminusZ;dfimag=dfminusZi

min_val=min(as.numeric(dfreal$V1));max_val=max(as.numeric(dfreal$V1))
dfimag=dfimag[dfimag$V1 %in% dfreal$V1,]

fft_minusZ = stats::fft(dfreal$V2+1i*dfimag$V2)

dfreal_minus=dfreal
dfimag_minus=dfimag

lenf=dim(dfreal)[1]

n=dim(dfreal)[1]

min_freq=min(as.numeric(substr(dfreal$V1,1,12)))
max_freq=max(as.numeric(substr(dfreal$V1,1,12)))
delta_fft=max(as.numeric(substr(dfreal$V1,1,12)))-min(as.numeric(substr(dfreal$V1,1,12)))


#symmetric formula when sigma=0.5
#for spectral filtering of first quiescent region based Euler Product

fft_hybrid=c(Re(fft_plusZ[1]),(fft_plusZ)[2:(ceiling(n/2)+0)],Re(fft_plusZ)[ceiling(n/2)+1],Conj(rev(c((fft_plusZ)[2:floor(n/2)]))))
inv_hybrid=fft(fft_hybrid,inverse=TRUE)

yspan=range(Re(inv_hybrid)/n,Im(inv_hybrid)/n)
plot(as.numeric(substr(dfreal$V1,1,22)),Re(inv_hybrid)/n,typ="l",
     ylim=c(-2,3),xlab="t",main="Riemann Siegel Z function analogue (using spectral filtered Euler Product) of \n Riemann Zeta function using 5 upwards for all t",xlim=c(-40,40)+0,col="gray",cex.main=0.6);grid(col="gray")#,ylim=c(-.75,15),,xlim=c(100055,100060),xlim=c(100170,100173)
lines(as.numeric(substr(dfimag$V1,1,22)),Im(inv_hybrid)/n,col="blue")
lines(as.numeric(substr(dfZi$V1,1,22)),Re(dfZ$V2),col="magenta",lty=2)
lines(as.numeric(substr(dfZ$V1,1,22)),Re(dfZi$V2),col="cyan",lty=2)

plot(as.numeric(substr(dfreal$V1,1,22)),Re(inv_hybrid)/n-Re(dfZ$V2),typ="l",xlab="t",ylab="Error",main="Error in real(Z) component (using spectral filtered Euler Product approximation) of \n Riemann Zeta Z function using max(1,floor(1.25*sqrt(t/2/pi*1))) in EP",col="gray",cex.main=0.8);grid(col="gray2")
lines(-rep((7/1.25)^2*2*pi/1,2),c(-0.6,-0.1),lty=2,col="blue")
lines(rep((7/1.25)^2*2*pi/1,2),c(-0.6,-0.1),lty=2,col="blue")
text(x=c(-1,1)*(7/1.25)^2*2*pi/1,y=-0.8,"7")
text(x=0,y=-1.2,"t value when next prime is included in EP")
lines(-rep((11/1.25)^2*2*pi/1,2),c(-0.6,-0.1),lty=2,col="blue")
lines(rep((11/1.25)^2*2*pi/1,2),c(-0.6,-0.1),lty=2,col="blue")
text(x=c(-1,1)*(11/1.25)^2*2*pi/1,y=-0.8,"11")
lines(-rep((13/1.25)^2*2*pi/1,2),c(0.05,0.45),lty=2,col="blue")
lines(rep((13/1.25)^2*2*pi/1,2),c(0.05,0.45),lty=2,col="blue")
text(x=c(-1,1)*(13/1.25)^2*2*pi/1,y=0.6,"13")


#first component of riemann-siegel formula based on first quiescent region
#EP(sigma+i*t)*exp(i*theta)
#using 13 and upwards in prodeuler pari-gp function for all t

dfplusZ=read.csv("/home/john/pari/Zplus_EPonly_res_p5_0_m750_p750_13upwards_spacing_p01_real.csv",header=FALSE,colClasses = c("character"));
dfplusZ$V2=as.numeric(gsub(" ","",dfplusZ$V2));
dfplusZ=dfplusZ[order(as.numeric(dfplusZ$V1)),]

dfplusZi=read.csv("/home/john/pari/Zplus_EPonly_res_p5_0_m750_p750_13upwards_spacing_p01_imag.csv",header=FALSE,colClasses = c("character"));
dfplusZi$V2=as.numeric(gsub(" ","",dfplusZi$V2));
dfplusZi=dfplusZi[order(as.numeric(dfplusZi$V1)),]

dfreal=dfplusZ;dfimag=dfplusZi

min_val=min(as.numeric(dfreal$V1));max_val=max(as.numeric(dfreal$V1))
dfimag=dfimag[(dfimag$V1 %in% dfreal$V1),]


fft_plusZ = stats::fft(dfreal$V2+1i*dfimag$V2)

dfreal_plus=dfreal
dfimag_plus=dfimag

lenf2=length(fft_plusZ)
delta_fft2=max(as.numeric(substr(dfreal$V1,1,12)))-min(as.numeric(substr(dfreal$V1,1,12)))
n=lenf2

#second component of riemann-siegel formula based on first quiescent region
#EP(1-(sigma+i*t))*chi(sigma+i*t)*exp(i*theta)
#using 5 and upwards in prodeuler pari-gp function for all t

dfminusZ=read.csv("/home/john/pari/Zminus_EPonly_res_p5_0_m750_p750_13upwards_spacing_p01_real.csv",header=FALSE,colClasses = c("character"));
dfminusZ$V2=as.numeric(gsub(" ","",dfminusZ$V2));
dfminusZ=dfminusZ[order(as.numeric(dfminusZ$V1)),]

dfminusZi=read.csv("/home/john/pari/Zminus_EPonly_res_p5_0_m750_p750_13upwards_spacing_p01_imag.csv",header=FALSE,colClasses = c("character"));
dfminusZi$V2=as.numeric(gsub(" ","",dfminusZi$V2));
dfminusZi=dfminusZi[order(as.numeric(dfminusZi$V1)),]

dfreal=dfminusZ;dfimag=dfminusZi

min_val=min(as.numeric(dfreal$V1));max_val=max(as.numeric(dfreal$V1))
dfimag=dfimag[dfimag$V1 %in% dfreal$V1,]

fft_minusZ = stats::fft(dfreal$V2+1i*dfimag$V2)

dfreal_minus=dfreal
dfimag_minus=dfimag

lenf=dim(dfreal)[1]

n=dim(dfreal)[1]

min_freq=min(as.numeric(substr(dfreal$V1,1,12)))
max_freq=max(as.numeric(substr(dfreal$V1,1,12)))
delta_fft=max(as.numeric(substr(dfreal$V1,1,12)))-min(as.numeric(substr(dfreal$V1,1,12)))


#symmetric formula when sigma=0.5
#for spectral filtering of first quiescent region based Euler Product

fft_hybrid=c(Re(fft_plusZ[1]),(fft_plusZ)[2:(ceiling(n/2)+0)],Re(fft_plusZ)[ceiling(n/2)+1],Conj(rev(c((fft_plusZ)[2:floor(n/2)]))))
inv_hybrid=fft(fft_hybrid,inverse=TRUE)

yspan=range(Re(inv_hybrid)/n,Im(inv_hybrid)/n)
plot(as.numeric(substr(dfreal$V1,1,22)),Re(inv_hybrid)/n,typ="l",
     ylim=c(-2,3),xlab="t",main="Riemann Siegel Z function analogue (using spectral filtered Euler Product) of \n Riemann Zeta function using 13 upwards for all t",xlim=c(-40,40)+0,col="gray",cex.main=0.6);grid(col="gray")#,ylim=c(-.75,15),,xlim=c(100055,100060),xlim=c(100170,100173)
lines(as.numeric(substr(dfimag$V1,1,22)),Im(inv_hybrid)/n,col="blue")
lines(as.numeric(substr(dfZi$V1,1,22)),Re(dfZ$V2),col="magenta",lty=2)
lines(as.numeric(substr(dfZ$V1,1,22)),Re(dfZi$V2),col="cyan",lty=2)

plot(as.numeric(substr(dfreal$V1,1,22)),Re(inv_hybrid)/n-Re(dfZ$V2),typ="l",xlab="t",ylab="Error",main="Error in real(Z) component (using spectral filtered Euler Product approximation) of \n Riemann Zeta Z function using max(1,floor(1.25*sqrt(t/2/pi*1))) in EP",col="gray",cex.main=0.8);grid(col="gray2")
text(x=250,y=-0.5,"as shown the error in the zeta Z EP \n approximation around t=0 is NOT resolved \n by adding primes to EP",cex=0.7)

```





\clearpage



```{r Zfnzeta_andtruncatedEPfouriertransform_0_pm750_p1, echo=FALSE, fig.cap="Lefthand panel - True Z function shown in magenta (cyan) for real (imaginary) parts and spectral filtered based EP approximation shown in black (blue) for real (imaginary) parts, Right hand panel - Error in the real(Z) EP approximation. A comparison of the Riemann-Siegel Z function of the Riemann Zeta L-function and spectrally filtered partial Euler Product (using truncation at $\\max (P,\\sqrt{((\\frac{t}{2\\pi})^1\\cdot 1}) $) in the complex plane at $\\sigma=0.1$ for the interval t=(-750,750) where $P_{min}={1,2,3,5,13}$ for rows 1-5. The approximation error around t=0 only increases by adding primes.", out.width = c("49%","49%"), fig.show = "hold",  fig.height=3.8, warning=FALSE, cache=TRUE}

# Riemann-Siegel Z function of Riemann Zeta function on critical line
# values recorded every .01 spacing in interval [-750,+750]

dfZ=read.csv("/home/john/pari/Zzeta_res_p1_0_m750_p750_spacing_p01_real.csv",header=FALSE,colClasses = c("character"));
dfZ$V2=as.numeric(gsub(" ","",dfZ$V2));
dfZ=dfZ[order(as.numeric(dfZ$V1)),]

dfZi=read.csv("/home/john/pari/Zzeta_res_p1_0_m750_p750_spacing_p01_imag.csv",header=FALSE,colClasses = c("character"));
dfZi$V2=as.numeric(gsub(" ","",dfZi$V2));
dfZi=dfZi[order(as.numeric(dfZi$V1)),]


#Riemann-Siegel Z function of truncated Euler product at first quiescent region
#first component of riemann-siegel formula based on first quiescent region
#EP(sigma+i*t)*exp(i*theta)
#using 0 extra integers in prodeuler pari-gp function

dfplusZ=read.csv("/home/john/pari/Zplus_EPonly_res_p1_0_m750_p750_0extra_spacing_p01_real.csv",header=FALSE,colClasses = c("character"));
dfplusZ$V2=as.numeric(gsub(" ","",dfplusZ$V2));
dfplusZ=dfplusZ[order(as.numeric(dfplusZ$V1)),]

dfplusZi=read.csv("/home/john/pari/Zplus_EPonly_res_p1_0_m750_p750_0extra_spacing_p01_imag.csv",header=FALSE,colClasses = c("character"));
dfplusZi$V2=as.numeric(gsub(" ","",dfplusZi$V2));
dfplusZi=dfplusZi[order(as.numeric(dfplusZi$V1)),]

dfreal=dfplusZ;dfimag=dfplusZi

min_val=min(as.numeric(dfreal$V1));max_val=max(as.numeric(dfreal$V1))
dfimag=dfimag[(dfimag$V1 %in% dfreal$V1),]


fft_plusZ = stats::fft(dfreal$V2+1i*dfimag$V2)

dfreal_plus=dfreal
dfimag_plus=dfimag

lenf2=length(fft_plusZ)
delta_fft2=max(as.numeric(substr(dfreal$V1,1,12)))-min(as.numeric(substr(dfreal$V1,1,12)))
n=lenf2

#second component of riemann-siegel formula based on first quiescent region
#EP(1-(sigma+i*t))*chi(sigma+i*t)*exp(i*theta)
#using 0 extra integers in prodeuler pari-gp function

dfminusZ=read.csv("/home/john/pari/Zminus_EPonly_res_p1_0_m750_p750_0extra_spacing_p01_real.csv",header=FALSE,colClasses = c("character"));
dfminusZ$V2=as.numeric(gsub(" ","",dfminusZ$V2));
dfminusZ=dfminusZ[order(as.numeric(dfminusZ$V1)),]

dfminusZi=read.csv("/home/john/pari/Zminus_EPonly_res_p1_0_m750_p750_0extra_spacing_p01_imag.csv",header=FALSE,colClasses = c("character"));
dfminusZi$V2=as.numeric(gsub(" ","",dfminusZi$V2));
dfminusZi=dfminusZi[order(as.numeric(dfminusZi$V1)),]

dfreal=dfminusZ;dfimag=dfminusZi

min_val=min(as.numeric(dfreal$V1));max_val=max(as.numeric(dfreal$V1))
dfimag=dfimag[dfimag$V1 %in% dfreal$V1,]

fft_minusZ = stats::fft(dfreal$V2+1i*dfimag$V2)

dfreal_minus=dfreal
dfimag_minus=dfimag

lenf=dim(dfreal)[1]

n=dim(dfreal)[1]

min_freq=min(as.numeric(substr(dfreal$V1,1,12)))
max_freq=max(as.numeric(substr(dfreal$V1,1,12)))
delta_fft=max(as.numeric(substr(dfreal$V1,1,12)))-min(as.numeric(substr(dfreal$V1,1,12)))


#symmetric formula when sigma=0.5
#for spectral filtering of first quiescent region based Euler Product

fft_hybrid=c(1/2*(fft_plusZ[1]+fft_minusZ[1]),(fft_plusZ)[2:(ceiling(n/2)+0)],1/2*(fft_plusZ[ceiling(n/2)+1]+fft_minusZ[ceiling(n/2)+1]),fft_minusZ[(ceiling(n/2)+2):n])
inv_hybrid=fft(fft_hybrid,inverse=TRUE)

yspan=range(Re(inv_hybrid)/n,Im(inv_hybrid)/n)
plot(as.numeric(substr(dfreal$V1,1,22)),Re(inv_hybrid)/n,typ="l",
     ylim=c(-4,6),xlab="t",main="Riemann Siegel Z function analogue (using spectral filtered Euler Product) of \n Riemann Zeta function using floor(1.25*sqrt(t)/2/pi) upwards in EP",xlim=c(-40,40)+0,col="gray",cex.main=0.6);grid(col="gray")#,ylim=c(-.75,15),,xlim=c(100055,100060),xlim=c(100170,100173)
lines(as.numeric(substr(dfimag$V1,1,22)),Im(inv_hybrid)/n,col="blue")
lines(as.numeric(substr(dfZ$V1,1,22)),Re(dfZ$V2),col="magenta",lty=2)
lines(as.numeric(substr(dfZ$V1,1,22)),Re(dfZi$V2),col="cyan",lty=2)
# lines(-rep((2/1.25)^2*2*pi/1,2),c(-0.5,0.5),lty=2,col="blue")
# lines(rep((2/1.25)^2*2*pi/1,2),c(-0.5,0.5),lty=2,col="blue")
# text(x=c(-1,1)*(2/1.25)^2*2*pi/1,y=-.67,"2")
# text(x=0,y=-2,"t value when next prime is included in EP")
# lines(-rep((3/1.25)^2*2*pi/1,2),c(-1.5,-0.5),lty=2,col="blue")
# lines(rep((3/1.25)^2*2*pi/1,2),c(-1.5,-0.5),lty=2,col="blue")
# text(x=c(-1,1)*(3/1.25)^2*2*pi/1,y=-2,"3")

plot(as.numeric(substr(dfreal$V1,1,22)),Re(inv_hybrid)/n-Re(dfZ$V2),typ="l",xlab="t",ylab="Error",main="Error in real(Z) component (using spectral filtered Euler Product approximation) of \n Riemann Zeta Z function using max(1,floor(1.25*sqrt(t/2/pi*1))) in EP",col="darkgreen",cex.main=0.8);grid(col="gray2")

#first component of riemann-siegel formula based on first quiescent region
#EP(sigma+i*t)*exp(i*theta)
#using 2 and upwards in prodeuler pari-gp function for all t

dfplusZ=read.csv("/home/john/pari/Zplus_EPonly_res_p1_0_m750_p750_2upwards_spacing_p01_real.csv",header=FALSE,colClasses = c("character"));
dfplusZ$V2=as.numeric(gsub(" ","",dfplusZ$V2));
dfplusZ=dfplusZ[order(as.numeric(dfplusZ$V1)),]

dfplusZi=read.csv("/home/john/pari/Zplus_EPonly_res_p1_0_m750_p750_2upwards_spacing_p01_imag.csv",header=FALSE,colClasses = c("character"));
dfplusZi$V2=as.numeric(gsub(" ","",dfplusZi$V2));
dfplusZi=dfplusZi[order(as.numeric(dfplusZi$V1)),]

dfreal=dfplusZ;dfimag=dfplusZi

min_val=min(as.numeric(dfreal$V1));max_val=max(as.numeric(dfreal$V1))
dfimag=dfimag[(dfimag$V1 %in% dfreal$V1),]


fft_plusZ = stats::fft(dfreal$V2+1i*dfimag$V2)

dfreal_plus=dfreal
dfimag_plus=dfimag

lenf2=length(fft_plusZ)
delta_fft2=max(as.numeric(substr(dfreal$V1,1,12)))-min(as.numeric(substr(dfreal$V1,1,12)))
n=lenf2

#second component of riemann-siegel formula based on first quiescent region
#EP(1-(sigma+i*t))*chi(sigma+i*t)*exp(i*theta)
#using 2 and upwards in prodeuler pari-gp function for all t

dfminusZ=read.csv("/home/john/pari/Zminus_EPonly_res_p1_0_m750_p750_2upwards_spacing_p01_real.csv",header=FALSE,colClasses = c("character"));
dfminusZ$V2=as.numeric(gsub(" ","",dfminusZ$V2));
dfminusZ=dfminusZ[order(as.numeric(dfminusZ$V1)),]

dfminusZi=read.csv("/home/john/pari/Zminus_EPonly_res_p1_0_m750_p750_2upwards_spacing_p01_imag.csv",header=FALSE,colClasses = c("character"));
dfminusZi$V2=as.numeric(gsub(" ","",dfminusZi$V2));
dfminusZi=dfminusZi[order(as.numeric(dfminusZi$V1)),]

dfreal=dfminusZ;dfimag=dfminusZi

min_val=min(as.numeric(dfreal$V1));max_val=max(as.numeric(dfreal$V1))
dfimag=dfimag[dfimag$V1 %in% dfreal$V1,]

fft_minusZ = stats::fft(dfreal$V2+1i*dfimag$V2)

dfreal_minus=dfreal
dfimag_minus=dfimag

lenf=dim(dfreal)[1]

n=dim(dfreal)[1]

min_freq=min(as.numeric(substr(dfreal$V1,1,12)))
max_freq=max(as.numeric(substr(dfreal$V1,1,12)))
delta_fft=max(as.numeric(substr(dfreal$V1,1,12)))-min(as.numeric(substr(dfreal$V1,1,12)))


#symmetric formula when sigma=0.5
#for spectral filtering of first quiescent region based Euler Product

fft_hybrid=c(1/2*(fft_plusZ[1]+fft_minusZ[1]),(fft_plusZ)[2:(ceiling(n/2)+0)],1/2*(fft_plusZ[ceiling(n/2)+1]+fft_minusZ[ceiling(n/2)+1]),fft_minusZ[(ceiling(n/2)+2):n])
inv_hybrid=fft(fft_hybrid,inverse=TRUE)

yspan=range(Re(inv_hybrid)/n,Im(inv_hybrid)/n)
plot(as.numeric(substr(dfreal$V1,1,22)),Re(inv_hybrid)/n,typ="l",
     ylim=c(-4,6),xlab="t",main="Riemann Siegel Z function analogue (using spectral filtered Euler Product) of \n Riemann Zeta function using 2 upwards for all t",xlim=c(-40,40)+0,col="gray",cex.main=0.6);grid(col="gray")#,ylim=c(-.75,15),,xlim=c(100055,100060),xlim=c(100170,100173)
lines(as.numeric(substr(dfimag$V1,1,22)),Im(inv_hybrid)/n,col="blue")
lines(as.numeric(substr(dfZ$V1,1,22)),Re(dfZ$V2),col="magenta",lty=2)
lines(as.numeric(substr(dfZ$V1,1,22)),Re(dfZi$V2),col="cyan",lty=2)
lines(-rep((3/1.25)^2*2*pi/1,2),c(-1.2,-0.2),lty=2,col="blue")
lines(rep((3/1.25)^2*2*pi/1,2),c(-1.2,-0.2),lty=2,col="blue")
text(x=c(-1,1)*(3/1.25)^2*2*pi/1,y=-1.5,"3")
text(x=0,y=-2,"t value when next prime is included in EP")

plot(as.numeric(substr(dfreal$V1,1,22)),Re(inv_hybrid)/n-Re(dfZ$V2),typ="l",xlab="t",ylab="Error",main="Error in real(Z) component (using spectral filtered Euler Product approximation) of \n Riemann Zeta Z function using max(1,floor(1.25*sqrt(t/2/pi*1))) in EP",col="darkgreen",cex.main=0.8);grid(col="gray2")
# lines(-rep((3/1.25)^2*2*pi/1,2),c(0.1,0.6),lty=2,col="blue")
# lines(-rep((5/1.25)^2*2*pi/1,2),c(-0.6,-0.1),lty=2,col="blue")
# lines(-rep((7/1.25)^2*2*pi/1,2),c(-0.6,-0.1),lty=2,col="blue")
# lines(rep((3/1.25)^2*2*pi/1,2),c(0.1,0.6),lty=2,col="blue")
# lines(rep((5/1.25)^2*2*pi/1,2),c(-0.6,-0.1),lty=2,col="blue")
# lines(rep((7/1.25)^2*2*pi/1,2),c(-0.6,-0.1),lty=2,col="blue")
# text(x=c(-1,1)*(3/1.25)^2*2*pi/1,y=0.8,"3")
# text(x=c(-1,1)*(5/1.25)^2*2*pi/1,y=-0.8,"5")
# text(x=c(-1,1)*(7/1.25)^2*2*pi/1,y=-0.8,"7")
# text(x=0,y=-1.2,"t value when next prime is included in EP")


#first component of riemann-siegel formula based on first quiescent region
#EP(sigma+i*t)*exp(i*theta)
#using 3 and upwards in prodeuler pari-gp function for all t

dfplusZ=read.csv("/home/john/pari/Zplus_EPonly_res_p1_0_m750_p750_3upwards_spacing_p01_real.csv",header=FALSE,colClasses = c("character"));
dfplusZ$V2=as.numeric(gsub(" ","",dfplusZ$V2));
dfplusZ=dfplusZ[order(as.numeric(dfplusZ$V1)),]

dfplusZi=read.csv("/home/john/pari/Zplus_EPonly_res_p1_0_m750_p750_3upwards_spacing_p01_imag.csv",header=FALSE,colClasses = c("character"));
dfplusZi$V2=as.numeric(gsub(" ","",dfplusZi$V2));
dfplusZi=dfplusZi[order(as.numeric(dfplusZi$V1)),]

dfreal=dfplusZ;dfimag=dfplusZi

min_val=min(as.numeric(dfreal$V1));max_val=max(as.numeric(dfreal$V1))
dfimag=dfimag[(dfimag$V1 %in% dfreal$V1),]


fft_plusZ = stats::fft(dfreal$V2+1i*dfimag$V2)

dfreal_plus=dfreal
dfimag_plus=dfimag

lenf2=length(fft_plusZ)
delta_fft2=max(as.numeric(substr(dfreal$V1,1,12)))-min(as.numeric(substr(dfreal$V1,1,12)))
n=lenf2

#second component of riemann-siegel formula based on first quiescent region
#EP(1-(sigma+i*t))*chi(sigma+i*t)*exp(i*theta)
#using 3 and upwards in prodeuler pari-gp function for all t

dfminusZ=read.csv("/home/john/pari/Zminus_EPonly_res_p1_0_m750_p750_3upwards_spacing_p01_real.csv",header=FALSE,colClasses = c("character"));
dfminusZ$V2=as.numeric(gsub(" ","",dfminusZ$V2));
dfminusZ=dfminusZ[order(as.numeric(dfminusZ$V1)),]

dfminusZi=read.csv("/home/john/pari/Zminus_EPonly_res_p1_0_m750_p750_3upwards_spacing_p01_imag.csv",header=FALSE,colClasses = c("character"));
dfminusZi$V2=as.numeric(gsub(" ","",dfminusZi$V2));
dfminusZi=dfminusZi[order(as.numeric(dfminusZi$V1)),]

dfreal=dfminusZ;dfimag=dfminusZi

min_val=min(as.numeric(dfreal$V1));max_val=max(as.numeric(dfreal$V1))
dfimag=dfimag[dfimag$V1 %in% dfreal$V1,]

fft_minusZ = stats::fft(dfreal$V2+1i*dfimag$V2)

dfreal_minus=dfreal
dfimag_minus=dfimag

lenf=dim(dfreal)[1]

n=dim(dfreal)[1]

min_freq=min(as.numeric(substr(dfreal$V1,1,12)))
max_freq=max(as.numeric(substr(dfreal$V1,1,12)))
delta_fft=max(as.numeric(substr(dfreal$V1,1,12)))-min(as.numeric(substr(dfreal$V1,1,12)))


#symmetric formula when sigma=0.5
#for spectral filtering of first quiescent region based Euler Product

fft_hybrid=c(1/2*(fft_plusZ[1]+fft_minusZ[1]),(fft_plusZ)[2:(ceiling(n/2)+0)],1/2*(fft_plusZ[ceiling(n/2)+1]+fft_minusZ[ceiling(n/2)+1]),fft_minusZ[(ceiling(n/2)+2):n])
inv_hybrid=fft(fft_hybrid,inverse=TRUE)

yspan=range(Re(inv_hybrid)/n,Im(inv_hybrid)/n)
plot(as.numeric(substr(dfreal$V1,1,22)),Re(inv_hybrid)/n,typ="l",
     ylim=c(-4,6),xlab="t",main="Riemann Siegel Z function analogue (using spectral filtered Euler Product) of \n Riemann Zeta function using 3 upwards for all t",xlim=c(-40,40)+0,col="gray",cex.main=0.6);grid(col="gray")#,ylim=c(-.75,15),,xlim=c(100055,100060),xlim=c(100170,100173)
lines(as.numeric(substr(dfimag$V1,1,22)),Im(inv_hybrid)/n,col="blue")
lines(as.numeric(substr(dfZi$V1,1,22)),Re(dfZ$V2),col="magenta",lty=2)
lines(as.numeric(substr(dfZ$V1,1,22)),Re(dfZi$V2),col="cyan",lty=2)

plot(as.numeric(substr(dfreal$V1,1,22)),Re(inv_hybrid)/n-Re(dfZ$V2),typ="l",xlab="t",ylab="Error",main="Error in real(Z) component (using spectral filtered Euler Product approximation) of \n Riemann Zeta Z function using max(1,floor(1.25*sqrt(t/2/pi*1))) in EP",col="darkgreen",cex.main=0.8);grid(col="gray2")
# lines(-rep((5/1.25)^2*2*pi/1,2),c(-0.6,-0.1),lty=2,col="blue")
# lines(-rep((7/1.25)^2*2*pi/1,2),c(-0.6,-0.1),lty=2,col="blue")
# lines(rep((5/1.25)^2*2*pi/1,2),c(-0.6,-0.1),lty=2,col="blue")
# lines(rep((7/1.25)^2*2*pi/1,2),c(-0.6,-0.1),lty=2,col="blue")
# text(x=c(-1,1)*(5/1.25)^2*2*pi/1,y=-0.8,"5")
# text(x=c(-1,1)*(7/1.25)^2*2*pi/1,y=-0.8,"7")
# text(x=0,y=-1.2,"t value when next prime is included in EP")


#first component of riemann-siegel formula based on first quiescent region
#EP(sigma+i*t)*exp(i*theta)
#using 5 and upwards in prodeuler pari-gp function for all t

dfplusZ=read.csv("/home/john/pari/Zplus_EPonly_res_p1_0_m750_p750_5upwards_spacing_p01_real.csv",header=FALSE,colClasses = c("character"));
dfplusZ$V2=as.numeric(gsub(" ","",dfplusZ$V2));
dfplusZ=dfplusZ[order(as.numeric(dfplusZ$V1)),]

dfplusZi=read.csv("/home/john/pari/Zplus_EPonly_res_p1_0_m750_p750_5upwards_spacing_p01_imag.csv",header=FALSE,colClasses = c("character"));
dfplusZi$V2=as.numeric(gsub(" ","",dfplusZi$V2));
dfplusZi=dfplusZi[order(as.numeric(dfplusZi$V1)),]

dfreal=dfplusZ;dfimag=dfplusZi

min_val=min(as.numeric(dfreal$V1));max_val=max(as.numeric(dfreal$V1))
dfimag=dfimag[(dfimag$V1 %in% dfreal$V1),]


fft_plusZ = stats::fft(dfreal$V2+1i*dfimag$V2)

dfreal_plus=dfreal
dfimag_plus=dfimag

lenf2=length(fft_plusZ)
delta_fft2=max(as.numeric(substr(dfreal$V1,1,12)))-min(as.numeric(substr(dfreal$V1,1,12)))
n=lenf2

#second component of riemann-siegel formula based on first quiescent region
#EP(1-(sigma+i*t))*chi(sigma+i*t)*exp(i*theta)
#using 5 and upwards in prodeuler pari-gp function for all t

dfminusZ=read.csv("/home/john/pari/Zminus_EPonly_res_p1_0_m750_p750_5upwards_spacing_p01_real.csv",header=FALSE,colClasses = c("character"));
dfminusZ$V2=as.numeric(gsub(" ","",dfminusZ$V2));
dfminusZ=dfminusZ[order(as.numeric(dfminusZ$V1)),]

dfminusZi=read.csv("/home/john/pari/Zminus_EPonly_res_p1_0_m750_p750_5upwards_spacing_p01_imag.csv",header=FALSE,colClasses = c("character"));
dfminusZi$V2=as.numeric(gsub(" ","",dfminusZi$V2));
dfminusZi=dfminusZi[order(as.numeric(dfminusZi$V1)),]

dfreal=dfminusZ;dfimag=dfminusZi

min_val=min(as.numeric(dfreal$V1));max_val=max(as.numeric(dfreal$V1))
dfimag=dfimag[dfimag$V1 %in% dfreal$V1,]

fft_minusZ = stats::fft(dfreal$V2+1i*dfimag$V2)

dfreal_minus=dfreal
dfimag_minus=dfimag

lenf=dim(dfreal)[1]

n=dim(dfreal)[1]

min_freq=min(as.numeric(substr(dfreal$V1,1,12)))
max_freq=max(as.numeric(substr(dfreal$V1,1,12)))
delta_fft=max(as.numeric(substr(dfreal$V1,1,12)))-min(as.numeric(substr(dfreal$V1,1,12)))


#symmetric formula when sigma=0.5
#for spectral filtering of first quiescent region based Euler Product

fft_hybrid=c(1/2*(fft_plusZ[1]+fft_minusZ[1]),(fft_plusZ)[2:(ceiling(n/2)+0)],1/2*(fft_plusZ[ceiling(n/2)+1]+fft_minusZ[ceiling(n/2)+1]),fft_minusZ[(ceiling(n/2)+2):n])
inv_hybrid=fft(fft_hybrid,inverse=TRUE)

yspan=range(Re(inv_hybrid)/n,Im(inv_hybrid)/n)
plot(as.numeric(substr(dfreal$V1,1,22)),Re(inv_hybrid)/n,typ="l",
     ylim=c(-4,6),xlab="t",main="Riemann Siegel Z function analogue (using spectral filtered Euler Product) of \n Riemann Zeta function using 5 upwards for all t",xlim=c(-40,40)+0,col="gray",cex.main=0.6);grid(col="gray")#,ylim=c(-.75,15),,xlim=c(100055,100060),xlim=c(100170,100173)
lines(as.numeric(substr(dfimag$V1,1,22)),Im(inv_hybrid)/n,col="blue")
lines(as.numeric(substr(dfZi$V1,1,22)),Re(dfZ$V2),col="magenta",lty=2)
lines(as.numeric(substr(dfZ$V1,1,22)),Re(dfZi$V2),col="cyan",lty=2)

plot(as.numeric(substr(dfreal$V1,1,22)),Re(inv_hybrid)/n-Re(dfZ$V2),typ="l",xlab="t",ylab="Error",main="Error in real(Z) component (using spectral filtered Euler Product approximation) of \n Riemann Zeta Z function using max(1,floor(1.25*sqrt(t/2/pi*1))) in EP",col="darkgreen",cex.main=0.8);grid(col="gray2")
# lines(-rep((7/1.25)^2*2*pi/1,2),c(-0.6,-0.1),lty=2,col="blue")
# lines(rep((7/1.25)^2*2*pi/1,2),c(-0.6,-0.1),lty=2,col="blue")
# text(x=c(-1,1)*(7/1.25)^2*2*pi/1,y=-0.8,"7")
# text(x=0,y=-1.2,"t value when next prime is included in EP")
# lines(-rep((11/1.25)^2*2*pi/1,2),c(-0.6,-0.1),lty=2,col="blue")
# lines(rep((11/1.25)^2*2*pi/1,2),c(-0.6,-0.1),lty=2,col="blue")
# text(x=c(-1,1)*(11/1.25)^2*2*pi/1,y=-0.8,"11")
# lines(-rep((13/1.25)^2*2*pi/1,2),c(0.05,0.45),lty=2,col="blue")
# lines(rep((13/1.25)^2*2*pi/1,2),c(0.05,0.45),lty=2,col="blue")
# text(x=c(-1,1)*(13/1.25)^2*2*pi/1,y=0.6,"13")


#first component of riemann-siegel formula based on first quiescent region
#EP(sigma+i*t)*exp(i*theta)
#using 13 and upwards in prodeuler pari-gp function for all t

dfplusZ=read.csv("/home/john/pari/Zplus_EPonly_res_p1_0_m750_p750_13upwards_spacing_p01_real.csv",header=FALSE,colClasses = c("character"));
dfplusZ$V2=as.numeric(gsub(" ","",dfplusZ$V2));
dfplusZ=dfplusZ[order(as.numeric(dfplusZ$V1)),]

dfplusZi=read.csv("/home/john/pari/Zplus_EPonly_res_p1_0_m750_p750_13upwards_spacing_p01_imag.csv",header=FALSE,colClasses = c("character"));
dfplusZi$V2=as.numeric(gsub(" ","",dfplusZi$V2));
dfplusZi=dfplusZi[order(as.numeric(dfplusZi$V1)),]

dfreal=dfplusZ;dfimag=dfplusZi

min_val=min(as.numeric(dfreal$V1));max_val=max(as.numeric(dfreal$V1))
dfimag=dfimag[(dfimag$V1 %in% dfreal$V1),]


fft_plusZ = stats::fft(dfreal$V2+1i*dfimag$V2)

dfreal_plus=dfreal
dfimag_plus=dfimag

lenf2=length(fft_plusZ)
delta_fft2=max(as.numeric(substr(dfreal$V1,1,12)))-min(as.numeric(substr(dfreal$V1,1,12)))
n=lenf2

#second component of riemann-siegel formula based on first quiescent region
#EP(1-(sigma+i*t))*chi(sigma+i*t)*exp(i*theta)
#using 5 and upwards in prodeuler pari-gp function for all t

dfminusZ=read.csv("/home/john/pari/Zminus_EPonly_res_p1_0_m750_p750_13upwards_spacing_p01_real.csv",header=FALSE,colClasses = c("character"));
dfminusZ$V2=as.numeric(gsub(" ","",dfminusZ$V2));
dfminusZ=dfminusZ[order(as.numeric(dfminusZ$V1)),]

dfminusZi=read.csv("/home/john/pari/Zminus_EPonly_res_p1_0_m750_p750_13upwards_spacing_p01_imag.csv",header=FALSE,colClasses = c("character"));
dfminusZi$V2=as.numeric(gsub(" ","",dfminusZi$V2));
dfminusZi=dfminusZi[order(as.numeric(dfminusZi$V1)),]

dfreal=dfminusZ;dfimag=dfminusZi

min_val=min(as.numeric(dfreal$V1));max_val=max(as.numeric(dfreal$V1))
dfimag=dfimag[dfimag$V1 %in% dfreal$V1,]

fft_minusZ = stats::fft(dfreal$V2+1i*dfimag$V2)

dfreal_minus=dfreal
dfimag_minus=dfimag

lenf=dim(dfreal)[1]

n=dim(dfreal)[1]

min_freq=min(as.numeric(substr(dfreal$V1,1,12)))
max_freq=max(as.numeric(substr(dfreal$V1,1,12)))
delta_fft=max(as.numeric(substr(dfreal$V1,1,12)))-min(as.numeric(substr(dfreal$V1,1,12)))


#symmetric formula when sigma=0.5
#for spectral filtering of first quiescent region based Euler Product

fft_hybrid=c(1/2*(fft_plusZ[1]+fft_minusZ[1]),(fft_plusZ)[2:(ceiling(n/2)+0)],1/2*(fft_plusZ[ceiling(n/2)+1]+fft_minusZ[ceiling(n/2)+1]),fft_minusZ[(ceiling(n/2)+2):n])
inv_hybrid=fft(fft_hybrid,inverse=TRUE)

yspan=range(Re(inv_hybrid)/n,Im(inv_hybrid)/n)
plot(as.numeric(substr(dfreal$V1,1,22)),Re(inv_hybrid)/n,typ="l",
     ylim=c(-4,6),xlab="t",main="Riemann Siegel Z function analogue (using spectral filtered Euler Product) of \n Riemann Zeta function using 13 upwards for all t",xlim=c(-40,40)+0,col="gray",cex.main=0.6);grid(col="gray")#,ylim=c(-.75,15),,xlim=c(100055,100060),xlim=c(100170,100173)
lines(as.numeric(substr(dfimag$V1,1,22)),Im(inv_hybrid)/n,col="blue")
lines(as.numeric(substr(dfZi$V1,1,22)),Re(dfZ$V2),col="magenta",lty=2)
lines(as.numeric(substr(dfZ$V1,1,22)),Re(dfZi$V2),col="cyan",lty=2)

plot(as.numeric(substr(dfreal$V1,1,22)),Re(inv_hybrid)/n-Re(dfZ$V2),typ="l",xlab="t",ylab="Error",main="Error in real(Z) component (using spectral filtered Euler Product approximation) of \n Riemann Zeta Z function using max(1,floor(1.25*sqrt(t/2/pi*1))) in EP",col="darkgreen",cex.main=0.8);grid(col="gray2")
text(x=250,y=-0.5,"as shown the error in the zeta Z EP \n approximation around t=0 is NOT resolved \n by adding primes to EP",cex=0.7)

```





\clearpage



```{r Zfnzeta_andtruncatedEPfouriertransform_0_pm750_p9, echo=FALSE, fig.cap="Lefthand panel - True Z function shown in magenta (cyan) for real (imaginary) parts and spectral filtered based EP approximation shown in black (blue) for real (imaginary) parts, Right hand panel - Error in the real(Z) EP approximation. A comparison of the Riemann-Siegel Z function of the Riemann Zeta L-function and spectrally filtered partial Euler Product (using truncation at $\\max (P,\\sqrt{((\\frac{t}{2\\pi})^1\\cdot 1}) $) in the complex plane at $\\sigma=0.1$ for the interval t=(-750,750) where $P_{min}={1,2,3,5,13}$ for rows 1-5. The approximation error around t=0 only increases by adding primes.", out.width = c("49%","49%"), fig.show = "hold",  fig.height=3.8, warning=FALSE, cache=TRUE}

# Riemann-Siegel Z function of Riemann Zeta function on critical line
# values recorded every .01 spacing in interval [-750,+750]

dfZ=read.csv("/home/john/pari/Zzeta_res_p9_0_m750_p750_spacing_p01_real.csv",header=FALSE,colClasses = c("character"));
dfZ$V2=as.numeric(gsub(" ","",dfZ$V2));
dfZ=dfZ[order(as.numeric(dfZ$V1)),]

dfZi=read.csv("/home/john/pari/Zzeta_res_p9_0_m750_p750_spacing_p01_imag.csv",header=FALSE,colClasses = c("character"));
dfZi$V2=as.numeric(gsub(" ","",dfZi$V2));
dfZi=dfZi[order(as.numeric(dfZi$V1)),]


#Riemann-Siegel Z function of truncated Euler product at first quiescent region
#first component of riemann-siegel formula based on first quiescent region
#EP(sigma+i*t)*exp(i*theta)
#using 0 extra integers in prodeuler pari-gp function

dfplusZ=read.csv("/home/john/pari/Zplus_EPonly_res_p9_0_m750_p750_0extra_spacing_p01_real.csv",header=FALSE,colClasses = c("character"));
dfplusZ$V2=as.numeric(gsub(" ","",dfplusZ$V2));
dfplusZ=dfplusZ[order(as.numeric(dfplusZ$V1)),]

dfplusZi=read.csv("/home/john/pari/Zplus_EPonly_res_p9_0_m750_p750_0extra_spacing_p01_imag.csv",header=FALSE,colClasses = c("character"));
dfplusZi$V2=as.numeric(gsub(" ","",dfplusZi$V2));
dfplusZi=dfplusZi[order(as.numeric(dfplusZi$V1)),]

dfreal=dfplusZ;dfimag=dfplusZi

min_val=min(as.numeric(dfreal$V1));max_val=max(as.numeric(dfreal$V1))
dfimag=dfimag[(dfimag$V1 %in% dfreal$V1),]


fft_plusZ = stats::fft(dfreal$V2+1i*dfimag$V2)

dfreal_plus=dfreal
dfimag_plus=dfimag

lenf2=length(fft_plusZ)
delta_fft2=max(as.numeric(substr(dfreal$V1,1,12)))-min(as.numeric(substr(dfreal$V1,1,12)))
n=lenf2

#second component of riemann-siegel formula based on first quiescent region
#EP(1-(sigma+i*t))*chi(sigma+i*t)*exp(i*theta)
#using 0 extra integers in prodeuler pari-gp function

dfminusZ=read.csv("/home/john/pari/Zminus_EPonly_res_p9_0_m750_p750_0extra_spacing_p01_real.csv",header=FALSE,colClasses = c("character"));
dfminusZ$V2=as.numeric(gsub(" ","",dfminusZ$V2));
dfminusZ=dfminusZ[order(as.numeric(dfminusZ$V1)),]

dfminusZi=read.csv("/home/john/pari/Zminus_EPonly_res_p9_0_m750_p750_0extra_spacing_p01_imag.csv",header=FALSE,colClasses = c("character"));
dfminusZi$V2=as.numeric(gsub(" ","",dfminusZi$V2));
dfminusZi=dfminusZi[order(as.numeric(dfminusZi$V1)),]

dfreal=dfminusZ;dfimag=dfminusZi

min_val=min(as.numeric(dfreal$V1));max_val=max(as.numeric(dfreal$V1))
dfimag=dfimag[dfimag$V1 %in% dfreal$V1,]

fft_minusZ = stats::fft(dfreal$V2+1i*dfimag$V2)

dfreal_minus=dfreal
dfimag_minus=dfimag

lenf=dim(dfreal)[1]

n=dim(dfreal)[1]

min_freq=min(as.numeric(substr(dfreal$V1,1,12)))
max_freq=max(as.numeric(substr(dfreal$V1,1,12)))
delta_fft=max(as.numeric(substr(dfreal$V1,1,12)))-min(as.numeric(substr(dfreal$V1,1,12)))


#symmetric formula when sigma=0.5
#for spectral filtering of first quiescent region based Euler Product

fft_hybrid=c(1/2*(fft_plusZ[1]+fft_minusZ[1]),(fft_plusZ)[2:(ceiling(n/2)+0)],1/2*(fft_plusZ[ceiling(n/2)+1]+fft_minusZ[ceiling(n/2)+1]),fft_minusZ[(ceiling(n/2)+2):n])
inv_hybrid=fft(fft_hybrid,inverse=TRUE)

yspan=range(Re(inv_hybrid)/n,Im(inv_hybrid)/n)
plot(as.numeric(substr(dfreal$V1,1,22)),Re(inv_hybrid)/n,typ="l",
     ylim=c(-4,6),xlab="t",main="Riemann Siegel Z function analogue (using spectral filtered Euler Product) of \n Riemann Zeta function using floor(1.25*sqrt(t)/2/pi) upwards in EP",xlim=c(-40,40)+0,col="gray",cex.main=0.6);grid(col="gray")#,ylim=c(-.75,15),,xlim=c(100055,100060),xlim=c(100170,100173)
lines(as.numeric(substr(dfimag$V1,1,22)),Im(inv_hybrid)/n,col="blue")
lines(as.numeric(substr(dfZ$V1,1,22)),Re(dfZ$V2),col="magenta",lty=2)
lines(as.numeric(substr(dfZ$V1,1,22)),Re(dfZi$V2),col="cyan",lty=2)
lines(-rep((2/1.25)^2*2*pi/1,2),c(-0.5,0.5),lty=2,col="blue")
lines(rep((2/1.25)^2*2*pi/1,2),c(-0.5,0.5),lty=2,col="blue")
text(x=c(-1,1)*(2/1.25)^2*2*pi/1,y=-.67,"2")
text(x=0,y=-2,"t value when next prime is included in EP")
lines(-rep((3/1.25)^2*2*pi/1,2),c(-1.5,-0.5),lty=2,col="blue")
lines(rep((3/1.25)^2*2*pi/1,2),c(-1.5,-0.5),lty=2,col="blue")
text(x=c(-1,1)*(3/1.25)^2*2*pi/1,y=-2,"3")

plot(as.numeric(substr(dfreal$V1,1,22)),Re(inv_hybrid)/n-Re(dfZ$V2),typ="l",xlab="t",ylab="Error",main="Error in real(Z) component (using spectral filtered Euler Product approximation) of \n Riemann Zeta Z function using max(1,floor(1.25*sqrt(t/2/pi*1))) in EP",col="gray",cex.main=0.8);grid(col="gray2")

#first component of riemann-siegel formula based on first quiescent region
#EP(sigma+i*t)*exp(i*theta)
#using 2 and upwards in prodeuler pari-gp function for all t

dfplusZ=read.csv("/home/john/pari/Zplus_EPonly_res_p9_0_m750_p750_2upwards_spacing_p01_real.csv",header=FALSE,colClasses = c("character"));
dfplusZ$V2=as.numeric(gsub(" ","",dfplusZ$V2));
dfplusZ=dfplusZ[order(as.numeric(dfplusZ$V1)),]

dfplusZi=read.csv("/home/john/pari/Zplus_EPonly_res_p9_0_m750_p750_2upwards_spacing_p01_imag.csv",header=FALSE,colClasses = c("character"));
dfplusZi$V2=as.numeric(gsub(" ","",dfplusZi$V2));
dfplusZi=dfplusZi[order(as.numeric(dfplusZi$V1)),]

dfreal=dfplusZ;dfimag=dfplusZi

min_val=min(as.numeric(dfreal$V1));max_val=max(as.numeric(dfreal$V1))
dfimag=dfimag[(dfimag$V1 %in% dfreal$V1),]


fft_plusZ = stats::fft(dfreal$V2+1i*dfimag$V2)

dfreal_plus=dfreal
dfimag_plus=dfimag

lenf2=length(fft_plusZ)
delta_fft2=max(as.numeric(substr(dfreal$V1,1,12)))-min(as.numeric(substr(dfreal$V1,1,12)))
n=lenf2

#second component of riemann-siegel formula based on first quiescent region
#EP(1-(sigma+i*t))*chi(sigma+i*t)*exp(i*theta)
#using 2 and upwards in prodeuler pari-gp function for all t

dfminusZ=read.csv("/home/john/pari/Zminus_EPonly_res_p9_0_m750_p750_2upwards_spacing_p01_real.csv",header=FALSE,colClasses = c("character"));
dfminusZ$V2=as.numeric(gsub(" ","",dfminusZ$V2));
dfminusZ=dfminusZ[order(as.numeric(dfminusZ$V1)),]

dfminusZi=read.csv("/home/john/pari/Zminus_EPonly_res_p9_0_m750_p750_2upwards_spacing_p01_imag.csv",header=FALSE,colClasses = c("character"));
dfminusZi$V2=as.numeric(gsub(" ","",dfminusZi$V2));
dfminusZi=dfminusZi[order(as.numeric(dfminusZi$V1)),]

dfreal=dfminusZ;dfimag=dfminusZi

min_val=min(as.numeric(dfreal$V1));max_val=max(as.numeric(dfreal$V1))
dfimag=dfimag[dfimag$V1 %in% dfreal$V1,]

fft_minusZ = stats::fft(dfreal$V2+1i*dfimag$V2)

dfreal_minus=dfreal
dfimag_minus=dfimag

lenf=dim(dfreal)[1]

n=dim(dfreal)[1]

min_freq=min(as.numeric(substr(dfreal$V1,1,12)))
max_freq=max(as.numeric(substr(dfreal$V1,1,12)))
delta_fft=max(as.numeric(substr(dfreal$V1,1,12)))-min(as.numeric(substr(dfreal$V1,1,12)))


#symmetric formula when sigma=0.5
#for spectral filtering of first quiescent region based Euler Product

fft_hybrid=c(1/2*(fft_plusZ[1]+fft_minusZ[1]),(fft_plusZ)[2:(ceiling(n/2)+0)],1/2*(fft_plusZ[ceiling(n/2)+1]+fft_minusZ[ceiling(n/2)+1]),fft_minusZ[(ceiling(n/2)+2):n])
inv_hybrid=fft(fft_hybrid,inverse=TRUE)

yspan=range(Re(inv_hybrid)/n,Im(inv_hybrid)/n)
plot(as.numeric(substr(dfreal$V1,1,22)),Re(inv_hybrid)/n,typ="l",
     ylim=c(-4,6),xlab="t",main="Riemann Siegel Z function analogue (using spectral filtered Euler Product) of \n Riemann Zeta function using 2 upwards for all t",xlim=c(-40,40)+0,col="gray",cex.main=0.6);grid(col="gray")#,ylim=c(-.75,15),,xlim=c(100055,100060),xlim=c(100170,100173)
lines(as.numeric(substr(dfimag$V1,1,22)),Im(inv_hybrid)/n,col="blue")
lines(as.numeric(substr(dfZ$V1,1,22)),Re(dfZ$V2),col="magenta",lty=2)
lines(as.numeric(substr(dfZ$V1,1,22)),Re(dfZi$V2),col="cyan",lty=2)
lines(-rep((3/1.25)^2*2*pi/1,2),c(-1.2,-0.2),lty=2,col="blue")
lines(rep((3/1.25)^2*2*pi/1,2),c(-1.2,-0.2),lty=2,col="blue")
text(x=c(-1,1)*(3/1.25)^2*2*pi/1,y=-1.5,"3")
text(x=0,y=-2,"t value when next prime is included in EP")

plot(as.numeric(substr(dfreal$V1,1,22)),Re(inv_hybrid)/n-Re(dfZ$V2),typ="l",xlab="t",ylab="Error",main="Error in real(Z) component (using spectral filtered Euler Product approximation) of \n Riemann Zeta Z function using max(1,floor(1.25*sqrt(t/2/pi*1))) in EP",col="darkgreen",cex.main=0.8);grid(col="gray2")
# lines(-rep((3/1.25)^2*2*pi/1,2),c(0.1,0.6),lty=2,col="blue")
# lines(-rep((5/1.25)^2*2*pi/1,2),c(-0.6,-0.1),lty=2,col="blue")
# lines(-rep((7/1.25)^2*2*pi/1,2),c(-0.6,-0.1),lty=2,col="blue")
# lines(rep((3/1.25)^2*2*pi/1,2),c(0.1,0.6),lty=2,col="blue")
# lines(rep((5/1.25)^2*2*pi/1,2),c(-0.6,-0.1),lty=2,col="blue")
# lines(rep((7/1.25)^2*2*pi/1,2),c(-0.6,-0.1),lty=2,col="blue")
# text(x=c(-1,1)*(3/1.25)^2*2*pi/1,y=0.8,"3")
# text(x=c(-1,1)*(5/1.25)^2*2*pi/1,y=-0.8,"5")
# text(x=c(-1,1)*(7/1.25)^2*2*pi/1,y=-0.8,"7")
# text(x=0,y=-1.2,"t value when next prime is included in EP")


#first component of riemann-siegel formula based on first quiescent region
#EP(sigma+i*t)*exp(i*theta)
#using 3 and upwards in prodeuler pari-gp function for all t

dfplusZ=read.csv("/home/john/pari/Zplus_EPonly_res_p9_0_m750_p750_3upwards_spacing_p01_real.csv",header=FALSE,colClasses = c("character"));
dfplusZ$V2=as.numeric(gsub(" ","",dfplusZ$V2));
dfplusZ=dfplusZ[order(as.numeric(dfplusZ$V1)),]

dfplusZi=read.csv("/home/john/pari/Zplus_EPonly_res_p9_0_m750_p750_3upwards_spacing_p01_imag.csv",header=FALSE,colClasses = c("character"));
dfplusZi$V2=as.numeric(gsub(" ","",dfplusZi$V2));
dfplusZi=dfplusZi[order(as.numeric(dfplusZi$V1)),]

dfreal=dfplusZ;dfimag=dfplusZi

min_val=min(as.numeric(dfreal$V1));max_val=max(as.numeric(dfreal$V1))
dfimag=dfimag[(dfimag$V1 %in% dfreal$V1),]


fft_plusZ = stats::fft(dfreal$V2+1i*dfimag$V2)

dfreal_plus=dfreal
dfimag_plus=dfimag

lenf2=length(fft_plusZ)
delta_fft2=max(as.numeric(substr(dfreal$V1,1,12)))-min(as.numeric(substr(dfreal$V1,1,12)))
n=lenf2

#second component of riemann-siegel formula based on first quiescent region
#EP(1-(sigma+i*t))*chi(sigma+i*t)*exp(i*theta)
#using 3 and upwards in prodeuler pari-gp function for all t

dfminusZ=read.csv("/home/john/pari/Zminus_EPonly_res_p9_0_m750_p750_3upwards_spacing_p01_real.csv",header=FALSE,colClasses = c("character"));
dfminusZ$V2=as.numeric(gsub(" ","",dfminusZ$V2));
dfminusZ=dfminusZ[order(as.numeric(dfminusZ$V1)),]

dfminusZi=read.csv("/home/john/pari/Zminus_EPonly_res_p9_0_m750_p750_3upwards_spacing_p01_imag.csv",header=FALSE,colClasses = c("character"));
dfminusZi$V2=as.numeric(gsub(" ","",dfminusZi$V2));
dfminusZi=dfminusZi[order(as.numeric(dfminusZi$V1)),]

dfreal=dfminusZ;dfimag=dfminusZi

min_val=min(as.numeric(dfreal$V1));max_val=max(as.numeric(dfreal$V1))
dfimag=dfimag[dfimag$V1 %in% dfreal$V1,]

fft_minusZ = stats::fft(dfreal$V2+1i*dfimag$V2)

dfreal_minus=dfreal
dfimag_minus=dfimag

lenf=dim(dfreal)[1]

n=dim(dfreal)[1]

min_freq=min(as.numeric(substr(dfreal$V1,1,12)))
max_freq=max(as.numeric(substr(dfreal$V1,1,12)))
delta_fft=max(as.numeric(substr(dfreal$V1,1,12)))-min(as.numeric(substr(dfreal$V1,1,12)))


#symmetric formula when sigma=0.5
#for spectral filtering of first quiescent region based Euler Product

fft_hybrid=c(1/2*(fft_plusZ[1]+fft_minusZ[1]),(fft_plusZ)[2:(ceiling(n/2)+0)],1/2*(fft_plusZ[ceiling(n/2)+1]+fft_minusZ[ceiling(n/2)+1]),fft_minusZ[(ceiling(n/2)+2):n])
inv_hybrid=fft(fft_hybrid,inverse=TRUE)

yspan=range(Re(inv_hybrid)/n,Im(inv_hybrid)/n)
plot(as.numeric(substr(dfreal$V1,1,22)),Re(inv_hybrid)/n,typ="l",
     ylim=c(-4,6),xlab="t",main="Riemann Siegel Z function analogue (using spectral filtered Euler Product) of \n Riemann Zeta function using 3 upwards for all t",xlim=c(-40,40)+0,col="gray",cex.main=0.6);grid(col="gray")#,ylim=c(-.75,15),,xlim=c(100055,100060),xlim=c(100170,100173)
lines(as.numeric(substr(dfimag$V1,1,22)),Im(inv_hybrid)/n,col="blue")
lines(as.numeric(substr(dfZi$V1,1,22)),Re(dfZ$V2),col="magenta",lty=2)
lines(as.numeric(substr(dfZ$V1,1,22)),Re(dfZi$V2),col="cyan",lty=2)

plot(as.numeric(substr(dfreal$V1,1,22)),Re(inv_hybrid)/n-Re(dfZ$V2),typ="l",xlab="t",ylab="Error",main="Error in real(Z) component (using spectral filtered Euler Product approximation) of \n Riemann Zeta Z function using max(1,floor(1.25*sqrt(t/2/pi*1))) in EP",col="darkgreen",cex.main=0.8);grid(col="gray2")
# lines(-rep((5/1.25)^2*2*pi/1,2),c(-0.6,-0.1),lty=2,col="blue")
# lines(-rep((7/1.25)^2*2*pi/1,2),c(-0.6,-0.1),lty=2,col="blue")
# lines(rep((5/1.25)^2*2*pi/1,2),c(-0.6,-0.1),lty=2,col="blue")
# lines(rep((7/1.25)^2*2*pi/1,2),c(-0.6,-0.1),lty=2,col="blue")
# text(x=c(-1,1)*(5/1.25)^2*2*pi/1,y=-0.8,"5")
# text(x=c(-1,1)*(7/1.25)^2*2*pi/1,y=-0.8,"7")
# text(x=0,y=-1.2,"t value when next prime is included in EP")


#first component of riemann-siegel formula based on first quiescent region
#EP(sigma+i*t)*exp(i*theta)
#using 5 and upwards in prodeuler pari-gp function for all t

dfplusZ=read.csv("/home/john/pari/Zplus_EPonly_res_p9_0_m750_p750_5upwards_spacing_p01_real.csv",header=FALSE,colClasses = c("character"));
dfplusZ$V2=as.numeric(gsub(" ","",dfplusZ$V2));
dfplusZ=dfplusZ[order(as.numeric(dfplusZ$V1)),]

dfplusZi=read.csv("/home/john/pari/Zplus_EPonly_res_p9_0_m750_p750_5upwards_spacing_p01_imag.csv",header=FALSE,colClasses = c("character"));
dfplusZi$V2=as.numeric(gsub(" ","",dfplusZi$V2));
dfplusZi=dfplusZi[order(as.numeric(dfplusZi$V1)),]

dfreal=dfplusZ;dfimag=dfplusZi

min_val=min(as.numeric(dfreal$V1));max_val=max(as.numeric(dfreal$V1))
dfimag=dfimag[(dfimag$V1 %in% dfreal$V1),]


fft_plusZ = stats::fft(dfreal$V2+1i*dfimag$V2)

dfreal_plus=dfreal
dfimag_plus=dfimag

lenf2=length(fft_plusZ)
delta_fft2=max(as.numeric(substr(dfreal$V1,1,12)))-min(as.numeric(substr(dfreal$V1,1,12)))
n=lenf2

#second component of riemann-siegel formula based on first quiescent region
#EP(1-(sigma+i*t))*chi(sigma+i*t)*exp(i*theta)
#using 5 and upwards in prodeuler pari-gp function for all t

dfminusZ=read.csv("/home/john/pari/Zminus_EPonly_res_p9_0_m750_p750_5upwards_spacing_p01_real.csv",header=FALSE,colClasses = c("character"));
dfminusZ$V2=as.numeric(gsub(" ","",dfminusZ$V2));
dfminusZ=dfminusZ[order(as.numeric(dfminusZ$V1)),]

dfminusZi=read.csv("/home/john/pari/Zminus_EPonly_res_p9_0_m750_p750_5upwards_spacing_p01_imag.csv",header=FALSE,colClasses = c("character"));
dfminusZi$V2=as.numeric(gsub(" ","",dfminusZi$V2));
dfminusZi=dfminusZi[order(as.numeric(dfminusZi$V1)),]

dfreal=dfminusZ;dfimag=dfminusZi

min_val=min(as.numeric(dfreal$V1));max_val=max(as.numeric(dfreal$V1))
dfimag=dfimag[dfimag$V1 %in% dfreal$V1,]

fft_minusZ = stats::fft(dfreal$V2+1i*dfimag$V2)

dfreal_minus=dfreal
dfimag_minus=dfimag

lenf=dim(dfreal)[1]

n=dim(dfreal)[1]

min_freq=min(as.numeric(substr(dfreal$V1,1,12)))
max_freq=max(as.numeric(substr(dfreal$V1,1,12)))
delta_fft=max(as.numeric(substr(dfreal$V1,1,12)))-min(as.numeric(substr(dfreal$V1,1,12)))


#symmetric formula when sigma=0.5
#for spectral filtering of first quiescent region based Euler Product

fft_hybrid=c(1/2*(fft_plusZ[1]+fft_minusZ[1]),(fft_plusZ)[2:(ceiling(n/2)+0)],1/2*(fft_plusZ[ceiling(n/2)+1]+fft_minusZ[ceiling(n/2)+1]),fft_minusZ[(ceiling(n/2)+2):n])
inv_hybrid=fft(fft_hybrid,inverse=TRUE)

yspan=range(Re(inv_hybrid)/n,Im(inv_hybrid)/n)
plot(as.numeric(substr(dfreal$V1,1,22)),Re(inv_hybrid)/n,typ="l",
     ylim=c(-4,6),xlab="t",main="Riemann Siegel Z function analogue (using spectral filtered Euler Product) of \n Riemann Zeta function using 5 upwards for all t",xlim=c(-40,40)+0,col="gray",cex.main=0.6);grid(col="gray")#,ylim=c(-.75,15),,xlim=c(100055,100060),xlim=c(100170,100173)
lines(as.numeric(substr(dfimag$V1,1,22)),Im(inv_hybrid)/n,col="blue")
lines(as.numeric(substr(dfZi$V1,1,22)),Re(dfZ$V2),col="magenta",lty=2)
lines(as.numeric(substr(dfZ$V1,1,22)),Re(dfZi$V2),col="cyan",lty=2)

plot(as.numeric(substr(dfreal$V1,1,22)),Re(inv_hybrid)/n-Re(dfZ$V2),typ="l",xlab="t",ylab="Error",main="Error in real(Z) component (using spectral filtered Euler Product approximation) of \n Riemann Zeta Z function using max(1,floor(1.25*sqrt(t/2/pi*1))) in EP",col="darkgreen",cex.main=0.8);grid(col="gray2")
# lines(-rep((7/1.25)^2*2*pi/1,2),c(-0.6,-0.1),lty=2,col="blue")
# lines(rep((7/1.25)^2*2*pi/1,2),c(-0.6,-0.1),lty=2,col="blue")
# text(x=c(-1,1)*(7/1.25)^2*2*pi/1,y=-0.8,"7")
# text(x=0,y=-1.2,"t value when next prime is included in EP")
# lines(-rep((11/1.25)^2*2*pi/1,2),c(-0.6,-0.1),lty=2,col="blue")
# lines(rep((11/1.25)^2*2*pi/1,2),c(-0.6,-0.1),lty=2,col="blue")
# text(x=c(-1,1)*(11/1.25)^2*2*pi/1,y=-0.8,"11")
# lines(-rep((13/1.25)^2*2*pi/1,2),c(0.05,0.45),lty=2,col="blue")
# lines(rep((13/1.25)^2*2*pi/1,2),c(0.05,0.45),lty=2,col="blue")
# text(x=c(-1,1)*(13/1.25)^2*2*pi/1,y=0.6,"13")


#first component of riemann-siegel formula based on first quiescent region
#EP(sigma+i*t)*exp(i*theta)
#using 13 and upwards in prodeuler pari-gp function for all t

dfplusZ=read.csv("/home/john/pari/Zplus_EPonly_res_p9_0_m750_p750_13upwards_spacing_p01_real.csv",header=FALSE,colClasses = c("character"));
dfplusZ$V2=as.numeric(gsub(" ","",dfplusZ$V2));
dfplusZ=dfplusZ[order(as.numeric(dfplusZ$V1)),]

dfplusZi=read.csv("/home/john/pari/Zplus_EPonly_res_p9_0_m750_p750_13upwards_spacing_p01_imag.csv",header=FALSE,colClasses = c("character"));
dfplusZi$V2=as.numeric(gsub(" ","",dfplusZi$V2));
dfplusZi=dfplusZi[order(as.numeric(dfplusZi$V1)),]

dfreal=dfplusZ;dfimag=dfplusZi

min_val=min(as.numeric(dfreal$V1));max_val=max(as.numeric(dfreal$V1))
dfimag=dfimag[(dfimag$V1 %in% dfreal$V1),]


fft_plusZ = stats::fft(dfreal$V2+1i*dfimag$V2)

dfreal_plus=dfreal
dfimag_plus=dfimag

lenf2=length(fft_plusZ)
delta_fft2=max(as.numeric(substr(dfreal$V1,1,12)))-min(as.numeric(substr(dfreal$V1,1,12)))
n=lenf2

#second component of riemann-siegel formula based on first quiescent region
#EP(1-(sigma+i*t))*chi(sigma+i*t)*exp(i*theta)
#using 5 and upwards in prodeuler pari-gp function for all t

dfminusZ=read.csv("/home/john/pari/Zminus_EPonly_res_p9_0_m750_p750_13upwards_spacing_p01_real.csv",header=FALSE,colClasses = c("character"));
dfminusZ$V2=as.numeric(gsub(" ","",dfminusZ$V2));
dfminusZ=dfminusZ[order(as.numeric(dfminusZ$V1)),]

dfminusZi=read.csv("/home/john/pari/Zminus_EPonly_res_p9_0_m750_p750_13upwards_spacing_p01_imag.csv",header=FALSE,colClasses = c("character"));
dfminusZi$V2=as.numeric(gsub(" ","",dfminusZi$V2));
dfminusZi=dfminusZi[order(as.numeric(dfminusZi$V1)),]

dfreal=dfminusZ;dfimag=dfminusZi

min_val=min(as.numeric(dfreal$V1));max_val=max(as.numeric(dfreal$V1))
dfimag=dfimag[dfimag$V1 %in% dfreal$V1,]

fft_minusZ = stats::fft(dfreal$V2+1i*dfimag$V2)

dfreal_minus=dfreal
dfimag_minus=dfimag

lenf=dim(dfreal)[1]

n=dim(dfreal)[1]

min_freq=min(as.numeric(substr(dfreal$V1,1,12)))
max_freq=max(as.numeric(substr(dfreal$V1,1,12)))
delta_fft=max(as.numeric(substr(dfreal$V1,1,12)))-min(as.numeric(substr(dfreal$V1,1,12)))


#symmetric formula when sigma=0.5
#for spectral filtering of first quiescent region based Euler Product

fft_hybrid=c(1/2*(fft_plusZ[1]+fft_minusZ[1]),(fft_plusZ)[2:(ceiling(n/2)+0)],1/2*(fft_plusZ[ceiling(n/2)+1]+fft_minusZ[ceiling(n/2)+1]),fft_minusZ[(ceiling(n/2)+2):n])
inv_hybrid=fft(fft_hybrid,inverse=TRUE)

yspan=range(Re(inv_hybrid)/n,Im(inv_hybrid)/n)
plot(as.numeric(substr(dfreal$V1,1,22)),Re(inv_hybrid)/n,typ="l",
     ylim=c(-4,6),xlab="t",main="Riemann Siegel Z function analogue (using spectral filtered Euler Product) of \n Riemann Zeta function using 13 upwards for all t",xlim=c(-40,40)+0,col="gray",cex.main=0.6);grid(col="gray")#,ylim=c(-.75,15),,xlim=c(100055,100060),xlim=c(100170,100173)
lines(as.numeric(substr(dfimag$V1,1,22)),Im(inv_hybrid)/n,col="blue")
lines(as.numeric(substr(dfZi$V1,1,22)),Re(dfZ$V2),col="magenta",lty=2)
lines(as.numeric(substr(dfZ$V1,1,22)),Re(dfZi$V2),col="cyan",lty=2)

plot(as.numeric(substr(dfreal$V1,1,22)),Re(inv_hybrid)/n-Re(dfZ$V2),typ="l",xlab="t",ylab="Error",main="Error in real(Z) component (using spectral filtered Euler Product approximation) of \n Riemann Zeta Z function using max(1,floor(1.25*sqrt(t/2/pi*1))) in EP",col="darkgreen",cex.main=0.8);grid(col="gray2")
text(x=250,y=-0.5,"as shown the error in the zeta Z EP \n approximation around t=0 is NOT resolved \n by adding primes to EP",cex=0.7)

```





\clearpage


## Appendix B - Examining discrete inverse fourier transform of a spectrally filtered hybrid combination of (i) the Riemann Zeta function Laurent series for t=(-4,4), (ii) the spectral filtered first quiescent region partial Euler Product approximation for 5 < abs(t) < 750 and (iii) a smoothstep linear combination of the two functions for 4 < abs(t) < 5.

To deal with the pole at s=1, one hybrid solution would be to combine the Riemann Zeta Laurent Series [2,3] for t~(-4,4) with the two components of the partial Euler Product approximation equation (32) for ~5 < abs(t) < 750 and then use a smoothstep function to join the two formula in the region ~4 <= abs(t) ~5.

In this attempt, the following 6th order Riemann Zeta laurent series was used 

\begin{verbatim}
zeta_laurentseries(s)=(1^(1-(s))/(s-1)+\gamma+(-1)^1*-0.07281584*(z-1)+
(-1)^2*-0.009690363/2*(z-1)^2+(-1)^3*0.002053834/6*(z-1)^3+(-1)^4*0.00232537/24*(z-1)^4+
(-1)^5*0.0007933238/factorial(5)*(z-1)^5+(-1)^6*-0.00023876693/factorial(6)*(z-1)^6)+...
\end{verbatim}

alongwith a second order smoothstep function 

\begin{verbatim}
delta(dt)=6*dt^5-15*dt^4+10*dt^3;
\end{verbatim}

with the joining interval for the smoothstep function being placed at $\Delta t=(1.5\cdot\pi,1.5\cdot\pi+1)$.

After performing fourier analysis of the hybrid versions of the two components of equation (32), figures 17, 18, 19 respectively illustrate in the lefthand panels, the performance of the averaged inverse fourier transform around the real axis compared to the real (imaginary) parts of the true Riemann-Siegel Z function shown in magenta (cyan) at the fourier grid spacing 0.01. That is, in the lefthand panels of figures 14, 15, 16 the following interval is displayed for five different values of the minimum prime in partial Euler product calculation $P_{min}=\left\lfloor 1.25\cdot \max\left(\{1,2,3,5,13\},\sqrt{(\frac{t}{2\pi})^d\cdot N_C}\right)\right\rfloor$ with each row (top to bottom) respectively belonging to the minimum prime value \{1,2,3,5,13\} which is active when t=0.

(i) $s=(0.5-I\cdot 40,0.5+I\cdot 40)$ 

(ii) $s=(0.9-I\cdot 40,0.9+I\cdot 40)$ and 

(iii) $s=(0.1-I\cdot 40,0.1+I\cdot 40)$ 

following the fourth step of the fourier analysis procedure described earlier in this paper. When $P_{min}=1$, the partial Euler Product returns the value unity.   

In the righthand panels, the approximation error (real(spectrally filtered, spliced inverse fourier transform based approximation)-real(Z)) is displayed over the entire span of the input spectra

(i) $s=(0.5-I\cdot 750,0.5+I\cdot 750)$ 

(ii) $s=(0.9-I\cdot 750,0.9+I\cdot 750)$ and 

(iii) $s=(0.1-I\cdot 750,0.1+I\cdot 750)$ 

and there are clear error peaks that can be associated with discontinuous changes in $P_{min}$. The errors at each end $\pm750$ occur due to the rectangular window used for the input spectra. 

It can be seen from figures 17, 18 and 19 

(i) in the lefthand panels that there a lot of visual overlap of the grid of true Riemann-Siegel Z function values with the partial Euler Product based approximation including t=0 except for (i) regions with discontinuities in the real (gray) or blue (imaginary) waveforms of the approximation or (ii) the region (4 < abs(t) < 5) where the smoothstep joint exists. The presence of the discontinuites reduces (in the lower rows) as $P_{min}$ is increased. 

(ii) in the righthand panels the magnitude of the errors in the real part of the approximation with respect to the true function values are shown and the peaks in approximation errors are observed to be removed as $P_{min}$ is increased except for the region (4 < abs(t) < 5) where the smoothstep joint exists. 

(iii) In the bottom row with as $P_{min}=13$ the approximation has a smooth performance with low errors across the entire $\pm750$ span of the input spectra except for the effect of the rectangular window of the input spectra. The value $P_{min}=13$ corresponds to the maximum prime required in the zeroth order Riemann-Siegel formula for the maximum |t| value of the input spectra $13=\left\lfloor 1.25\cdot \sqrt{(\frac{750}{2\pi})^1\cdot 1}\right\rfloor$. 






```{r Zfnzeta_andtruncatedEPfouriertransform_0_pm750_LaurentSerieshybrid, echo=FALSE, fig.cap="Lefthand panel - True Z function shown in magenta (cyan) for real (imaginary) parts and hybrid spectral filtered based EP/Laurent Series approximation shown in black (blue) for real (imaginary) parts, Right hand panel - Error in the real(Z) EP approximation. A comparison of the Riemann-Siegel Z function of the Riemann Zeta L-function and spectrally filtered partial Euler Product/Laurent Series (using truncation at $\\max (P,\\sqrt{((\\frac{t}{2\\pi})^1\\cdot 1}) $) in the complex plane at $\\sigma=0.5$ for the interval t=(-750,750) where $P_{min}={1,2,3,5,13}$ for rows 1-5.", out.width = c("49%","49%"), fig.show = "hold",  fig.height=3.8, warning=FALSE, cache=TRUE}

# Riemann-Siegel Z function of Riemann Zeta function on critical line
# values recorded every .01 spacing in interval [-750,+750]

dfZ=read.csv("/home/john/pari/Zzeta_res_p5_0_m750_p750_spacing_p01_real.csv",header=FALSE,colClasses = c("character"));
dfZ$V2=as.numeric(gsub(" ","",dfZ$V2));
dfZ=dfZ[order(as.numeric(dfZ$V1)),]

dfZi=read.csv("/home/john/pari/Zzeta_res_p5_0_m750_p750_spacing_p01_imag.csv",header=FALSE,colClasses = c("character"));
dfZi$V2=as.numeric(gsub(" ","",dfZi$V2));
dfZi=dfZi[order(as.numeric(dfZi$V1)),]


#Riemann-Siegel Z function of truncated Euler product at first quiescent region
#first component of riemann-siegel formula based on first quiescent region
#EP(sigma+i*t)*exp(i*theta)
#using 0 extra integers in prodeuler pari-gp function

dfplusZ=read.csv("/home/john/pari/Zplus_EP_res_p5_0_m750_p750_0extra_spacing_p01_real.csv",header=FALSE,colClasses = c("character"));
dfplusZ$V2=as.numeric(gsub(" ","",dfplusZ$V2));
dfplusZ=dfplusZ[order(as.numeric(dfplusZ$V1)),]

dfplusZi=read.csv("/home/john/pari/Zplus_EP_res_p5_0_m750_p750_0extra_spacing_p01_imag.csv",header=FALSE,colClasses = c("character"));
dfplusZi$V2=as.numeric(gsub(" ","",dfplusZi$V2));
dfplusZi=dfplusZi[order(as.numeric(dfplusZi$V1)),]

dfreal=dfplusZ;dfimag=dfplusZi

min_val=min(as.numeric(dfreal$V1));max_val=max(as.numeric(dfreal$V1))
dfimag=dfimag[(dfimag$V1 %in% dfreal$V1),]


fft_plusZ = stats::fft(dfreal$V2+1i*dfimag$V2)

dfreal_plus=dfreal
dfimag_plus=dfimag

lenf2=length(fft_plusZ)
delta_fft2=max(as.numeric(substr(dfreal$V1,1,12)))-min(as.numeric(substr(dfreal$V1,1,12)))
n=lenf2

#second component of riemann-siegel formula based on first quiescent region
#EP(1-(sigma+i*t))*chi(sigma+i*t)*exp(i*theta)
#using 0 extra integers in prodeuler pari-gp function

dfminusZ=read.csv("/home/john/pari/Zminus_EP_res_p5_0_m750_p750_0extra_spacing_p01_real.csv",header=FALSE,colClasses = c("character"));
dfminusZ$V2=as.numeric(gsub(" ","",dfminusZ$V2));
dfminusZ=dfminusZ[order(as.numeric(dfminusZ$V1)),]

dfminusZi=read.csv("/home/john/pari/Zminus_EP_res_p5_0_m750_p750_0extra_spacing_p01_imag.csv",header=FALSE,colClasses = c("character"));
dfminusZi$V2=as.numeric(gsub(" ","",dfminusZi$V2));
dfminusZi=dfminusZi[order(as.numeric(dfminusZi$V1)),]

dfreal=dfminusZ;dfimag=dfminusZi

min_val=min(as.numeric(dfreal$V1));max_val=max(as.numeric(dfreal$V1))
dfimag=dfimag[dfimag$V1 %in% dfreal$V1,]

fft_minusZ = stats::fft(dfreal$V2+1i*dfimag$V2)

dfreal_minus=dfreal
dfimag_minus=dfimag

lenf=dim(dfreal)[1]

n=dim(dfreal)[1]

min_freq=min(as.numeric(substr(dfreal$V1,1,12)))
max_freq=max(as.numeric(substr(dfreal$V1,1,12)))
delta_fft=max(as.numeric(substr(dfreal$V1,1,12)))-min(as.numeric(substr(dfreal$V1,1,12)))


#symmetric formula when sigma=0.5
#for spectral filtering of first quiescent region based Euler Product

fft_hybrid=c(Re(fft_plusZ[1]),(fft_plusZ)[2:(ceiling(n/2)+0)],Re(fft_plusZ)[ceiling(n/2)+1],Conj(rev(c((fft_plusZ)[2:floor(n/2)]))))
inv_hybrid=fft(fft_hybrid,inverse=TRUE)

yspan=range(Re(inv_hybrid)/n,Im(inv_hybrid)/n)
plot(as.numeric(substr(dfreal$V1,1,22)),Re(inv_hybrid)/n,typ="l",
     ylim=c(-2,3),xlab="t",main="Riemann Siegel Z function analogue (using spectral filtered Euler Product) of \n Riemann Zeta function using floor(1.25*sqrt(t)/2/pi) upwards in EP",xlim=c(-40,40)+0,col="gray",cex.main=0.6);grid(col="gray")#,ylim=c(-.75,15),,xlim=c(100055,100060),xlim=c(100170,100173)
lines(as.numeric(substr(dfimag$V1,1,22)),Im(inv_hybrid)/n,col="blue")
lines(as.numeric(substr(dfZ$V1,1,22)),Re(dfZ$V2),col="magenta",lty=2)
lines(as.numeric(substr(dfZ$V1,1,22)),Re(dfZi$V2),col="cyan",lty=2)
lines(-rep((2/1.25)^2*2*pi/1,2),c(-0.5,0.5),lty=2,col="blue")
lines(rep((2/1.25)^2*2*pi/1,2),c(-0.5,0.5),lty=2,col="blue")
text(x=c(-1,1)*(2/1.25)^2*2*pi/1,y=-.67,"2")
text(x=0,y=-2,"t value when next prime is included in EP")
lines(-rep((3/1.25)^2*2*pi/1,2),c(-1.5,-0.5),lty=2,col="blue")
lines(rep((3/1.25)^2*2*pi/1,2),c(-1.5,-0.5),lty=2,col="blue")
text(x=c(-1,1)*(3/1.25)^2*2*pi/1,y=-2,"3")

plot(as.numeric(substr(dfreal$V1,1,22)),Re(inv_hybrid)/n-Re(dfZ$V2),typ="l",xlab="t",ylab="Error",main="Error in real(Z) component (using spectral filtered Euler Product approximation) of \n Riemann Zeta Z function using max(1,floor(1.25*sqrt(t/2/pi*1))) in EP",col="gray",cex.main=0.8);grid(col="gray2")

#first component of riemann-siegel formula based on first quiescent region
#EP(sigma+i*t)*exp(i*theta)
#using 2 and upwards in prodeuler pari-gp function for all t

dfplusZ=read.csv("/home/john/pari/Zplus_EP_res_p5_0_m750_p750_2upwards_spacing_p01_real.csv",header=FALSE,colClasses = c("character"));
dfplusZ$V2=as.numeric(gsub(" ","",dfplusZ$V2));
dfplusZ=dfplusZ[order(as.numeric(dfplusZ$V1)),]

dfplusZi=read.csv("/home/john/pari/Zplus_EP_res_p5_0_m750_p750_2upwards_spacing_p01_imag.csv",header=FALSE,colClasses = c("character"));
dfplusZi$V2=as.numeric(gsub(" ","",dfplusZi$V2));
dfplusZi=dfplusZi[order(as.numeric(dfplusZi$V1)),]

dfreal=dfplusZ;dfimag=dfplusZi

min_val=min(as.numeric(dfreal$V1));max_val=max(as.numeric(dfreal$V1))
dfimag=dfimag[(dfimag$V1 %in% dfreal$V1),]


fft_plusZ = stats::fft(dfreal$V2+1i*dfimag$V2)

dfreal_plus=dfreal
dfimag_plus=dfimag

lenf2=length(fft_plusZ)
delta_fft2=max(as.numeric(substr(dfreal$V1,1,12)))-min(as.numeric(substr(dfreal$V1,1,12)))
n=lenf2

#second component of riemann-siegel formula based on first quiescent region
#EP(1-(sigma+i*t))*chi(sigma+i*t)*exp(i*theta)
#using 2 and upwards in prodeuler pari-gp function for all t

dfminusZ=read.csv("/home/john/pari/Zminus_EP_res_p5_0_m750_p750_2upwards_spacing_p01_real.csv",header=FALSE,colClasses = c("character"));
dfminusZ$V2=as.numeric(gsub(" ","",dfminusZ$V2));
dfminusZ=dfminusZ[order(as.numeric(dfminusZ$V1)),]

dfminusZi=read.csv("/home/john/pari/Zminus_EP_res_p5_0_m750_p750_2upwards_spacing_p01_imag.csv",header=FALSE,colClasses = c("character"));
dfminusZi$V2=as.numeric(gsub(" ","",dfminusZi$V2));
dfminusZi=dfminusZi[order(as.numeric(dfminusZi$V1)),]

dfreal=dfminusZ;dfimag=dfminusZi

min_val=min(as.numeric(dfreal$V1));max_val=max(as.numeric(dfreal$V1))
dfimag=dfimag[dfimag$V1 %in% dfreal$V1,]

fft_minusZ = stats::fft(dfreal$V2+1i*dfimag$V2)

dfreal_minus=dfreal
dfimag_minus=dfimag

lenf=dim(dfreal)[1]

n=dim(dfreal)[1]

min_freq=min(as.numeric(substr(dfreal$V1,1,12)))
max_freq=max(as.numeric(substr(dfreal$V1,1,12)))
delta_fft=max(as.numeric(substr(dfreal$V1,1,12)))-min(as.numeric(substr(dfreal$V1,1,12)))


#symmetric formula when sigma=0.5
#for spectral filtering of first quiescent region based Euler Product

fft_hybrid=c(Re(fft_plusZ[1]),(fft_plusZ)[2:(ceiling(n/2)+0)],Re(fft_plusZ)[ceiling(n/2)+1],Conj(rev(c((fft_plusZ)[2:floor(n/2)]))))
inv_hybrid=fft(fft_hybrid,inverse=TRUE)

yspan=range(Re(inv_hybrid)/n,Im(inv_hybrid)/n)
plot(as.numeric(substr(dfreal$V1,1,22)),Re(inv_hybrid)/n,typ="l",
     ylim=c(-2,3),xlab="t",main="Riemann Siegel Z function analogue (using spectral filtered Euler Product) of \n Riemann Zeta function using 2 upwards for all t",xlim=c(-40,40)+0,col="gray",cex.main=0.6);grid(col="gray")#,ylim=c(-.75,15),,xlim=c(100055,100060),xlim=c(100170,100173)
lines(as.numeric(substr(dfimag$V1,1,22)),Im(inv_hybrid)/n,col="blue")
lines(as.numeric(substr(dfZ$V1,1,22)),Re(dfZ$V2),col="magenta",lty=2)
lines(as.numeric(substr(dfZ$V1,1,22)),Re(dfZi$V2),col="cyan",lty=2)
lines(-rep((3/1.25)^2*2*pi/1,2),c(-1.2,-0.2),lty=2,col="blue")
lines(rep((3/1.25)^2*2*pi/1,2),c(-1.2,-0.2),lty=2,col="blue")
text(x=c(-1,1)*(3/1.25)^2*2*pi/1,y=-1.5,"3")
text(x=0,y=-2,"t value when next prime is included in EP")

plot(as.numeric(substr(dfreal$V1,1,22)),Re(inv_hybrid)/n-Re(dfZ$V2),typ="l",xlab="t",ylab="Error",main="Error in real(Z) component (using spectral filtered Euler Product approximation) of \n Riemann Zeta Z function using max(1,floor(1.25*sqrt(t/2/pi*1))) in EP",col="gray",cex.main=0.8);grid(col="gray2")
lines(-rep((3/1.25)^2*2*pi/1,2),c(0.1,0.6),lty=2,col="blue")
lines(-rep((5/1.25)^2*2*pi/1,2),c(-0.6,-0.1),lty=2,col="blue")
lines(-rep((7/1.25)^2*2*pi/1,2),c(-0.6,-0.1),lty=2,col="blue")
lines(rep((3/1.25)^2*2*pi/1,2),c(0.1,0.6),lty=2,col="blue")
lines(rep((5/1.25)^2*2*pi/1,2),c(-0.6,-0.1),lty=2,col="blue")
lines(rep((7/1.25)^2*2*pi/1,2),c(-0.6,-0.1),lty=2,col="blue")
text(x=c(-1,1)*(3/1.25)^2*2*pi/1,y=0.8,"3")
text(x=c(-1,1)*(5/1.25)^2*2*pi/1,y=-0.8,"5")
text(x=c(-1,1)*(7/1.25)^2*2*pi/1,y=-0.8,"7")
text(x=0,y=-1.2,"t value when next prime is included in EP")


#first component of riemann-siegel formula based on first quiescent region
#EP(sigma+i*t)*exp(i*theta)
#using 3 and upwards in prodeuler pari-gp function for all t

dfplusZ=read.csv("/home/john/pari/Zplus_EP_res_p5_0_m750_p750_3upwards_spacing_p01_real.csv",header=FALSE,colClasses = c("character"));
dfplusZ$V2=as.numeric(gsub(" ","",dfplusZ$V2));
dfplusZ=dfplusZ[order(as.numeric(dfplusZ$V1)),]

dfplusZi=read.csv("/home/john/pari/Zplus_EP_res_p5_0_m750_p750_3upwards_spacing_p01_imag.csv",header=FALSE,colClasses = c("character"));
dfplusZi$V2=as.numeric(gsub(" ","",dfplusZi$V2));
dfplusZi=dfplusZi[order(as.numeric(dfplusZi$V1)),]

dfreal=dfplusZ;dfimag=dfplusZi

min_val=min(as.numeric(dfreal$V1));max_val=max(as.numeric(dfreal$V1))
dfimag=dfimag[(dfimag$V1 %in% dfreal$V1),]


fft_plusZ = stats::fft(dfreal$V2+1i*dfimag$V2)

dfreal_plus=dfreal
dfimag_plus=dfimag

lenf2=length(fft_plusZ)
delta_fft2=max(as.numeric(substr(dfreal$V1,1,12)))-min(as.numeric(substr(dfreal$V1,1,12)))
n=lenf2

#second component of riemann-siegel formula based on first quiescent region
#EP(1-(sigma+i*t))*chi(sigma+i*t)*exp(i*theta)
#using 3 and upwards in prodeuler pari-gp function for all t

dfminusZ=read.csv("/home/john/pari/Zminus_EP_res_p5_0_m750_p750_3upwards_spacing_p01_real.csv",header=FALSE,colClasses = c("character"));
dfminusZ$V2=as.numeric(gsub(" ","",dfminusZ$V2));
dfminusZ=dfminusZ[order(as.numeric(dfminusZ$V1)),]

dfminusZi=read.csv("/home/john/pari/Zminus_EP_res_p5_0_m750_p750_3upwards_spacing_p01_imag.csv",header=FALSE,colClasses = c("character"));
dfminusZi$V2=as.numeric(gsub(" ","",dfminusZi$V2));
dfminusZi=dfminusZi[order(as.numeric(dfminusZi$V1)),]

dfreal=dfminusZ;dfimag=dfminusZi

min_val=min(as.numeric(dfreal$V1));max_val=max(as.numeric(dfreal$V1))
dfimag=dfimag[dfimag$V1 %in% dfreal$V1,]

fft_minusZ = stats::fft(dfreal$V2+1i*dfimag$V2)

dfreal_minus=dfreal
dfimag_minus=dfimag

lenf=dim(dfreal)[1]

n=dim(dfreal)[1]

min_freq=min(as.numeric(substr(dfreal$V1,1,12)))
max_freq=max(as.numeric(substr(dfreal$V1,1,12)))
delta_fft=max(as.numeric(substr(dfreal$V1,1,12)))-min(as.numeric(substr(dfreal$V1,1,12)))


#symmetric formula when sigma=0.5
#for spectral filtering of first quiescent region based Euler Product

fft_hybrid=c(Re(fft_plusZ[1]),(fft_plusZ)[2:(ceiling(n/2)+0)],Re(fft_plusZ)[ceiling(n/2)+1],Conj(rev(c((fft_plusZ)[2:floor(n/2)]))))
inv_hybrid=fft(fft_hybrid,inverse=TRUE)

yspan=range(Re(inv_hybrid)/n,Im(inv_hybrid)/n)
plot(as.numeric(substr(dfreal$V1,1,22)),Re(inv_hybrid)/n,typ="l",
     ylim=c(-2,3),xlab="t",main="Riemann Siegel Z function analogue (using spectral filtered Euler Product) of \n Riemann Zeta function using 3 upwards for all t",xlim=c(-40,40)+0,col="gray",cex.main=0.6);grid(col="gray")#,ylim=c(-.75,15),,xlim=c(100055,100060),xlim=c(100170,100173)
lines(as.numeric(substr(dfimag$V1,1,22)),Im(inv_hybrid)/n,col="blue")
lines(as.numeric(substr(dfZi$V1,1,22)),Re(dfZ$V2),col="magenta",lty=2)
lines(as.numeric(substr(dfZ$V1,1,22)),Re(dfZi$V2),col="cyan",lty=2)

plot(as.numeric(substr(dfreal$V1,1,22)),Re(inv_hybrid)/n-Re(dfZ$V2),typ="l",xlab="t",ylab="Error",main="Error in real(Z) component (using spectral filtered Euler Product approximation) of \n Riemann Zeta Z function using max(1,floor(1.25*sqrt(t/2/pi*1))) in EP",col="gray",cex.main=0.8);grid(col="gray2")
lines(-rep((5/1.25)^2*2*pi/1,2),c(-0.6,-0.1),lty=2,col="blue")
lines(-rep((7/1.25)^2*2*pi/1,2),c(-0.6,-0.1),lty=2,col="blue")
lines(rep((5/1.25)^2*2*pi/1,2),c(-0.6,-0.1),lty=2,col="blue")
lines(rep((7/1.25)^2*2*pi/1,2),c(-0.6,-0.1),lty=2,col="blue")
text(x=c(-1,1)*(5/1.25)^2*2*pi/1,y=-0.8,"5")
text(x=c(-1,1)*(7/1.25)^2*2*pi/1,y=-0.8,"7")
text(x=0,y=-1.2,"t value when next prime is included in EP")


#first component of riemann-siegel formula based on first quiescent region
#EP(sigma+i*t)*exp(i*theta)
#using 5 and upwards in prodeuler pari-gp function for all t

dfplusZ=read.csv("/home/john/pari/Zplus_EP_res_p5_0_m750_p750_5upwards_spacing_p01_real.csv",header=FALSE,colClasses = c("character"));
dfplusZ$V2=as.numeric(gsub(" ","",dfplusZ$V2));
dfplusZ=dfplusZ[order(as.numeric(dfplusZ$V1)),]

dfplusZi=read.csv("/home/john/pari/Zplus_EP_res_p5_0_m750_p750_5upwards_spacing_p01_imag.csv",header=FALSE,colClasses = c("character"));
dfplusZi$V2=as.numeric(gsub(" ","",dfplusZi$V2));
dfplusZi=dfplusZi[order(as.numeric(dfplusZi$V1)),]

dfreal=dfplusZ;dfimag=dfplusZi

min_val=min(as.numeric(dfreal$V1));max_val=max(as.numeric(dfreal$V1))
dfimag=dfimag[(dfimag$V1 %in% dfreal$V1),]


fft_plusZ = stats::fft(dfreal$V2+1i*dfimag$V2)

dfreal_plus=dfreal
dfimag_plus=dfimag

lenf2=length(fft_plusZ)
delta_fft2=max(as.numeric(substr(dfreal$V1,1,12)))-min(as.numeric(substr(dfreal$V1,1,12)))
n=lenf2

#second component of riemann-siegel formula based on first quiescent region
#EP(1-(sigma+i*t))*chi(sigma+i*t)*exp(i*theta)
#using 5 and upwards in prodeuler pari-gp function for all t

dfminusZ=read.csv("/home/john/pari/Zminus_EP_res_p5_0_m750_p750_5upwards_spacing_p01_real.csv",header=FALSE,colClasses = c("character"));
dfminusZ$V2=as.numeric(gsub(" ","",dfminusZ$V2));
dfminusZ=dfminusZ[order(as.numeric(dfminusZ$V1)),]

dfminusZi=read.csv("/home/john/pari/Zminus_EP_res_p5_0_m750_p750_5upwards_spacing_p01_imag.csv",header=FALSE,colClasses = c("character"));
dfminusZi$V2=as.numeric(gsub(" ","",dfminusZi$V2));
dfminusZi=dfminusZi[order(as.numeric(dfminusZi$V1)),]

dfreal=dfminusZ;dfimag=dfminusZi

min_val=min(as.numeric(dfreal$V1));max_val=max(as.numeric(dfreal$V1))
dfimag=dfimag[dfimag$V1 %in% dfreal$V1,]

fft_minusZ = stats::fft(dfreal$V2+1i*dfimag$V2)

dfreal_minus=dfreal
dfimag_minus=dfimag

lenf=dim(dfreal)[1]

n=dim(dfreal)[1]

min_freq=min(as.numeric(substr(dfreal$V1,1,12)))
max_freq=max(as.numeric(substr(dfreal$V1,1,12)))
delta_fft=max(as.numeric(substr(dfreal$V1,1,12)))-min(as.numeric(substr(dfreal$V1,1,12)))


#symmetric formula when sigma=0.5
#for spectral filtering of first quiescent region based Euler Product

fft_hybrid=c(Re(fft_plusZ[1]),(fft_plusZ)[2:(ceiling(n/2)+0)],Re(fft_plusZ)[ceiling(n/2)+1],Conj(rev(c((fft_plusZ)[2:floor(n/2)]))))
inv_hybrid=fft(fft_hybrid,inverse=TRUE)

yspan=range(Re(inv_hybrid)/n,Im(inv_hybrid)/n)
plot(as.numeric(substr(dfreal$V1,1,22)),Re(inv_hybrid)/n,typ="l",
     ylim=c(-2,3),xlab="t",main="Riemann Siegel Z function analogue (using spectral filtered Euler Product) of \n Riemann Zeta function using 5 upwards for all t",xlim=c(-40,40)+0,col="gray",cex.main=0.6);grid(col="gray")#,ylim=c(-.75,15),,xlim=c(100055,100060),xlim=c(100170,100173)
lines(as.numeric(substr(dfimag$V1,1,22)),Im(inv_hybrid)/n,col="blue")
lines(as.numeric(substr(dfZi$V1,1,22)),Re(dfZ$V2),col="magenta",lty=2)
lines(as.numeric(substr(dfZ$V1,1,22)),Re(dfZi$V2),col="cyan",lty=2)

plot(as.numeric(substr(dfreal$V1,1,22)),Re(inv_hybrid)/n-Re(dfZ$V2),typ="l",xlab="t",ylab="Error",main="Error in real(Z) component (using spectral filtered Euler Product approximation) of \n Riemann Zeta Z function using max(1,floor(1.25*sqrt(t/2/pi*1))) in EP",col="gray",cex.main=0.8);grid(col="gray2")
lines(-rep((7/1.25)^2*2*pi/1,2),c(-0.6,-0.1),lty=2,col="blue")
lines(rep((7/1.25)^2*2*pi/1,2),c(-0.6,-0.1),lty=2,col="blue")
text(x=c(-1,1)*(7/1.25)^2*2*pi/1,y=-0.8,"7")
text(x=0,y=-1.2,"t value when next prime is included in EP")
lines(-rep((11/1.25)^2*2*pi/1,2),c(-0.6,-0.1),lty=2,col="blue")
lines(rep((11/1.25)^2*2*pi/1,2),c(-0.6,-0.1),lty=2,col="blue")
text(x=c(-1,1)*(11/1.25)^2*2*pi/1,y=-0.8,"11")
lines(-rep((13/1.25)^2*2*pi/1,2),c(0.05,0.45),lty=2,col="blue")
lines(rep((13/1.25)^2*2*pi/1,2),c(0.05,0.45),lty=2,col="blue")
text(x=c(-1,1)*(13/1.25)^2*2*pi/1,y=0.6,"13")


#first component of riemann-siegel formula based on first quiescent region
#EP(sigma+i*t)*exp(i*theta)
#using 13 and upwards in prodeuler pari-gp function for all t

dfplusZ=read.csv("/home/john/pari/Zplus_EP_res_p5_0_m750_p750_13upwards_spacing_p01_real.csv",header=FALSE,colClasses = c("character"));
dfplusZ$V2=as.numeric(gsub(" ","",dfplusZ$V2));
dfplusZ=dfplusZ[order(as.numeric(dfplusZ$V1)),]

dfplusZi=read.csv("/home/john/pari/Zplus_EP_res_p5_0_m750_p750_13upwards_spacing_p01_imag.csv",header=FALSE,colClasses = c("character"));
dfplusZi$V2=as.numeric(gsub(" ","",dfplusZi$V2));
dfplusZi=dfplusZi[order(as.numeric(dfplusZi$V1)),]

dfreal=dfplusZ;dfimag=dfplusZi

min_val=min(as.numeric(dfreal$V1));max_val=max(as.numeric(dfreal$V1))
dfimag=dfimag[(dfimag$V1 %in% dfreal$V1),]


fft_plusZ = stats::fft(dfreal$V2+1i*dfimag$V2)

dfreal_plus=dfreal
dfimag_plus=dfimag

lenf2=length(fft_plusZ)
delta_fft2=max(as.numeric(substr(dfreal$V1,1,12)))-min(as.numeric(substr(dfreal$V1,1,12)))
n=lenf2

#second component of riemann-siegel formula based on first quiescent region
#EP(1-(sigma+i*t))*chi(sigma+i*t)*exp(i*theta)
#using 5 and upwards in prodeuler pari-gp function for all t

dfminusZ=read.csv("/home/john/pari/Zminus_EP_res_p5_0_m750_p750_13upwards_spacing_p01_real.csv",header=FALSE,colClasses = c("character"));
dfminusZ$V2=as.numeric(gsub(" ","",dfminusZ$V2));
dfminusZ=dfminusZ[order(as.numeric(dfminusZ$V1)),]

dfminusZi=read.csv("/home/john/pari/Zminus_EP_res_p5_0_m750_p750_13upwards_spacing_p01_imag.csv",header=FALSE,colClasses = c("character"));
dfminusZi$V2=as.numeric(gsub(" ","",dfminusZi$V2));
dfminusZi=dfminusZi[order(as.numeric(dfminusZi$V1)),]

dfreal=dfminusZ;dfimag=dfminusZi

min_val=min(as.numeric(dfreal$V1));max_val=max(as.numeric(dfreal$V1))
dfimag=dfimag[dfimag$V1 %in% dfreal$V1,]

fft_minusZ = stats::fft(dfreal$V2+1i*dfimag$V2)

dfreal_minus=dfreal
dfimag_minus=dfimag

lenf=dim(dfreal)[1]

n=dim(dfreal)[1]

min_freq=min(as.numeric(substr(dfreal$V1,1,12)))
max_freq=max(as.numeric(substr(dfreal$V1,1,12)))
delta_fft=max(as.numeric(substr(dfreal$V1,1,12)))-min(as.numeric(substr(dfreal$V1,1,12)))


#symmetric formula when sigma=0.5
#for spectral filtering of first quiescent region based Euler Product

fft_hybrid=c(Re(fft_plusZ[1]),(fft_plusZ)[2:(ceiling(n/2)+0)],Re(fft_plusZ)[ceiling(n/2)+1],Conj(rev(c((fft_plusZ)[2:floor(n/2)]))))
inv_hybrid=fft(fft_hybrid,inverse=TRUE)

yspan=range(Re(inv_hybrid)/n,Im(inv_hybrid)/n)
plot(as.numeric(substr(dfreal$V1,1,22)),Re(inv_hybrid)/n,typ="l",
     ylim=c(-2,3),xlab="t",main="Riemann Siegel Z function analogue (using spectral filtered Euler Product) of \n Riemann Zeta function using 13 upwards for all t",xlim=c(-40,40)+0,col="gray",cex.main=0.6);grid(col="gray")#,ylim=c(-.75,15),,xlim=c(100055,100060),xlim=c(100170,100173)
lines(as.numeric(substr(dfimag$V1,1,22)),Im(inv_hybrid)/n,col="blue")
lines(as.numeric(substr(dfZi$V1,1,22)),Re(dfZ$V2),col="magenta",lty=2)
lines(as.numeric(substr(dfZ$V1,1,22)),Re(dfZi$V2),col="cyan",lty=2)
text(x=0,y=-2,"the join in the hybrid  EP/Laurent Series approximation \n around 4<abs(t)<5 has error",cex=0.5)

plot(as.numeric(substr(dfreal$V1,1,22)),Re(inv_hybrid)/n-Re(dfZ$V2),typ="l",xlab="t",ylab="Error",main="Error in real(Z) component (using spectral filtered Euler Product approximation) of \n Riemann Zeta Z function using max(1,floor(1.25*sqrt(t/2/pi*1))) in EP",col="darkgreen",cex.main=0.8);grid(col="gray2")
text(x=250,y=-0.25,"as shown the error in joining the hybrid  EP/Laurent Series \n approximation around 4<abs(t)<5 is NOT fully resolved.",cex=0.7)



```





\clearpage



```{r Zfnzeta_andtruncatedEPfouriertransform_0_pm750_LaurentSerieshybrid_p1, echo=FALSE, fig.cap="Lefthand panel - True Z function shown in magenta (cyan) for real (imaginary) parts and hybrid spectral filtered based EP/Laurent Series approximation shown in black (blue) for real (imaginary) parts, Right hand panel - Error in the real(Z) EP approximation. A comparison of the Riemann-Siegel Z function of the Riemann Zeta L-function and spectrally filtered partial Euler Product/Laurent Series (using truncation at $\\max (P,\\sqrt{((\\frac{t}{2\\pi})^1\\cdot 1}) $) in the complex plane at $\\sigma=0.1$ for the interval t=(-750,750) where $P_{min}={1,2,3,5,13}$ for rows 1-5.", out.width = c("49%","49%"), fig.show = "hold",  fig.height=3.8, warning=FALSE, cache=TRUE}

# Riemann-Siegel Z function of Riemann Zeta function on critical line
# values recorded every .01 spacing in interval [-750,+750]

dfZ=read.csv("/home/john/pari/Zzeta_res_p1_0_m750_p750_spacing_p01_real.csv",header=FALSE,colClasses = c("character"));
dfZ$V2=as.numeric(gsub(" ","",dfZ$V2));
dfZ=dfZ[order(as.numeric(dfZ$V1)),]

dfZi=read.csv("/home/john/pari/Zzeta_res_p1_0_m750_p750_spacing_p01_imag.csv",header=FALSE,colClasses = c("character"));
dfZi$V2=as.numeric(gsub(" ","",dfZi$V2));
dfZi=dfZi[order(as.numeric(dfZi$V1)),]


#Riemann-Siegel Z function of truncated Euler product at first quiescent region
#first component of riemann-siegel formula based on first quiescent region
#EP(sigma+i*t)*exp(i*theta)
#using 0 extra integers in prodeuler pari-gp function

dfplusZ=read.csv("/home/john/pari/Zplus_EP_res_p1_0_m750_p750_0extra_spacing_p01_real.csv",header=FALSE,colClasses = c("character"));
dfplusZ$V2=as.numeric(gsub(" ","",dfplusZ$V2));
dfplusZ=dfplusZ[order(as.numeric(dfplusZ$V1)),]

dfplusZi=read.csv("/home/john/pari/Zplus_EP_res_p1_0_m750_p750_0extra_spacing_p01_imag.csv",header=FALSE,colClasses = c("character"));
dfplusZi$V2=as.numeric(gsub(" ","",dfplusZi$V2));
dfplusZi=dfplusZi[order(as.numeric(dfplusZi$V1)),]

dfreal=dfplusZ;dfimag=dfplusZi

min_val=min(as.numeric(dfreal$V1));max_val=max(as.numeric(dfreal$V1))
dfimag=dfimag[(dfimag$V1 %in% dfreal$V1),]


fft_plusZ = stats::fft(dfreal$V2+1i*dfimag$V2)

dfreal_plus=dfreal
dfimag_plus=dfimag

lenf2=length(fft_plusZ)
delta_fft2=max(as.numeric(substr(dfreal$V1,1,12)))-min(as.numeric(substr(dfreal$V1,1,12)))
n=lenf2

#second component of riemann-siegel formula based on first quiescent region
#EP(1-(sigma+i*t))*chi(sigma+i*t)*exp(i*theta)
#using 0 extra integers in prodeuler pari-gp function

dfminusZ=read.csv("/home/john/pari/Zminus_EP_res_p1_0_m750_p750_0extra_spacing_p01_real.csv",header=FALSE,colClasses = c("character"));
dfminusZ$V2=as.numeric(gsub(" ","",dfminusZ$V2));
dfminusZ=dfminusZ[order(as.numeric(dfminusZ$V1)),]

dfminusZi=read.csv("/home/john/pari/Zminus_EP_res_p1_0_m750_p750_0extra_spacing_p01_imag.csv",header=FALSE,colClasses = c("character"));
dfminusZi$V2=as.numeric(gsub(" ","",dfminusZi$V2));
dfminusZi=dfminusZi[order(as.numeric(dfminusZi$V1)),]

dfreal=dfminusZ;dfimag=dfminusZi

min_val=min(as.numeric(dfreal$V1));max_val=max(as.numeric(dfreal$V1))
dfimag=dfimag[dfimag$V1 %in% dfreal$V1,]

fft_minusZ = stats::fft(dfreal$V2+1i*dfimag$V2)

dfreal_minus=dfreal
dfimag_minus=dfimag

lenf=dim(dfreal)[1]

n=dim(dfreal)[1]

min_freq=min(as.numeric(substr(dfreal$V1,1,12)))
max_freq=max(as.numeric(substr(dfreal$V1,1,12)))
delta_fft=max(as.numeric(substr(dfreal$V1,1,12)))-min(as.numeric(substr(dfreal$V1,1,12)))


#symmetric formula when sigma=0.5
#for spectral filtering of first quiescent region based Euler Product

fft_hybrid=c(1/2*(fft_plusZ[1]+fft_minusZ[1]),(fft_plusZ)[2:(ceiling(n/2)+0)],1/2*(fft_plusZ[ceiling(n/2)+1]+fft_minusZ[ceiling(n/2)+1]),fft_minusZ[(ceiling(n/2)+2):n])
inv_hybrid=fft(fft_hybrid,inverse=TRUE)

yspan=range(Re(inv_hybrid)/n,Im(inv_hybrid)/n)
plot(as.numeric(substr(dfreal$V1,1,22)),Re(inv_hybrid)/n,typ="l",
     ylim=c(-4,6),xlab="t",main="Riemann Siegel Z function analogue (using spectral filtered Euler Product) of \n Riemann Zeta function using floor(1.25*sqrt(t)/2/pi) upwards in EP",xlim=c(-40,40)+0,col="gray",cex.main=0.6);grid(col="gray")#,ylim=c(-.75,15),,xlim=c(100055,100060),xlim=c(100170,100173)
lines(as.numeric(substr(dfimag$V1,1,22)),Im(inv_hybrid)/n,col="blue")
lines(as.numeric(substr(dfZ$V1,1,22)),Re(dfZ$V2),col="magenta",lty=2)
lines(as.numeric(substr(dfZ$V1,1,22)),Re(dfZi$V2),col="cyan",lty=2)
# lines(-rep((2/1.25)^2*2*pi/1,2),c(-0.5,0.5),lty=2,col="blue")
# lines(rep((2/1.25)^2*2*pi/1,2),c(-0.5,0.5),lty=2,col="blue")
# text(x=c(-1,1)*(2/1.25)^2*2*pi/1,y=-.67,"2")
# text(x=0,y=-2,"t value when next prime is included in EP")
# lines(-rep((3/1.25)^2*2*pi/1,2),c(-1.5,-0.5),lty=2,col="blue")
# lines(rep((3/1.25)^2*2*pi/1,2),c(-1.5,-0.5),lty=2,col="blue")
# text(x=c(-1,1)*(3/1.25)^2*2*pi/1,y=-2,"3")

plot(as.numeric(substr(dfreal$V1,1,22)),Re(inv_hybrid)/n-Re(dfZ$V2),typ="l",xlab="t",ylab="Error",main="Error in real(Z) component (using spectral filtered Euler Product approximation) of \n Riemann Zeta Z function using max(1,floor(1.25*sqrt(t/2/pi*1))) in EP",col="darkgreen",cex.main=0.8);grid(col="gray2")

#first component of riemann-siegel formula based on first quiescent region
#EP(sigma+i*t)*exp(i*theta)
#using 2 and upwards in prodeuler pari-gp function for all t

dfplusZ=read.csv("/home/john/pari/Zplus_EP_res_p1_0_m750_p750_2upwards_spacing_p01_real.csv",header=FALSE,colClasses = c("character"));
dfplusZ$V2=as.numeric(gsub(" ","",dfplusZ$V2));
dfplusZ=dfplusZ[order(as.numeric(dfplusZ$V1)),]

dfplusZi=read.csv("/home/john/pari/Zplus_EP_res_p1_0_m750_p750_2upwards_spacing_p01_imag.csv",header=FALSE,colClasses = c("character"));
dfplusZi$V2=as.numeric(gsub(" ","",dfplusZi$V2));
dfplusZi=dfplusZi[order(as.numeric(dfplusZi$V1)),]

dfreal=dfplusZ;dfimag=dfplusZi

min_val=min(as.numeric(dfreal$V1));max_val=max(as.numeric(dfreal$V1))
dfimag=dfimag[(dfimag$V1 %in% dfreal$V1),]


fft_plusZ = stats::fft(dfreal$V2+1i*dfimag$V2)

dfreal_plus=dfreal
dfimag_plus=dfimag

lenf2=length(fft_plusZ)
delta_fft2=max(as.numeric(substr(dfreal$V1,1,12)))-min(as.numeric(substr(dfreal$V1,1,12)))
n=lenf2

#second component of riemann-siegel formula based on first quiescent region
#EP(1-(sigma+i*t))*chi(sigma+i*t)*exp(i*theta)
#using 2 and upwards in prodeuler pari-gp function for all t

dfminusZ=read.csv("/home/john/pari/Zminus_EP_res_p1_0_m750_p750_2upwards_spacing_p01_real.csv",header=FALSE,colClasses = c("character"));
dfminusZ$V2=as.numeric(gsub(" ","",dfminusZ$V2));
dfminusZ=dfminusZ[order(as.numeric(dfminusZ$V1)),]

dfminusZi=read.csv("/home/john/pari/Zminus_EP_res_p1_0_m750_p750_2upwards_spacing_p01_imag.csv",header=FALSE,colClasses = c("character"));
dfminusZi$V2=as.numeric(gsub(" ","",dfminusZi$V2));
dfminusZi=dfminusZi[order(as.numeric(dfminusZi$V1)),]

dfreal=dfminusZ;dfimag=dfminusZi

min_val=min(as.numeric(dfreal$V1));max_val=max(as.numeric(dfreal$V1))
dfimag=dfimag[dfimag$V1 %in% dfreal$V1,]

fft_minusZ = stats::fft(dfreal$V2+1i*dfimag$V2)

dfreal_minus=dfreal
dfimag_minus=dfimag

lenf=dim(dfreal)[1]

n=dim(dfreal)[1]

min_freq=min(as.numeric(substr(dfreal$V1,1,12)))
max_freq=max(as.numeric(substr(dfreal$V1,1,12)))
delta_fft=max(as.numeric(substr(dfreal$V1,1,12)))-min(as.numeric(substr(dfreal$V1,1,12)))


#symmetric formula when sigma=0.5
#for spectral filtering of first quiescent region based Euler Product

fft_hybrid=c(1/2*(fft_plusZ[1]+fft_minusZ[1]),(fft_plusZ)[2:(ceiling(n/2)+0)],1/2*(fft_plusZ[ceiling(n/2)+1]+fft_minusZ[ceiling(n/2)+1]),fft_minusZ[(ceiling(n/2)+2):n])
inv_hybrid=fft(fft_hybrid,inverse=TRUE)

yspan=range(Re(inv_hybrid)/n,Im(inv_hybrid)/n)
plot(as.numeric(substr(dfreal$V1,1,22)),Re(inv_hybrid)/n,typ="l",
     ylim=c(-4,6),xlab="t",main="Riemann Siegel Z function analogue (using spectral filtered Euler Product) of \n Riemann Zeta function using 2 upwards for all t",xlim=c(-40,40)+0,col="gray",cex.main=0.6);grid(col="gray")#,ylim=c(-.75,15),,xlim=c(100055,100060),xlim=c(100170,100173)
lines(as.numeric(substr(dfimag$V1,1,22)),Im(inv_hybrid)/n,col="blue")
lines(as.numeric(substr(dfZ$V1,1,22)),Re(dfZ$V2),col="magenta",lty=2)
lines(as.numeric(substr(dfZ$V1,1,22)),Re(dfZi$V2),col="cyan",lty=2)
lines(-rep((3/1.25)^2*2*pi/1,2),c(-1.2,-0.2),lty=2,col="blue")
lines(rep((3/1.25)^2*2*pi/1,2),c(-1.2,-0.2),lty=2,col="blue")
text(x=c(-1,1)*(3/1.25)^2*2*pi/1,y=-1.5,"3")
text(x=0,y=-3,"t value when next prime is included in EP")

plot(as.numeric(substr(dfreal$V1,1,22)),Re(inv_hybrid)/n-Re(dfZ$V2),typ="l",xlab="t",ylab="Error",main="Error in real(Z) component (using spectral filtered Euler Product approximation) of \n Riemann Zeta Z function using max(1,floor(1.25*sqrt(t/2/pi*1))) in EP",col="darkgreen",cex.main=0.8);grid(col="gray2")
# lines(-rep((3/1.25)^2*2*pi/1,2),c(0.1,0.6),lty=2,col="blue")
# lines(-rep((5/1.25)^2*2*pi/1,2),c(-0.6,-0.1),lty=2,col="blue")
# lines(-rep((7/1.25)^2*2*pi/1,2),c(-0.6,-0.1),lty=2,col="blue")
# lines(rep((3/1.25)^2*2*pi/1,2),c(0.1,0.6),lty=2,col="blue")
# lines(rep((5/1.25)^2*2*pi/1,2),c(-0.6,-0.1),lty=2,col="blue")
# lines(rep((7/1.25)^2*2*pi/1,2),c(-0.6,-0.1),lty=2,col="blue")
# text(x=c(-1,1)*(3/1.25)^2*2*pi/1,y=0.8,"3")
# text(x=c(-1,1)*(5/1.25)^2*2*pi/1,y=-0.8,"5")
# text(x=c(-1,1)*(7/1.25)^2*2*pi/1,y=-0.8,"7")
# text(x=0,y=-1.2,"t value when next prime is included in EP")


#first component of riemann-siegel formula based on first quiescent region
#EP(sigma+i*t)*exp(i*theta)
#using 3 and upwards in prodeuler pari-gp function for all t

dfplusZ=read.csv("/home/john/pari/Zplus_EP_res_p1_0_m750_p750_3upwards_spacing_p01_real.csv",header=FALSE,colClasses = c("character"));
dfplusZ$V2=as.numeric(gsub(" ","",dfplusZ$V2));
dfplusZ=dfplusZ[order(as.numeric(dfplusZ$V1)),]

dfplusZi=read.csv("/home/john/pari/Zplus_EP_res_p1_0_m750_p750_3upwards_spacing_p01_imag.csv",header=FALSE,colClasses = c("character"));
dfplusZi$V2=as.numeric(gsub(" ","",dfplusZi$V2));
dfplusZi=dfplusZi[order(as.numeric(dfplusZi$V1)),]

dfreal=dfplusZ;dfimag=dfplusZi

min_val=min(as.numeric(dfreal$V1));max_val=max(as.numeric(dfreal$V1))
dfimag=dfimag[(dfimag$V1 %in% dfreal$V1),]


fft_plusZ = stats::fft(dfreal$V2+1i*dfimag$V2)

dfreal_plus=dfreal
dfimag_plus=dfimag

lenf2=length(fft_plusZ)
delta_fft2=max(as.numeric(substr(dfreal$V1,1,12)))-min(as.numeric(substr(dfreal$V1,1,12)))
n=lenf2

#second component of riemann-siegel formula based on first quiescent region
#EP(1-(sigma+i*t))*chi(sigma+i*t)*exp(i*theta)
#using 3 and upwards in prodeuler pari-gp function for all t

dfminusZ=read.csv("/home/john/pari/Zminus_EP_res_p1_0_m750_p750_3upwards_spacing_p01_real.csv",header=FALSE,colClasses = c("character"));
dfminusZ$V2=as.numeric(gsub(" ","",dfminusZ$V2));
dfminusZ=dfminusZ[order(as.numeric(dfminusZ$V1)),]

dfminusZi=read.csv("/home/john/pari/Zminus_EP_res_p1_0_m750_p750_3upwards_spacing_p01_imag.csv",header=FALSE,colClasses = c("character"));
dfminusZi$V2=as.numeric(gsub(" ","",dfminusZi$V2));
dfminusZi=dfminusZi[order(as.numeric(dfminusZi$V1)),]

dfreal=dfminusZ;dfimag=dfminusZi

min_val=min(as.numeric(dfreal$V1));max_val=max(as.numeric(dfreal$V1))
dfimag=dfimag[dfimag$V1 %in% dfreal$V1,]

fft_minusZ = stats::fft(dfreal$V2+1i*dfimag$V2)

dfreal_minus=dfreal
dfimag_minus=dfimag

lenf=dim(dfreal)[1]

n=dim(dfreal)[1]

min_freq=min(as.numeric(substr(dfreal$V1,1,12)))
max_freq=max(as.numeric(substr(dfreal$V1,1,12)))
delta_fft=max(as.numeric(substr(dfreal$V1,1,12)))-min(as.numeric(substr(dfreal$V1,1,12)))


#symmetric formula when sigma=0.5
#for spectral filtering of first quiescent region based Euler Product

fft_hybrid=c(1/2*(fft_plusZ[1]+fft_minusZ[1]),(fft_plusZ)[2:(ceiling(n/2)+0)],1/2*(fft_plusZ[ceiling(n/2)+1]+fft_minusZ[ceiling(n/2)+1]),fft_minusZ[(ceiling(n/2)+2):n])
inv_hybrid=fft(fft_hybrid,inverse=TRUE)

yspan=range(Re(inv_hybrid)/n,Im(inv_hybrid)/n)
plot(as.numeric(substr(dfreal$V1,1,22)),Re(inv_hybrid)/n,typ="l",
     ylim=c(-4,6),xlab="t",main="Riemann Siegel Z function analogue (using spectral filtered Euler Product) of \n Riemann Zeta function using 3 upwards for all t",xlim=c(-40,40)+0,col="gray",cex.main=0.6);grid(col="gray")#,ylim=c(-.75,15),,xlim=c(100055,100060),xlim=c(100170,100173)
lines(as.numeric(substr(dfimag$V1,1,22)),Im(inv_hybrid)/n,col="blue")
lines(as.numeric(substr(dfZi$V1,1,22)),Re(dfZ$V2),col="magenta",lty=2)
lines(as.numeric(substr(dfZ$V1,1,22)),Re(dfZi$V2),col="cyan",lty=2)

plot(as.numeric(substr(dfreal$V1,1,22)),Re(inv_hybrid)/n-Re(dfZ$V2),typ="l",xlab="t",ylab="Error",main="Error in real(Z) component (using spectral filtered Euler Product approximation) of \n Riemann Zeta Z function using max(1,floor(1.25*sqrt(t/2/pi*1))) in EP",col="darkgreen",cex.main=0.8);grid(col="gray2")
# lines(-rep((5/1.25)^2*2*pi/1,2),c(-0.6,-0.1),lty=2,col="blue")
# lines(-rep((7/1.25)^2*2*pi/1,2),c(-0.6,-0.1),lty=2,col="blue")
# lines(rep((5/1.25)^2*2*pi/1,2),c(-0.6,-0.1),lty=2,col="blue")
# lines(rep((7/1.25)^2*2*pi/1,2),c(-0.6,-0.1),lty=2,col="blue")
# text(x=c(-1,1)*(5/1.25)^2*2*pi/1,y=-0.8,"5")
# text(x=c(-1,1)*(7/1.25)^2*2*pi/1,y=-0.8,"7")
# text(x=0,y=-1.2,"t value when next prime is included in EP")


#first component of riemann-siegel formula based on first quiescent region
#EP(sigma+i*t)*exp(i*theta)
#using 5 and upwards in prodeuler pari-gp function for all t

dfplusZ=read.csv("/home/john/pari/Zplus_EP_res_p1_0_m750_p750_5upwards_spacing_p01_real.csv",header=FALSE,colClasses = c("character"));
dfplusZ$V2=as.numeric(gsub(" ","",dfplusZ$V2));
dfplusZ=dfplusZ[order(as.numeric(dfplusZ$V1)),]

dfplusZi=read.csv("/home/john/pari/Zplus_EP_res_p1_0_m750_p750_5upwards_spacing_p01_imag.csv",header=FALSE,colClasses = c("character"));
dfplusZi$V2=as.numeric(gsub(" ","",dfplusZi$V2));
dfplusZi=dfplusZi[order(as.numeric(dfplusZi$V1)),]

dfreal=dfplusZ;dfimag=dfplusZi

min_val=min(as.numeric(dfreal$V1));max_val=max(as.numeric(dfreal$V1))
dfimag=dfimag[(dfimag$V1 %in% dfreal$V1),]


fft_plusZ = stats::fft(dfreal$V2+1i*dfimag$V2)

dfreal_plus=dfreal
dfimag_plus=dfimag

lenf2=length(fft_plusZ)
delta_fft2=max(as.numeric(substr(dfreal$V1,1,12)))-min(as.numeric(substr(dfreal$V1,1,12)))
n=lenf2

#second component of riemann-siegel formula based on first quiescent region
#EP(1-(sigma+i*t))*chi(sigma+i*t)*exp(i*theta)
#using 5 and upwards in prodeuler pari-gp function for all t

dfminusZ=read.csv("/home/john/pari/Zminus_EP_res_p1_0_m750_p750_5upwards_spacing_p01_real.csv",header=FALSE,colClasses = c("character"));
dfminusZ$V2=as.numeric(gsub(" ","",dfminusZ$V2));
dfminusZ=dfminusZ[order(as.numeric(dfminusZ$V1)),]

dfminusZi=read.csv("/home/john/pari/Zminus_EP_res_p1_0_m750_p750_5upwards_spacing_p01_imag.csv",header=FALSE,colClasses = c("character"));
dfminusZi$V2=as.numeric(gsub(" ","",dfminusZi$V2));
dfminusZi=dfminusZi[order(as.numeric(dfminusZi$V1)),]

dfreal=dfminusZ;dfimag=dfminusZi

min_val=min(as.numeric(dfreal$V1));max_val=max(as.numeric(dfreal$V1))
dfimag=dfimag[dfimag$V1 %in% dfreal$V1,]

fft_minusZ = stats::fft(dfreal$V2+1i*dfimag$V2)

dfreal_minus=dfreal
dfimag_minus=dfimag

lenf=dim(dfreal)[1]

n=dim(dfreal)[1]

min_freq=min(as.numeric(substr(dfreal$V1,1,12)))
max_freq=max(as.numeric(substr(dfreal$V1,1,12)))
delta_fft=max(as.numeric(substr(dfreal$V1,1,12)))-min(as.numeric(substr(dfreal$V1,1,12)))


#symmetric formula when sigma=0.5
#for spectral filtering of first quiescent region based Euler Product

fft_hybrid=c(1/2*(fft_plusZ[1]+fft_minusZ[1]),(fft_plusZ)[2:(ceiling(n/2)+0)],1/2*(fft_plusZ[ceiling(n/2)+1]+fft_minusZ[ceiling(n/2)+1]),fft_minusZ[(ceiling(n/2)+2):n])
inv_hybrid=fft(fft_hybrid,inverse=TRUE)

yspan=range(Re(inv_hybrid)/n,Im(inv_hybrid)/n)
plot(as.numeric(substr(dfreal$V1,1,22)),Re(inv_hybrid)/n,typ="l",
     ylim=c(-4,6),xlab="t",main="Riemann Siegel Z function analogue (using spectral filtered Euler Product) of \n Riemann Zeta function using 5 upwards for all t",xlim=c(-40,40)+0,col="gray",cex.main=0.6);grid(col="gray")#,ylim=c(-.75,15),,xlim=c(100055,100060),xlim=c(100170,100173)
lines(as.numeric(substr(dfimag$V1,1,22)),Im(inv_hybrid)/n,col="blue")
lines(as.numeric(substr(dfZi$V1,1,22)),Re(dfZ$V2),col="magenta",lty=2)
lines(as.numeric(substr(dfZ$V1,1,22)),Re(dfZi$V2),col="cyan",lty=2)

plot(as.numeric(substr(dfreal$V1,1,22)),Re(inv_hybrid)/n-Re(dfZ$V2),typ="l",xlab="t",ylab="Error",main="Error in real(Z) component (using spectral filtered Euler Product approximation) of \n Riemann Zeta Z function using max(1,floor(1.25*sqrt(t/2/pi*1))) in EP",col="darkgreen",cex.main=0.8);grid(col="gray2")
# lines(-rep((7/1.25)^2*2*pi/1,2),c(-0.6,-0.1),lty=2,col="blue")
# lines(rep((7/1.25)^2*2*pi/1,2),c(-0.6,-0.1),lty=2,col="blue")
# text(x=c(-1,1)*(7/1.25)^2*2*pi/1,y=-0.8,"7")
# text(x=0,y=-1.2,"t value when next prime is included in EP")
# lines(-rep((11/1.25)^2*2*pi/1,2),c(-0.6,-0.1),lty=2,col="blue")
# lines(rep((11/1.25)^2*2*pi/1,2),c(-0.6,-0.1),lty=2,col="blue")
# text(x=c(-1,1)*(11/1.25)^2*2*pi/1,y=-0.8,"11")
# lines(-rep((13/1.25)^2*2*pi/1,2),c(0.05,0.45),lty=2,col="blue")
# lines(rep((13/1.25)^2*2*pi/1,2),c(0.05,0.45),lty=2,col="blue")
# text(x=c(-1,1)*(13/1.25)^2*2*pi/1,y=0.6,"13")


#first component of riemann-siegel formula based on first quiescent region
#EP(sigma+i*t)*exp(i*theta)
#using 13 and upwards in prodeuler pari-gp function for all t

dfplusZ=read.csv("/home/john/pari/Zplus_EP_res_p1_0_m750_p750_13upwards_spacing_p01_real.csv",header=FALSE,colClasses = c("character"));
dfplusZ$V2=as.numeric(gsub(" ","",dfplusZ$V2));
dfplusZ=dfplusZ[order(as.numeric(dfplusZ$V1)),]

dfplusZi=read.csv("/home/john/pari/Zplus_EP_res_p1_0_m750_p750_13upwards_spacing_p01_imag.csv",header=FALSE,colClasses = c("character"));
dfplusZi$V2=as.numeric(gsub(" ","",dfplusZi$V2));
dfplusZi=dfplusZi[order(as.numeric(dfplusZi$V1)),]

dfreal=dfplusZ;dfimag=dfplusZi

min_val=min(as.numeric(dfreal$V1));max_val=max(as.numeric(dfreal$V1))
dfimag=dfimag[(dfimag$V1 %in% dfreal$V1),]


fft_plusZ = stats::fft(dfreal$V2+1i*dfimag$V2)

dfreal_plus=dfreal
dfimag_plus=dfimag

lenf2=length(fft_plusZ)
delta_fft2=max(as.numeric(substr(dfreal$V1,1,12)))-min(as.numeric(substr(dfreal$V1,1,12)))
n=lenf2

#second component of riemann-siegel formula based on first quiescent region
#EP(1-(sigma+i*t))*chi(sigma+i*t)*exp(i*theta)
#using 5 and upwards in prodeuler pari-gp function for all t

dfminusZ=read.csv("/home/john/pari/Zminus_EP_res_p1_0_m750_p750_13upwards_spacing_p01_real.csv",header=FALSE,colClasses = c("character"));
dfminusZ$V2=as.numeric(gsub(" ","",dfminusZ$V2));
dfminusZ=dfminusZ[order(as.numeric(dfminusZ$V1)),]

dfminusZi=read.csv("/home/john/pari/Zminus_EP_res_p1_0_m750_p750_13upwards_spacing_p01_imag.csv",header=FALSE,colClasses = c("character"));
dfminusZi$V2=as.numeric(gsub(" ","",dfminusZi$V2));
dfminusZi=dfminusZi[order(as.numeric(dfminusZi$V1)),]

dfreal=dfminusZ;dfimag=dfminusZi

min_val=min(as.numeric(dfreal$V1));max_val=max(as.numeric(dfreal$V1))
dfimag=dfimag[dfimag$V1 %in% dfreal$V1,]

fft_minusZ = stats::fft(dfreal$V2+1i*dfimag$V2)

dfreal_minus=dfreal
dfimag_minus=dfimag

lenf=dim(dfreal)[1]

n=dim(dfreal)[1]

min_freq=min(as.numeric(substr(dfreal$V1,1,12)))
max_freq=max(as.numeric(substr(dfreal$V1,1,12)))
delta_fft=max(as.numeric(substr(dfreal$V1,1,12)))-min(as.numeric(substr(dfreal$V1,1,12)))


#symmetric formula when sigma=0.5
#for spectral filtering of first quiescent region based Euler Product

fft_hybrid=c(1/2*(fft_plusZ[1]+fft_minusZ[1]),(fft_plusZ)[2:(ceiling(n/2)+0)],1/2*(fft_plusZ[ceiling(n/2)+1]+fft_minusZ[ceiling(n/2)+1]),fft_minusZ[(ceiling(n/2)+2):n])
inv_hybrid=fft(fft_hybrid,inverse=TRUE)

yspan=range(Re(inv_hybrid)/n,Im(inv_hybrid)/n)
plot(as.numeric(substr(dfreal$V1,1,22)),Re(inv_hybrid)/n,typ="l",
     ylim=c(-4,6),xlab="t",main="Riemann Siegel Z function analogue (using spectral filtered Euler Product) of \n Riemann Zeta function using 13 upwards for all t",xlim=c(-40,40)+0,col="gray",cex.main=0.6);grid(col="gray")#,ylim=c(-.75,15),,xlim=c(100055,100060),xlim=c(100170,100173)
lines(as.numeric(substr(dfimag$V1,1,22)),Im(inv_hybrid)/n,col="blue")
lines(as.numeric(substr(dfZi$V1,1,22)),Re(dfZ$V2),col="magenta",lty=2)
lines(as.numeric(substr(dfZ$V1,1,22)),Re(dfZi$V2),col="cyan",lty=2)
text(x=0,y=-3,"the join in the hybrid  EP/Laurent Series approximation \n around 4<abs(t)<5 has error",cex=0.5)

plot(as.numeric(substr(dfreal$V1,1,22)),Re(inv_hybrid)/n-Re(dfZ$V2),typ="l",xlab="t",ylab="Error",main="Error in real(Z) component (using spectral filtered Euler Product approximation) of \n Riemann Zeta Z function using max(1,floor(1.25*sqrt(t/2/pi*1))) in EP",col="darkgreen",cex.main=0.8);grid(col="gray2")
text(x=250,y=0.5,"as shown the error in joining the hybrid  EP/Laurent Series \n approximation around 4<abs(t)<5 is NOT fully resolved.",cex=0.7)

```





\clearpage



```{r Zfnzeta_andtruncatedEPfouriertransform_0_pm750_LaurentSerieshybrid_p9, echo=FALSE, fig.cap="Lefthand panel - True Z function shown in magenta (cyan) for real (imaginary) parts and hybrid spectral filtered based EP/Laurent Series approximation shown in black (blue) for real (imaginary) parts, Right hand panel - Error in the real(Z) EP approximation. A comparison of the Riemann-Siegel Z function of the Riemann Zeta L-function and spectrally filtered partial Euler Product/Laurent Series (using truncation at $\\max (P,\\sqrt{((\\frac{t}{2\\pi})^1\\cdot 1}) $) in the complex plane at $\\sigma=0.9$ for the interval t=(-750,750) where $P_{min}={1,2,3,5,13}$ for rows 1-5.", out.width = c("49%","49%"), fig.show = "hold",  fig.height=3.8, warning=FALSE, cache=TRUE}

# Riemann-Siegel Z function of Riemann Zeta function on critical line
# values recorded every .01 spacing in interval [-750,+750]

dfZ=read.csv("/home/john/pari/Zzeta_res_p9_0_m750_p750_spacing_p01_real.csv",header=FALSE,colClasses = c("character"));
dfZ$V2=as.numeric(gsub(" ","",dfZ$V2));
dfZ=dfZ[order(as.numeric(dfZ$V1)),]

dfZi=read.csv("/home/john/pari/Zzeta_res_p9_0_m750_p750_spacing_p01_imag.csv",header=FALSE,colClasses = c("character"));
dfZi$V2=as.numeric(gsub(" ","",dfZi$V2));
dfZi=dfZi[order(as.numeric(dfZi$V1)),]


#Riemann-Siegel Z function of truncated Euler product at first quiescent region
#first component of riemann-siegel formula based on first quiescent region
#EP(sigma+i*t)*exp(i*theta)
#using 0 extra integers in prodeuler pari-gp function

dfplusZ=read.csv("/home/john/pari/Zplus_EP_res_p9_0_m750_p750_0extra_spacing_p01_real.csv",header=FALSE,colClasses = c("character"));
dfplusZ$V2=as.numeric(gsub(" ","",dfplusZ$V2));
dfplusZ=dfplusZ[order(as.numeric(dfplusZ$V1)),]

dfplusZi=read.csv("/home/john/pari/Zplus_EP_res_p9_0_m750_p750_0extra_spacing_p01_imag.csv",header=FALSE,colClasses = c("character"));
dfplusZi$V2=as.numeric(gsub(" ","",dfplusZi$V2));
dfplusZi=dfplusZi[order(as.numeric(dfplusZi$V1)),]

dfreal=dfplusZ;dfimag=dfplusZi

min_val=min(as.numeric(dfreal$V1));max_val=max(as.numeric(dfreal$V1))
dfimag=dfimag[(dfimag$V1 %in% dfreal$V1),]


fft_plusZ = stats::fft(dfreal$V2+1i*dfimag$V2)

dfreal_plus=dfreal
dfimag_plus=dfimag

lenf2=length(fft_plusZ)
delta_fft2=max(as.numeric(substr(dfreal$V1,1,12)))-min(as.numeric(substr(dfreal$V1,1,12)))
n=lenf2

#second component of riemann-siegel formula based on first quiescent region
#EP(1-(sigma+i*t))*chi(sigma+i*t)*exp(i*theta)
#using 0 extra integers in prodeuler pari-gp function

dfminusZ=read.csv("/home/john/pari/Zminus_EP_res_p9_0_m750_p750_0extra_spacing_p01_real.csv",header=FALSE,colClasses = c("character"));
dfminusZ$V2=as.numeric(gsub(" ","",dfminusZ$V2));
dfminusZ=dfminusZ[order(as.numeric(dfminusZ$V1)),]

dfminusZi=read.csv("/home/john/pari/Zminus_EP_res_p9_0_m750_p750_0extra_spacing_p01_imag.csv",header=FALSE,colClasses = c("character"));
dfminusZi$V2=as.numeric(gsub(" ","",dfminusZi$V2));
dfminusZi=dfminusZi[order(as.numeric(dfminusZi$V1)),]

dfreal=dfminusZ;dfimag=dfminusZi

min_val=min(as.numeric(dfreal$V1));max_val=max(as.numeric(dfreal$V1))
dfimag=dfimag[dfimag$V1 %in% dfreal$V1,]

fft_minusZ = stats::fft(dfreal$V2+1i*dfimag$V2)

dfreal_minus=dfreal
dfimag_minus=dfimag

lenf=dim(dfreal)[1]

n=dim(dfreal)[1]

min_freq=min(as.numeric(substr(dfreal$V1,1,12)))
max_freq=max(as.numeric(substr(dfreal$V1,1,12)))
delta_fft=max(as.numeric(substr(dfreal$V1,1,12)))-min(as.numeric(substr(dfreal$V1,1,12)))


#symmetric formula when sigma=0.5
#for spectral filtering of first quiescent region based Euler Product

fft_hybrid=c(1/2*(fft_plusZ[1]+fft_minusZ[1]),(fft_plusZ)[2:(ceiling(n/2)+0)],1/2*(fft_plusZ[ceiling(n/2)+1]+fft_minusZ[ceiling(n/2)+1]),fft_minusZ[(ceiling(n/2)+2):n])
inv_hybrid=fft(fft_hybrid,inverse=TRUE)

yspan=range(Re(inv_hybrid)/n,Im(inv_hybrid)/n)
plot(as.numeric(substr(dfreal$V1,1,22)),Re(inv_hybrid)/n,typ="l",
     ylim=c(-4,6),xlab="t",main="Riemann Siegel Z function analogue (using spectral filtered Euler Product) of \n Riemann Zeta function using floor(1.25*sqrt(t)/2/pi) upwards in EP",xlim=c(-40,40)+0,col="gray",cex.main=0.6);grid(col="gray")#,ylim=c(-.75,15),,xlim=c(100055,100060),xlim=c(100170,100173)
lines(as.numeric(substr(dfimag$V1,1,22)),Im(inv_hybrid)/n,col="blue")
lines(as.numeric(substr(dfZ$V1,1,22)),Re(dfZ$V2),col="magenta",lty=2)
lines(as.numeric(substr(dfZ$V1,1,22)),Re(dfZi$V2),col="cyan",lty=2)
lines(-rep((2/1.25)^2*2*pi/1,2),c(-0.5,0.5),lty=2,col="blue")
lines(rep((2/1.25)^2*2*pi/1,2),c(-0.5,0.5),lty=2,col="blue")
text(x=c(-1,1)*(2/1.25)^2*2*pi/1,y=-.67,"2")
text(x=0,y=-2,"t value when next prime is included in EP")
lines(-rep((3/1.25)^2*2*pi/1,2),c(-1.5,-0.5),lty=2,col="blue")
lines(rep((3/1.25)^2*2*pi/1,2),c(-1.5,-0.5),lty=2,col="blue")
text(x=c(-1,1)*(3/1.25)^2*2*pi/1,y=-2,"3")

plot(as.numeric(substr(dfreal$V1,1,22)),Re(inv_hybrid)/n-Re(dfZ$V2),typ="l",xlab="t",ylab="Error",main="Error in real(Z) component (using spectral filtered Euler Product approximation) of \n Riemann Zeta Z function using max(1,floor(1.25*sqrt(t/2/pi*1))) in EP",col="gray",cex.main=0.8);grid(col="gray2")

#first component of riemann-siegel formula based on first quiescent region
#EP(sigma+i*t)*exp(i*theta)
#using 2 and upwards in prodeuler pari-gp function for all t

dfplusZ=read.csv("/home/john/pari/Zplus_EP_res_p9_0_m750_p750_2upwards_spacing_p01_real.csv",header=FALSE,colClasses = c("character"));
dfplusZ$V2=as.numeric(gsub(" ","",dfplusZ$V2));
dfplusZ=dfplusZ[order(as.numeric(dfplusZ$V1)),]

dfplusZi=read.csv("/home/john/pari/Zplus_EP_res_p9_0_m750_p750_2upwards_spacing_p01_imag.csv",header=FALSE,colClasses = c("character"));
dfplusZi$V2=as.numeric(gsub(" ","",dfplusZi$V2));
dfplusZi=dfplusZi[order(as.numeric(dfplusZi$V1)),]

dfreal=dfplusZ;dfimag=dfplusZi

min_val=min(as.numeric(dfreal$V1));max_val=max(as.numeric(dfreal$V1))
dfimag=dfimag[(dfimag$V1 %in% dfreal$V1),]


fft_plusZ = stats::fft(dfreal$V2+1i*dfimag$V2)

dfreal_plus=dfreal
dfimag_plus=dfimag

lenf2=length(fft_plusZ)
delta_fft2=max(as.numeric(substr(dfreal$V1,1,12)))-min(as.numeric(substr(dfreal$V1,1,12)))
n=lenf2

#second component of riemann-siegel formula based on first quiescent region
#EP(1-(sigma+i*t))*chi(sigma+i*t)*exp(i*theta)
#using 2 and upwards in prodeuler pari-gp function for all t

dfminusZ=read.csv("/home/john/pari/Zminus_EP_res_p9_0_m750_p750_2upwards_spacing_p01_real.csv",header=FALSE,colClasses = c("character"));
dfminusZ$V2=as.numeric(gsub(" ","",dfminusZ$V2));
dfminusZ=dfminusZ[order(as.numeric(dfminusZ$V1)),]

dfminusZi=read.csv("/home/john/pari/Zminus_EP_res_p9_0_m750_p750_2upwards_spacing_p01_imag.csv",header=FALSE,colClasses = c("character"));
dfminusZi$V2=as.numeric(gsub(" ","",dfminusZi$V2));
dfminusZi=dfminusZi[order(as.numeric(dfminusZi$V1)),]

dfreal=dfminusZ;dfimag=dfminusZi

min_val=min(as.numeric(dfreal$V1));max_val=max(as.numeric(dfreal$V1))
dfimag=dfimag[dfimag$V1 %in% dfreal$V1,]

fft_minusZ = stats::fft(dfreal$V2+1i*dfimag$V2)

dfreal_minus=dfreal
dfimag_minus=dfimag

lenf=dim(dfreal)[1]

n=dim(dfreal)[1]

min_freq=min(as.numeric(substr(dfreal$V1,1,12)))
max_freq=max(as.numeric(substr(dfreal$V1,1,12)))
delta_fft=max(as.numeric(substr(dfreal$V1,1,12)))-min(as.numeric(substr(dfreal$V1,1,12)))


#symmetric formula when sigma=0.5
#for spectral filtering of first quiescent region based Euler Product

fft_hybrid=c(1/2*(fft_plusZ[1]+fft_minusZ[1]),(fft_plusZ)[2:(ceiling(n/2)+0)],1/2*(fft_plusZ[ceiling(n/2)+1]+fft_minusZ[ceiling(n/2)+1]),fft_minusZ[(ceiling(n/2)+2):n])
inv_hybrid=fft(fft_hybrid,inverse=TRUE)

yspan=range(Re(inv_hybrid)/n,Im(inv_hybrid)/n)
plot(as.numeric(substr(dfreal$V1,1,22)),Re(inv_hybrid)/n,typ="l",
     ylim=c(-4,6),xlab="t",main="Riemann Siegel Z function analogue (using spectral filtered Euler Product) of \n Riemann Zeta function using 2 upwards for all t",xlim=c(-40,40)+0,col="gray",cex.main=0.6);grid(col="gray")#,ylim=c(-.75,15),,xlim=c(100055,100060),xlim=c(100170,100173)
lines(as.numeric(substr(dfimag$V1,1,22)),Im(inv_hybrid)/n,col="blue")
lines(as.numeric(substr(dfZ$V1,1,22)),Re(dfZ$V2),col="magenta",lty=2)
lines(as.numeric(substr(dfZ$V1,1,22)),Re(dfZi$V2),col="cyan",lty=2)
lines(-rep((3/1.25)^2*2*pi/1,2),c(-1.2,-0.2),lty=2,col="blue")
lines(rep((3/1.25)^2*2*pi/1,2),c(-1.2,-0.2),lty=2,col="blue")
text(x=c(-1,1)*(3/1.25)^2*2*pi/1,y=-1.5,"3")
text(x=0,y=-2,"t value when next prime is included in EP")

plot(as.numeric(substr(dfreal$V1,1,22)),Re(inv_hybrid)/n-Re(dfZ$V2),typ="l",xlab="t",ylab="Error",main="Error in real(Z) component (using spectral filtered Euler Product approximation) of \n Riemann Zeta Z function using max(1,floor(1.25*sqrt(t/2/pi*1))) in EP",col="darkgreen",cex.main=0.8);grid(col="gray2")
# lines(-rep((3/1.25)^2*2*pi/1,2),c(0.1,0.6),lty=2,col="blue")
# lines(-rep((5/1.25)^2*2*pi/1,2),c(-0.6,-0.1),lty=2,col="blue")
# lines(-rep((7/1.25)^2*2*pi/1,2),c(-0.6,-0.1),lty=2,col="blue")
# lines(rep((3/1.25)^2*2*pi/1,2),c(0.1,0.6),lty=2,col="blue")
# lines(rep((5/1.25)^2*2*pi/1,2),c(-0.6,-0.1),lty=2,col="blue")
# lines(rep((7/1.25)^2*2*pi/1,2),c(-0.6,-0.1),lty=2,col="blue")
# text(x=c(-1,1)*(3/1.25)^2*2*pi/1,y=0.8,"3")
# text(x=c(-1,1)*(5/1.25)^2*2*pi/1,y=-0.8,"5")
# text(x=c(-1,1)*(7/1.25)^2*2*pi/1,y=-0.8,"7")
# text(x=0,y=-1.2,"t value when next prime is included in EP")


#first component of riemann-siegel formula based on first quiescent region
#EP(sigma+i*t)*exp(i*theta)
#using 3 and upwards in prodeuler pari-gp function for all t

dfplusZ=read.csv("/home/john/pari/Zplus_EP_res_p9_0_m750_p750_3upwards_spacing_p01_real.csv",header=FALSE,colClasses = c("character"));
dfplusZ$V2=as.numeric(gsub(" ","",dfplusZ$V2));
dfplusZ=dfplusZ[order(as.numeric(dfplusZ$V1)),]

dfplusZi=read.csv("/home/john/pari/Zplus_EP_res_p9_0_m750_p750_3upwards_spacing_p01_imag.csv",header=FALSE,colClasses = c("character"));
dfplusZi$V2=as.numeric(gsub(" ","",dfplusZi$V2));
dfplusZi=dfplusZi[order(as.numeric(dfplusZi$V1)),]

dfreal=dfplusZ;dfimag=dfplusZi

min_val=min(as.numeric(dfreal$V1));max_val=max(as.numeric(dfreal$V1))
dfimag=dfimag[(dfimag$V1 %in% dfreal$V1),]


fft_plusZ = stats::fft(dfreal$V2+1i*dfimag$V2)

dfreal_plus=dfreal
dfimag_plus=dfimag

lenf2=length(fft_plusZ)
delta_fft2=max(as.numeric(substr(dfreal$V1,1,12)))-min(as.numeric(substr(dfreal$V1,1,12)))
n=lenf2

#second component of riemann-siegel formula based on first quiescent region
#EP(1-(sigma+i*t))*chi(sigma+i*t)*exp(i*theta)
#using 3 and upwards in prodeuler pari-gp function for all t

dfminusZ=read.csv("/home/john/pari/Zminus_EP_res_p9_0_m750_p750_3upwards_spacing_p01_real.csv",header=FALSE,colClasses = c("character"));
dfminusZ$V2=as.numeric(gsub(" ","",dfminusZ$V2));
dfminusZ=dfminusZ[order(as.numeric(dfminusZ$V1)),]

dfminusZi=read.csv("/home/john/pari/Zminus_EP_res_p9_0_m750_p750_3upwards_spacing_p01_imag.csv",header=FALSE,colClasses = c("character"));
dfminusZi$V2=as.numeric(gsub(" ","",dfminusZi$V2));
dfminusZi=dfminusZi[order(as.numeric(dfminusZi$V1)),]

dfreal=dfminusZ;dfimag=dfminusZi

min_val=min(as.numeric(dfreal$V1));max_val=max(as.numeric(dfreal$V1))
dfimag=dfimag[dfimag$V1 %in% dfreal$V1,]

fft_minusZ = stats::fft(dfreal$V2+1i*dfimag$V2)

dfreal_minus=dfreal
dfimag_minus=dfimag

lenf=dim(dfreal)[1]

n=dim(dfreal)[1]

min_freq=min(as.numeric(substr(dfreal$V1,1,12)))
max_freq=max(as.numeric(substr(dfreal$V1,1,12)))
delta_fft=max(as.numeric(substr(dfreal$V1,1,12)))-min(as.numeric(substr(dfreal$V1,1,12)))


#symmetric formula when sigma=0.5
#for spectral filtering of first quiescent region based Euler Product

fft_hybrid=c(1/2*(fft_plusZ[1]+fft_minusZ[1]),(fft_plusZ)[2:(ceiling(n/2)+0)],1/2*(fft_plusZ[ceiling(n/2)+1]+fft_minusZ[ceiling(n/2)+1]),fft_minusZ[(ceiling(n/2)+2):n])
inv_hybrid=fft(fft_hybrid,inverse=TRUE)

yspan=range(Re(inv_hybrid)/n,Im(inv_hybrid)/n)
plot(as.numeric(substr(dfreal$V1,1,22)),Re(inv_hybrid)/n,typ="l",
     ylim=c(-4,6),xlab="t",main="Riemann Siegel Z function analogue (using spectral filtered Euler Product) of \n Riemann Zeta function using 3 upwards for all t",xlim=c(-40,40)+0,col="gray",cex.main=0.6);grid(col="gray")#,ylim=c(-.75,15),,xlim=c(100055,100060),xlim=c(100170,100173)
lines(as.numeric(substr(dfimag$V1,1,22)),Im(inv_hybrid)/n,col="blue")
lines(as.numeric(substr(dfZi$V1,1,22)),Re(dfZ$V2),col="magenta",lty=2)
lines(as.numeric(substr(dfZ$V1,1,22)),Re(dfZi$V2),col="cyan",lty=2)

plot(as.numeric(substr(dfreal$V1,1,22)),Re(inv_hybrid)/n-Re(dfZ$V2),typ="l",xlab="t",ylab="Error",main="Error in real(Z) component (using spectral filtered Euler Product approximation) of \n Riemann Zeta Z function using max(1,floor(1.25*sqrt(t/2/pi*1))) in EP",col="darkgreen",cex.main=0.8);grid(col="gray2")
# lines(-rep((5/1.25)^2*2*pi/1,2),c(-0.6,-0.1),lty=2,col="blue")
# lines(-rep((7/1.25)^2*2*pi/1,2),c(-0.6,-0.1),lty=2,col="blue")
# lines(rep((5/1.25)^2*2*pi/1,2),c(-0.6,-0.1),lty=2,col="blue")
# lines(rep((7/1.25)^2*2*pi/1,2),c(-0.6,-0.1),lty=2,col="blue")
# text(x=c(-1,1)*(5/1.25)^2*2*pi/1,y=-0.8,"5")
# text(x=c(-1,1)*(7/1.25)^2*2*pi/1,y=-0.8,"7")
# text(x=0,y=-1.2,"t value when next prime is included in EP")


#first component of riemann-siegel formula based on first quiescent region
#EP(sigma+i*t)*exp(i*theta)
#using 5 and upwards in prodeuler pari-gp function for all t

dfplusZ=read.csv("/home/john/pari/Zplus_EP_res_p9_0_m750_p750_5upwards_spacing_p01_real.csv",header=FALSE,colClasses = c("character"));
dfplusZ$V2=as.numeric(gsub(" ","",dfplusZ$V2));
dfplusZ=dfplusZ[order(as.numeric(dfplusZ$V1)),]

dfplusZi=read.csv("/home/john/pari/Zplus_EP_res_p9_0_m750_p750_5upwards_spacing_p01_imag.csv",header=FALSE,colClasses = c("character"));
dfplusZi$V2=as.numeric(gsub(" ","",dfplusZi$V2));
dfplusZi=dfplusZi[order(as.numeric(dfplusZi$V1)),]

dfreal=dfplusZ;dfimag=dfplusZi

min_val=min(as.numeric(dfreal$V1));max_val=max(as.numeric(dfreal$V1))
dfimag=dfimag[(dfimag$V1 %in% dfreal$V1),]


fft_plusZ = stats::fft(dfreal$V2+1i*dfimag$V2)

dfreal_plus=dfreal
dfimag_plus=dfimag

lenf2=length(fft_plusZ)
delta_fft2=max(as.numeric(substr(dfreal$V1,1,12)))-min(as.numeric(substr(dfreal$V1,1,12)))
n=lenf2

#second component of riemann-siegel formula based on first quiescent region
#EP(1-(sigma+i*t))*chi(sigma+i*t)*exp(i*theta)
#using 5 and upwards in prodeuler pari-gp function for all t

dfminusZ=read.csv("/home/john/pari/Zminus_EP_res_p9_0_m750_p750_5upwards_spacing_p01_real.csv",header=FALSE,colClasses = c("character"));
dfminusZ$V2=as.numeric(gsub(" ","",dfminusZ$V2));
dfminusZ=dfminusZ[order(as.numeric(dfminusZ$V1)),]

dfminusZi=read.csv("/home/john/pari/Zminus_EP_res_p9_0_m750_p750_5upwards_spacing_p01_imag.csv",header=FALSE,colClasses = c("character"));
dfminusZi$V2=as.numeric(gsub(" ","",dfminusZi$V2));
dfminusZi=dfminusZi[order(as.numeric(dfminusZi$V1)),]

dfreal=dfminusZ;dfimag=dfminusZi

min_val=min(as.numeric(dfreal$V1));max_val=max(as.numeric(dfreal$V1))
dfimag=dfimag[dfimag$V1 %in% dfreal$V1,]

fft_minusZ = stats::fft(dfreal$V2+1i*dfimag$V2)

dfreal_minus=dfreal
dfimag_minus=dfimag

lenf=dim(dfreal)[1]

n=dim(dfreal)[1]

min_freq=min(as.numeric(substr(dfreal$V1,1,12)))
max_freq=max(as.numeric(substr(dfreal$V1,1,12)))
delta_fft=max(as.numeric(substr(dfreal$V1,1,12)))-min(as.numeric(substr(dfreal$V1,1,12)))


#symmetric formula when sigma=0.5
#for spectral filtering of first quiescent region based Euler Product

fft_hybrid=c(1/2*(fft_plusZ[1]+fft_minusZ[1]),(fft_plusZ)[2:(ceiling(n/2)+0)],1/2*(fft_plusZ[ceiling(n/2)+1]+fft_minusZ[ceiling(n/2)+1]),fft_minusZ[(ceiling(n/2)+2):n])
inv_hybrid=fft(fft_hybrid,inverse=TRUE)

yspan=range(Re(inv_hybrid)/n,Im(inv_hybrid)/n)
plot(as.numeric(substr(dfreal$V1,1,22)),Re(inv_hybrid)/n,typ="l",
     ylim=c(-4,6),xlab="t",main="Riemann Siegel Z function analogue (using spectral filtered Euler Product) of \n Riemann Zeta function using 5 upwards for all t",xlim=c(-40,40)+0,col="gray",cex.main=0.6);grid(col="gray")#,ylim=c(-.75,15),,xlim=c(100055,100060),xlim=c(100170,100173)
lines(as.numeric(substr(dfimag$V1,1,22)),Im(inv_hybrid)/n,col="blue")
lines(as.numeric(substr(dfZi$V1,1,22)),Re(dfZ$V2),col="magenta",lty=2)
lines(as.numeric(substr(dfZ$V1,1,22)),Re(dfZi$V2),col="cyan",lty=2)

plot(as.numeric(substr(dfreal$V1,1,22)),Re(inv_hybrid)/n-Re(dfZ$V2),typ="l",xlab="t",ylab="Error",main="Error in real(Z) component (using spectral filtered Euler Product approximation) of \n Riemann Zeta Z function using max(1,floor(1.25*sqrt(t/2/pi*1))) in EP",col="darkgreen",cex.main=0.8);grid(col="gray2")
# lines(-rep((7/1.25)^2*2*pi/1,2),c(-0.6,-0.1),lty=2,col="blue")
# lines(rep((7/1.25)^2*2*pi/1,2),c(-0.6,-0.1),lty=2,col="blue")
# text(x=c(-1,1)*(7/1.25)^2*2*pi/1,y=-0.8,"7")
# text(x=0,y=-1.2,"t value when next prime is included in EP")
# lines(-rep((11/1.25)^2*2*pi/1,2),c(-0.6,-0.1),lty=2,col="blue")
# lines(rep((11/1.25)^2*2*pi/1,2),c(-0.6,-0.1),lty=2,col="blue")
# text(x=c(-1,1)*(11/1.25)^2*2*pi/1,y=-0.8,"11")
# lines(-rep((13/1.25)^2*2*pi/1,2),c(0.05,0.45),lty=2,col="blue")
# lines(rep((13/1.25)^2*2*pi/1,2),c(0.05,0.45),lty=2,col="blue")
# text(x=c(-1,1)*(13/1.25)^2*2*pi/1,y=0.6,"13")


#first component of riemann-siegel formula based on first quiescent region
#EP(sigma+i*t)*exp(i*theta)
#using 13 and upwards in prodeuler pari-gp function for all t

dfplusZ=read.csv("/home/john/pari/Zplus_EP_res_p9_0_m750_p750_13upwards_spacing_p01_real.csv",header=FALSE,colClasses = c("character"));
dfplusZ$V2=as.numeric(gsub(" ","",dfplusZ$V2));
dfplusZ=dfplusZ[order(as.numeric(dfplusZ$V1)),]

dfplusZi=read.csv("/home/john/pari/Zplus_EP_res_p9_0_m750_p750_13upwards_spacing_p01_imag.csv",header=FALSE,colClasses = c("character"));
dfplusZi$V2=as.numeric(gsub(" ","",dfplusZi$V2));
dfplusZi=dfplusZi[order(as.numeric(dfplusZi$V1)),]

dfreal=dfplusZ;dfimag=dfplusZi

min_val=min(as.numeric(dfreal$V1));max_val=max(as.numeric(dfreal$V1))
dfimag=dfimag[(dfimag$V1 %in% dfreal$V1),]


fft_plusZ = stats::fft(dfreal$V2+1i*dfimag$V2)

dfreal_plus=dfreal
dfimag_plus=dfimag

lenf2=length(fft_plusZ)
delta_fft2=max(as.numeric(substr(dfreal$V1,1,12)))-min(as.numeric(substr(dfreal$V1,1,12)))
n=lenf2

#second component of riemann-siegel formula based on first quiescent region
#EP(1-(sigma+i*t))*chi(sigma+i*t)*exp(i*theta)
#using 5 and upwards in prodeuler pari-gp function for all t

dfminusZ=read.csv("/home/john/pari/Zminus_EP_res_p9_0_m750_p750_13upwards_spacing_p01_real.csv",header=FALSE,colClasses = c("character"));
dfminusZ$V2=as.numeric(gsub(" ","",dfminusZ$V2));
dfminusZ=dfminusZ[order(as.numeric(dfminusZ$V1)),]

dfminusZi=read.csv("/home/john/pari/Zminus_EP_res_p9_0_m750_p750_13upwards_spacing_p01_imag.csv",header=FALSE,colClasses = c("character"));
dfminusZi$V2=as.numeric(gsub(" ","",dfminusZi$V2));
dfminusZi=dfminusZi[order(as.numeric(dfminusZi$V1)),]

dfreal=dfminusZ;dfimag=dfminusZi

min_val=min(as.numeric(dfreal$V1));max_val=max(as.numeric(dfreal$V1))
dfimag=dfimag[dfimag$V1 %in% dfreal$V1,]

fft_minusZ = stats::fft(dfreal$V2+1i*dfimag$V2)

dfreal_minus=dfreal
dfimag_minus=dfimag

lenf=dim(dfreal)[1]

n=dim(dfreal)[1]

min_freq=min(as.numeric(substr(dfreal$V1,1,12)))
max_freq=max(as.numeric(substr(dfreal$V1,1,12)))
delta_fft=max(as.numeric(substr(dfreal$V1,1,12)))-min(as.numeric(substr(dfreal$V1,1,12)))


#symmetric formula when sigma=0.5
#for spectral filtering of first quiescent region based Euler Product

fft_hybrid=c(1/2*(fft_plusZ[1]+fft_minusZ[1]),(fft_plusZ)[2:(ceiling(n/2)+0)],1/2*(fft_plusZ[ceiling(n/2)+1]+fft_minusZ[ceiling(n/2)+1]),fft_minusZ[(ceiling(n/2)+2):n])
inv_hybrid=fft(fft_hybrid,inverse=TRUE)

yspan=range(Re(inv_hybrid)/n,Im(inv_hybrid)/n)
plot(as.numeric(substr(dfreal$V1,1,22)),Re(inv_hybrid)/n,typ="l",
     ylim=c(-4,6),xlab="t",main="Riemann Siegel Z function analogue (using spectral filtered Euler Product) of \n Riemann Zeta function using 13 upwards for all t",xlim=c(-40,40)+0,col="gray",cex.main=0.6);grid(col="gray")#,ylim=c(-.75,15),,xlim=c(100055,100060),xlim=c(100170,100173)
lines(as.numeric(substr(dfimag$V1,1,22)),Im(inv_hybrid)/n,col="blue")
lines(as.numeric(substr(dfZi$V1,1,22)),Re(dfZ$V2),col="magenta",lty=2)
lines(as.numeric(substr(dfZ$V1,1,22)),Re(dfZi$V2),col="cyan",lty=2)
text(x=0,y=-3,"the join in the hybrid  EP/Laurent Series approximation \n around 4<abs(t)<5 has error",cex=0.5)

plot(as.numeric(substr(dfreal$V1,1,22)),Re(inv_hybrid)/n-Re(dfZ$V2),typ="l",xlab="t",ylab="Error",main="Error in real(Z) component (using spectral filtered Euler Product approximation) of \n Riemann Zeta Z function using max(1,floor(1.25*sqrt(t/2/pi*1))) in EP",col="darkgreen",cex.main=0.8);grid(col="gray2")
text(x=250,y=0.25,"as shown the error in joining the hybrid  EP/Laurent Series \n approximation around 4<abs(t)<5 is NOT fully resolved.",cex=0.7)

```

